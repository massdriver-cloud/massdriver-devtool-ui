
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var react = {exports: {}};

var react_development = {exports: {}};

/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
react_development.exports;

(function (module, exports) {

	{
	  (function () {

	    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {
	      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
	    }
	    var ReactVersion = '18.2.0';

	    // ATTENTION
	    // When adding new symbols to this file,
	    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
	    // The Symbol used to tag the ReactElement-like types.
	    var REACT_ELEMENT_TYPE = Symbol.for('react.element');
	    var REACT_PORTAL_TYPE = Symbol.for('react.portal');
	    var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
	    var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
	    var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
	    var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
	    var REACT_CONTEXT_TYPE = Symbol.for('react.context');
	    var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
	    var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
	    var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
	    var REACT_MEMO_TYPE = Symbol.for('react.memo');
	    var REACT_LAZY_TYPE = Symbol.for('react.lazy');
	    var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
	    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
	    var FAUX_ITERATOR_SYMBOL = '@@iterator';
	    function getIteratorFn(maybeIterable) {
	      if (maybeIterable === null || typeof maybeIterable !== 'object') {
	        return null;
	      }
	      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
	      if (typeof maybeIterator === 'function') {
	        return maybeIterator;
	      }
	      return null;
	    }

	    /**
	     * Keeps track of the current dispatcher.
	     */
	    var ReactCurrentDispatcher = {
	      /**
	       * @internal
	       * @type {ReactComponent}
	       */
	      current: null
	    };

	    /**
	     * Keeps track of the current batch's configuration such as how long an update
	     * should suspend for if it needs to.
	     */
	    var ReactCurrentBatchConfig = {
	      transition: null
	    };
	    var ReactCurrentActQueue = {
	      current: null,
	      // Used to reproduce behavior of `batchedUpdates` in legacy mode.
	      isBatchingLegacy: false,
	      didScheduleLegacyUpdate: false
	    };

	    /**
	     * Keeps track of the current owner.
	     *
	     * The current owner is the component who should own any components that are
	     * currently being constructed.
	     */
	    var ReactCurrentOwner = {
	      /**
	       * @internal
	       * @type {ReactComponent}
	       */
	      current: null
	    };
	    var ReactDebugCurrentFrame = {};
	    var currentExtraStackFrame = null;
	    function setExtraStackFrame(stack) {
	      {
	        currentExtraStackFrame = stack;
	      }
	    }
	    {
	      ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {
	        {
	          currentExtraStackFrame = stack;
	        }
	      }; // Stack implementation injected by the current renderer.

	      ReactDebugCurrentFrame.getCurrentStack = null;
	      ReactDebugCurrentFrame.getStackAddendum = function () {
	        var stack = ''; // Add an extra top frame while an element is being validated

	        if (currentExtraStackFrame) {
	          stack += currentExtraStackFrame;
	        } // Delegate to the injected renderer-specific implementation

	        var impl = ReactDebugCurrentFrame.getCurrentStack;
	        if (impl) {
	          stack += impl() || '';
	        }
	        return stack;
	      };
	    }

	    // -----------------------------------------------------------------------------

	    var enableScopeAPI = false; // Experimental Create Event Handle API.
	    var enableCacheElement = false;
	    var enableTransitionTracing = false; // No known bugs, but needs performance testing

	    var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
	    // stuff. Intended to enable React core members to more easily debug scheduling
	    // issues in DEV builds.

	    var enableDebugTracing = false; // Track which Fiber(s) schedule render work.

	    var ReactSharedInternals = {
	      ReactCurrentDispatcher: ReactCurrentDispatcher,
	      ReactCurrentBatchConfig: ReactCurrentBatchConfig,
	      ReactCurrentOwner: ReactCurrentOwner
	    };
	    {
	      ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
	      ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
	    }

	    // by calls to these methods by a Babel plugin.
	    //
	    // In PROD (or in packages without access to React internals),
	    // they are left as they are instead.

	    function warn(format) {
	      {
	        {
	          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	            args[_key - 1] = arguments[_key];
	          }
	          printWarning('warn', format, args);
	        }
	      }
	    }
	    function error(format) {
	      {
	        {
	          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	            args[_key2 - 1] = arguments[_key2];
	          }
	          printWarning('error', format, args);
	        }
	      }
	    }
	    function printWarning(level, format, args) {
	      // When changing this logic, you might want to also
	      // update consoleWithStackDev.www.js as well.
	      {
	        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
	        var stack = ReactDebugCurrentFrame.getStackAddendum();
	        if (stack !== '') {
	          format += '%s';
	          args = args.concat([stack]);
	        } // eslint-disable-next-line react-internal/safe-string-coercion

	        var argsWithFormat = args.map(function (item) {
	          return String(item);
	        }); // Careful: RN currently depends on this prefix

	        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
	        // breaks IE9: https://github.com/facebook/react/issues/13610
	        // eslint-disable-next-line react-internal/no-production-logging

	        Function.prototype.apply.call(console[level], console, argsWithFormat);
	      }
	    }
	    var didWarnStateUpdateForUnmountedComponent = {};
	    function warnNoop(publicInstance, callerName) {
	      {
	        var _constructor = publicInstance.constructor;
	        var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
	        var warningKey = componentName + "." + callerName;
	        if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
	          return;
	        }
	        error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);
	        didWarnStateUpdateForUnmountedComponent[warningKey] = true;
	      }
	    }
	    /**
	     * This is the abstract API for an update queue.
	     */

	    var ReactNoopUpdateQueue = {
	      /**
	       * Checks whether or not this composite component is mounted.
	       * @param {ReactClass} publicInstance The instance we want to test.
	       * @return {boolean} True if mounted, false otherwise.
	       * @protected
	       * @final
	       */
	      isMounted: function (publicInstance) {
	        return false;
	      },
	      /**
	       * Forces an update. This should only be invoked when it is known with
	       * certainty that we are **not** in a DOM transaction.
	       *
	       * You may want to call this when you know that some deeper aspect of the
	       * component's state has changed but `setState` was not called.
	       *
	       * This will not invoke `shouldComponentUpdate`, but it will invoke
	       * `componentWillUpdate` and `componentDidUpdate`.
	       *
	       * @param {ReactClass} publicInstance The instance that should rerender.
	       * @param {?function} callback Called after component is updated.
	       * @param {?string} callerName name of the calling function in the public API.
	       * @internal
	       */
	      enqueueForceUpdate: function (publicInstance, callback, callerName) {
	        warnNoop(publicInstance, 'forceUpdate');
	      },
	      /**
	       * Replaces all of the state. Always use this or `setState` to mutate state.
	       * You should treat `this.state` as immutable.
	       *
	       * There is no guarantee that `this.state` will be immediately updated, so
	       * accessing `this.state` after calling this method may return the old value.
	       *
	       * @param {ReactClass} publicInstance The instance that should rerender.
	       * @param {object} completeState Next state.
	       * @param {?function} callback Called after component is updated.
	       * @param {?string} callerName name of the calling function in the public API.
	       * @internal
	       */
	      enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
	        warnNoop(publicInstance, 'replaceState');
	      },
	      /**
	       * Sets a subset of the state. This only exists because _pendingState is
	       * internal. This provides a merging strategy that is not available to deep
	       * properties which is confusing. TODO: Expose pendingState or don't use it
	       * during the merge.
	       *
	       * @param {ReactClass} publicInstance The instance that should rerender.
	       * @param {object} partialState Next partial state to be merged with state.
	       * @param {?function} callback Called after component is updated.
	       * @param {?string} Name of the calling function in the public API.
	       * @internal
	       */
	      enqueueSetState: function (publicInstance, partialState, callback, callerName) {
	        warnNoop(publicInstance, 'setState');
	      }
	    };
	    var assign = Object.assign;
	    var emptyObject = {};
	    {
	      Object.freeze(emptyObject);
	    }
	    /**
	     * Base class helpers for the updating state of a component.
	     */

	    function Component(props, context, updater) {
	      this.props = props;
	      this.context = context; // If a component has string refs, we will assign a different object later.

	      this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
	      // renderer.

	      this.updater = updater || ReactNoopUpdateQueue;
	    }
	    Component.prototype.isReactComponent = {};
	    /**
	     * Sets a subset of the state. Always use this to mutate
	     * state. You should treat `this.state` as immutable.
	     *
	     * There is no guarantee that `this.state` will be immediately updated, so
	     * accessing `this.state` after calling this method may return the old value.
	     *
	     * There is no guarantee that calls to `setState` will run synchronously,
	     * as they may eventually be batched together.  You can provide an optional
	     * callback that will be executed when the call to setState is actually
	     * completed.
	     *
	     * When a function is provided to setState, it will be called at some point in
	     * the future (not synchronously). It will be called with the up to date
	     * component arguments (state, props, context). These values can be different
	     * from this.* because your function may be called after receiveProps but before
	     * shouldComponentUpdate, and this new state, props, and context will not yet be
	     * assigned to this.
	     *
	     * @param {object|function} partialState Next partial state or function to
	     *        produce next partial state to be merged with current state.
	     * @param {?function} callback Called after state is updated.
	     * @final
	     * @protected
	     */

	    Component.prototype.setState = function (partialState, callback) {
	      if (typeof partialState !== 'object' && typeof partialState !== 'function' && partialState != null) {
	        throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');
	      }
	      this.updater.enqueueSetState(this, partialState, callback, 'setState');
	    };
	    /**
	     * Forces an update. This should only be invoked when it is known with
	     * certainty that we are **not** in a DOM transaction.
	     *
	     * You may want to call this when you know that some deeper aspect of the
	     * component's state has changed but `setState` was not called.
	     *
	     * This will not invoke `shouldComponentUpdate`, but it will invoke
	     * `componentWillUpdate` and `componentDidUpdate`.
	     *
	     * @param {?function} callback Called after update is complete.
	     * @final
	     * @protected
	     */

	    Component.prototype.forceUpdate = function (callback) {
	      this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
	    };
	    /**
	     * Deprecated APIs. These APIs used to exist on classic React classes but since
	     * we would like to deprecate them, we're not going to move them over to this
	     * modern base class. Instead, we define a getter that warns if it's accessed.
	     */

	    {
	      var deprecatedAPIs = {
	        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
	        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
	      };
	      var defineDeprecationWarning = function (methodName, info) {
	        Object.defineProperty(Component.prototype, methodName, {
	          get: function () {
	            warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
	            return undefined;
	          }
	        });
	      };
	      for (var fnName in deprecatedAPIs) {
	        if (deprecatedAPIs.hasOwnProperty(fnName)) {
	          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	        }
	      }
	    }
	    function ComponentDummy() {}
	    ComponentDummy.prototype = Component.prototype;
	    /**
	     * Convenience component with default shallow equality check for sCU.
	     */

	    function PureComponent(props, context, updater) {
	      this.props = props;
	      this.context = context; // If a component has string refs, we will assign a different object later.

	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;
	    }
	    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
	    pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

	    assign(pureComponentPrototype, Component.prototype);
	    pureComponentPrototype.isPureReactComponent = true;

	    // an immutable object with a single mutable value
	    function createRef() {
	      var refObject = {
	        current: null
	      };
	      {
	        Object.seal(refObject);
	      }
	      return refObject;
	    }
	    var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare

	    function isArray(a) {
	      return isArrayImpl(a);
	    }

	    /*
	     * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol
	     * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
	     *
	     * The functions in this module will throw an easier-to-understand,
	     * easier-to-debug exception with a clear errors message message explaining the
	     * problem. (Instead of a confusing exception thrown inside the implementation
	     * of the `value` object).
	     */
	    // $FlowFixMe only called in DEV, so void return is not possible.
	    function typeName(value) {
	      {
	        // toStringTag is needed for namespaced types like Temporal.Instant
	        var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
	        var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
	        return type;
	      }
	    } // $FlowFixMe only called in DEV, so void return is not possible.

	    function willCoercionThrow(value) {
	      {
	        try {
	          testStringCoercion(value);
	          return false;
	        } catch (e) {
	          return true;
	        }
	      }
	    }
	    function testStringCoercion(value) {
	      // If you ended up here by following an exception call stack, here's what's
	      // happened: you supplied an object or symbol value to React (as a prop, key,
	      // DOM attribute, CSS property, string ref, etc.) and when React tried to
	      // coerce it to a string using `'' + value`, an exception was thrown.
	      //
	      // The most common types that will cause this exception are `Symbol` instances
	      // and Temporal objects like `Temporal.Instant`. But any object that has a
	      // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
	      // exception. (Library authors do this to prevent users from using built-in
	      // numeric operators like `+` or comparison operators like `>=` because custom
	      // methods are needed to perform accurate arithmetic or comparison.)
	      //
	      // To fix the problem, coerce this object or symbol value to a string before
	      // passing it to React. The most reliable way is usually `String(value)`.
	      //
	      // To find which value is throwing, check the browser or debugger console.
	      // Before this exception was thrown, there should be `console.error` output
	      // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
	      // problem and how that type was used: key, atrribute, input value prop, etc.
	      // In most cases, this console output also shows the component and its
	      // ancestor components where the exception happened.
	      //
	      // eslint-disable-next-line react-internal/safe-string-coercion
	      return '' + value;
	    }
	    function checkKeyStringCoercion(value) {
	      {
	        if (willCoercionThrow(value)) {
	          error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));
	          return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
	        }
	      }
	    }

	    function getWrappedName(outerType, innerType, wrapperName) {
	      var displayName = outerType.displayName;
	      if (displayName) {
	        return displayName;
	      }
	      var functionName = innerType.displayName || innerType.name || '';
	      return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
	    } // Keep in sync with react-reconciler/getComponentNameFromFiber

	    function getContextName(type) {
	      return type.displayName || 'Context';
	    } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.

	    function getComponentNameFromType(type) {
	      if (type == null) {
	        // Host root, text node or just invalid type.
	        return null;
	      }
	      {
	        if (typeof type.tag === 'number') {
	          error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
	        }
	      }
	      if (typeof type === 'function') {
	        return type.displayName || type.name || null;
	      }
	      if (typeof type === 'string') {
	        return type;
	      }
	      switch (type) {
	        case REACT_FRAGMENT_TYPE:
	          return 'Fragment';
	        case REACT_PORTAL_TYPE:
	          return 'Portal';
	        case REACT_PROFILER_TYPE:
	          return 'Profiler';
	        case REACT_STRICT_MODE_TYPE:
	          return 'StrictMode';
	        case REACT_SUSPENSE_TYPE:
	          return 'Suspense';
	        case REACT_SUSPENSE_LIST_TYPE:
	          return 'SuspenseList';
	      }
	      if (typeof type === 'object') {
	        switch (type.$$typeof) {
	          case REACT_CONTEXT_TYPE:
	            var context = type;
	            return getContextName(context) + '.Consumer';
	          case REACT_PROVIDER_TYPE:
	            var provider = type;
	            return getContextName(provider._context) + '.Provider';
	          case REACT_FORWARD_REF_TYPE:
	            return getWrappedName(type, type.render, 'ForwardRef');
	          case REACT_MEMO_TYPE:
	            var outerName = type.displayName || null;
	            if (outerName !== null) {
	              return outerName;
	            }
	            return getComponentNameFromType(type.type) || 'Memo';
	          case REACT_LAZY_TYPE:
	            {
	              var lazyComponent = type;
	              var payload = lazyComponent._payload;
	              var init = lazyComponent._init;
	              try {
	                return getComponentNameFromType(init(payload));
	              } catch (x) {
	                return null;
	              }
	            }

	          // eslint-disable-next-line no-fallthrough
	        }
	      }

	      return null;
	    }
	    var hasOwnProperty = Object.prototype.hasOwnProperty;
	    var RESERVED_PROPS = {
	      key: true,
	      ref: true,
	      __self: true,
	      __source: true
	    };
	    var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
	    {
	      didWarnAboutStringRefs = {};
	    }
	    function hasValidRef(config) {
	      {
	        if (hasOwnProperty.call(config, 'ref')) {
	          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
	          if (getter && getter.isReactWarning) {
	            return false;
	          }
	        }
	      }
	      return config.ref !== undefined;
	    }
	    function hasValidKey(config) {
	      {
	        if (hasOwnProperty.call(config, 'key')) {
	          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
	          if (getter && getter.isReactWarning) {
	            return false;
	          }
	        }
	      }
	      return config.key !== undefined;
	    }
	    function defineKeyPropWarningGetter(props, displayName) {
	      var warnAboutAccessingKey = function () {
	        {
	          if (!specialPropKeyWarningShown) {
	            specialPropKeyWarningShown = true;
	            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
	          }
	        }
	      };
	      warnAboutAccessingKey.isReactWarning = true;
	      Object.defineProperty(props, 'key', {
	        get: warnAboutAccessingKey,
	        configurable: true
	      });
	    }
	    function defineRefPropWarningGetter(props, displayName) {
	      var warnAboutAccessingRef = function () {
	        {
	          if (!specialPropRefWarningShown) {
	            specialPropRefWarningShown = true;
	            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
	          }
	        }
	      };
	      warnAboutAccessingRef.isReactWarning = true;
	      Object.defineProperty(props, 'ref', {
	        get: warnAboutAccessingRef,
	        configurable: true
	      });
	    }
	    function warnIfStringRefCannotBeAutoConverted(config) {
	      {
	        if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
	          var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
	          if (!didWarnAboutStringRefs[componentName]) {
	            error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
	            didWarnAboutStringRefs[componentName] = true;
	          }
	        }
	      }
	    }
	    /**
	     * Factory method to create a new React element. This no longer adheres to
	     * the class pattern, so do not use new to call it. Also, instanceof check
	     * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
	     * if something is a React Element.
	     *
	     * @param {*} type
	     * @param {*} props
	     * @param {*} key
	     * @param {string|object} ref
	     * @param {*} owner
	     * @param {*} self A *temporary* helper to detect places where `this` is
	     * different from the `owner` when React.createElement is called, so that we
	     * can warn. We want to get rid of owner and replace string `ref`s with arrow
	     * functions, and as long as `this` and owner are the same, there will be no
	     * change in behavior.
	     * @param {*} source An annotation object (added by a transpiler or otherwise)
	     * indicating filename, line number, and/or other information.
	     * @internal
	     */

	    var ReactElement = function (type, key, ref, self, source, owner, props) {
	      var element = {
	        // This tag allows us to uniquely identify this as a React Element
	        $$typeof: REACT_ELEMENT_TYPE,
	        // Built-in properties that belong on the element
	        type: type,
	        key: key,
	        ref: ref,
	        props: props,
	        // Record the component responsible for creating this element.
	        _owner: owner
	      };
	      {
	        // The validation flag is currently mutative. We put it on
	        // an external backing store so that we can freeze the whole object.
	        // This can be replaced with a WeakMap once they are implemented in
	        // commonly used development environments.
	        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
	        // the validation flag non-enumerable (where possible, which should
	        // include every environment we run tests in), so the test framework
	        // ignores it.

	        Object.defineProperty(element._store, 'validated', {
	          configurable: false,
	          enumerable: false,
	          writable: true,
	          value: false
	        }); // self and source are DEV only properties.

	        Object.defineProperty(element, '_self', {
	          configurable: false,
	          enumerable: false,
	          writable: false,
	          value: self
	        }); // Two elements created in two different places should be considered
	        // equal for testing purposes and therefore we hide it from enumeration.

	        Object.defineProperty(element, '_source', {
	          configurable: false,
	          enumerable: false,
	          writable: false,
	          value: source
	        });
	        if (Object.freeze) {
	          Object.freeze(element.props);
	          Object.freeze(element);
	        }
	      }
	      return element;
	    };
	    /**
	     * Create and return a new ReactElement of the given type.
	     * See https://reactjs.org/docs/react-api.html#createelement
	     */

	    function createElement(type, config, children) {
	      var propName; // Reserved names are extracted

	      var props = {};
	      var key = null;
	      var ref = null;
	      var self = null;
	      var source = null;
	      if (config != null) {
	        if (hasValidRef(config)) {
	          ref = config.ref;
	          {
	            warnIfStringRefCannotBeAutoConverted(config);
	          }
	        }
	        if (hasValidKey(config)) {
	          {
	            checkKeyStringCoercion(config.key);
	          }
	          key = '' + config.key;
	        }
	        self = config.__self === undefined ? null : config.__self;
	        source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

	        for (propName in config) {
	          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	            props[propName] = config[propName];
	          }
	        }
	      } // Children can be more than one argument, and those are transferred onto
	      // the newly allocated props object.

	      var childrenLength = arguments.length - 2;
	      if (childrenLength === 1) {
	        props.children = children;
	      } else if (childrenLength > 1) {
	        var childArray = Array(childrenLength);
	        for (var i = 0; i < childrenLength; i++) {
	          childArray[i] = arguments[i + 2];
	        }
	        {
	          if (Object.freeze) {
	            Object.freeze(childArray);
	          }
	        }
	        props.children = childArray;
	      } // Resolve default props

	      if (type && type.defaultProps) {
	        var defaultProps = type.defaultProps;
	        for (propName in defaultProps) {
	          if (props[propName] === undefined) {
	            props[propName] = defaultProps[propName];
	          }
	        }
	      }
	      {
	        if (key || ref) {
	          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
	          if (key) {
	            defineKeyPropWarningGetter(props, displayName);
	          }
	          if (ref) {
	            defineRefPropWarningGetter(props, displayName);
	          }
	        }
	      }
	      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	    }
	    function cloneAndReplaceKey(oldElement, newKey) {
	      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
	      return newElement;
	    }
	    /**
	     * Clone and return a new ReactElement using element as the starting point.
	     * See https://reactjs.org/docs/react-api.html#cloneelement
	     */

	    function cloneElement(element, config, children) {
	      if (element === null || element === undefined) {
	        throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
	      }
	      var propName; // Original props are copied

	      var props = assign({}, element.props); // Reserved names are extracted

	      var key = element.key;
	      var ref = element.ref; // Self is preserved since the owner is preserved.

	      var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
	      // transpiler, and the original source is probably a better indicator of the
	      // true owner.

	      var source = element._source; // Owner will be preserved, unless ref is overridden

	      var owner = element._owner;
	      if (config != null) {
	        if (hasValidRef(config)) {
	          // Silently steal the ref from the parent.
	          ref = config.ref;
	          owner = ReactCurrentOwner.current;
	        }
	        if (hasValidKey(config)) {
	          {
	            checkKeyStringCoercion(config.key);
	          }
	          key = '' + config.key;
	        } // Remaining properties override existing props

	        var defaultProps;
	        if (element.type && element.type.defaultProps) {
	          defaultProps = element.type.defaultProps;
	        }
	        for (propName in config) {
	          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	            if (config[propName] === undefined && defaultProps !== undefined) {
	              // Resolve default props
	              props[propName] = defaultProps[propName];
	            } else {
	              props[propName] = config[propName];
	            }
	          }
	        }
	      } // Children can be more than one argument, and those are transferred onto
	      // the newly allocated props object.

	      var childrenLength = arguments.length - 2;
	      if (childrenLength === 1) {
	        props.children = children;
	      } else if (childrenLength > 1) {
	        var childArray = Array(childrenLength);
	        for (var i = 0; i < childrenLength; i++) {
	          childArray[i] = arguments[i + 2];
	        }
	        props.children = childArray;
	      }
	      return ReactElement(element.type, key, ref, self, source, owner, props);
	    }
	    /**
	     * Verifies the object is a ReactElement.
	     * See https://reactjs.org/docs/react-api.html#isvalidelement
	     * @param {?object} object
	     * @return {boolean} True if `object` is a ReactElement.
	     * @final
	     */

	    function isValidElement(object) {
	      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	    }
	    var SEPARATOR = '.';
	    var SUBSEPARATOR = ':';
	    /**
	     * Escape and wrap key so it is safe to use as a reactid
	     *
	     * @param {string} key to be escaped.
	     * @return {string} the escaped key.
	     */

	    function escape(key) {
	      var escapeRegex = /[=:]/g;
	      var escaperLookup = {
	        '=': '=0',
	        ':': '=2'
	      };
	      var escapedString = key.replace(escapeRegex, function (match) {
	        return escaperLookup[match];
	      });
	      return '$' + escapedString;
	    }
	    /**
	     * TODO: Test that a single child and an array with one item have the same key
	     * pattern.
	     */

	    var didWarnAboutMaps = false;
	    var userProvidedKeyEscapeRegex = /\/+/g;
	    function escapeUserProvidedKey(text) {
	      return text.replace(userProvidedKeyEscapeRegex, '$&/');
	    }
	    /**
	     * Generate a key string that identifies a element within a set.
	     *
	     * @param {*} element A element that could contain a manual key.
	     * @param {number} index Index that is used if a manual key is not provided.
	     * @return {string}
	     */

	    function getElementKey(element, index) {
	      // Do some typechecking here since we call this blindly. We want to ensure
	      // that we don't block potential future ES APIs.
	      if (typeof element === 'object' && element !== null && element.key != null) {
	        // Explicit key
	        {
	          checkKeyStringCoercion(element.key);
	        }
	        return escape('' + element.key);
	      } // Implicit key determined by the index in the set

	      return index.toString(36);
	    }
	    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
	      var type = typeof children;
	      if (type === 'undefined' || type === 'boolean') {
	        // All of the above are perceived as null.
	        children = null;
	      }
	      var invokeCallback = false;
	      if (children === null) {
	        invokeCallback = true;
	      } else {
	        switch (type) {
	          case 'string':
	          case 'number':
	            invokeCallback = true;
	            break;
	          case 'object':
	            switch (children.$$typeof) {
	              case REACT_ELEMENT_TYPE:
	              case REACT_PORTAL_TYPE:
	                invokeCallback = true;
	            }
	        }
	      }
	      if (invokeCallback) {
	        var _child = children;
	        var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array
	        // so that it's consistent if the number of children grows:

	        var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
	        if (isArray(mappedChild)) {
	          var escapedChildKey = '';
	          if (childKey != null) {
	            escapedChildKey = escapeUserProvidedKey(childKey) + '/';
	          }
	          mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {
	            return c;
	          });
	        } else if (mappedChild != null) {
	          if (isValidElement(mappedChild)) {
	            {
	              // The `if` statement here prevents auto-disabling of the safe
	              // coercion ESLint rule, so we must manually disable it below.
	              // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
	              if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
	                checkKeyStringCoercion(mappedChild.key);
	              }
	            }
	            mappedChild = cloneAndReplaceKey(mappedChild,
	            // Keep both the (mapped) and old keys if they differ, just as
	            // traverseAllChildren used to do for objects as children
	            escapedPrefix + (
	            // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
	            mappedChild.key && (!_child || _child.key !== mappedChild.key) ?
	            // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
	            // eslint-disable-next-line react-internal/safe-string-coercion
	            escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
	          }
	          array.push(mappedChild);
	        }
	        return 1;
	      }
	      var child;
	      var nextName;
	      var subtreeCount = 0; // Count of children found in the current subtree.

	      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
	      if (isArray(children)) {
	        for (var i = 0; i < children.length; i++) {
	          child = children[i];
	          nextName = nextNamePrefix + getElementKey(child, i);
	          subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
	        }
	      } else {
	        var iteratorFn = getIteratorFn(children);
	        if (typeof iteratorFn === 'function') {
	          var iterableChildren = children;
	          {
	            // Warn about using Maps as children
	            if (iteratorFn === iterableChildren.entries) {
	              if (!didWarnAboutMaps) {
	                warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
	              }
	              didWarnAboutMaps = true;
	            }
	          }
	          var iterator = iteratorFn.call(iterableChildren);
	          var step;
	          var ii = 0;
	          while (!(step = iterator.next()).done) {
	            child = step.value;
	            nextName = nextNamePrefix + getElementKey(child, ii++);
	            subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
	          }
	        } else if (type === 'object') {
	          // eslint-disable-next-line react-internal/safe-string-coercion
	          var childrenString = String(children);
	          throw new Error("Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). " + 'If you meant to render a collection of children, use an array ' + 'instead.');
	        }
	      }
	      return subtreeCount;
	    }

	    /**
	     * Maps children that are typically specified as `props.children`.
	     *
	     * See https://reactjs.org/docs/react-api.html#reactchildrenmap
	     *
	     * The provided mapFunction(child, index) will be called for each
	     * leaf child.
	     *
	     * @param {?*} children Children tree container.
	     * @param {function(*, int)} func The map function.
	     * @param {*} context Context for mapFunction.
	     * @return {object} Object containing the ordered map of results.
	     */
	    function mapChildren(children, func, context) {
	      if (children == null) {
	        return children;
	      }
	      var result = [];
	      var count = 0;
	      mapIntoArray(children, result, '', '', function (child) {
	        return func.call(context, child, count++);
	      });
	      return result;
	    }
	    /**
	     * Count the number of children that are typically specified as
	     * `props.children`.
	     *
	     * See https://reactjs.org/docs/react-api.html#reactchildrencount
	     *
	     * @param {?*} children Children tree container.
	     * @return {number} The number of children.
	     */

	    function countChildren(children) {
	      var n = 0;
	      mapChildren(children, function () {
	        n++; // Don't return anything
	      });

	      return n;
	    }

	    /**
	     * Iterates through children that are typically specified as `props.children`.
	     *
	     * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
	     *
	     * The provided forEachFunc(child, index) will be called for each
	     * leaf child.
	     *
	     * @param {?*} children Children tree container.
	     * @param {function(*, int)} forEachFunc
	     * @param {*} forEachContext Context for forEachContext.
	     */
	    function forEachChildren(children, forEachFunc, forEachContext) {
	      mapChildren(children, function () {
	        forEachFunc.apply(this, arguments); // Don't return anything.
	      }, forEachContext);
	    }
	    /**
	     * Flatten a children object (typically specified as `props.children`) and
	     * return an array with appropriately re-keyed children.
	     *
	     * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
	     */

	    function toArray(children) {
	      return mapChildren(children, function (child) {
	        return child;
	      }) || [];
	    }
	    /**
	     * Returns the first child in a collection of children and verifies that there
	     * is only one child in the collection.
	     *
	     * See https://reactjs.org/docs/react-api.html#reactchildrenonly
	     *
	     * The current implementation of this function assumes that a single child gets
	     * passed without a wrapper, but the purpose of this helper function is to
	     * abstract away the particular structure of children.
	     *
	     * @param {?object} children Child collection structure.
	     * @return {ReactElement} The first and only `ReactElement` contained in the
	     * structure.
	     */

	    function onlyChild(children) {
	      if (!isValidElement(children)) {
	        throw new Error('React.Children.only expected to receive a single React element child.');
	      }
	      return children;
	    }
	    function createContext(defaultValue) {
	      // TODO: Second argument used to be an optional `calculateChangedBits`
	      // function. Warn to reserve for future use?
	      var context = {
	        $$typeof: REACT_CONTEXT_TYPE,
	        // As a workaround to support multiple concurrent renderers, we categorize
	        // some renderers as primary and others as secondary. We only expect
	        // there to be two concurrent renderers at most: React Native (primary) and
	        // Fabric (secondary); React DOM (primary) and React ART (secondary).
	        // Secondary renderers store their context values on separate fields.
	        _currentValue: defaultValue,
	        _currentValue2: defaultValue,
	        // Used to track how many concurrent renderers this context currently
	        // supports within in a single renderer. Such as parallel server rendering.
	        _threadCount: 0,
	        // These are circular
	        Provider: null,
	        Consumer: null,
	        // Add these to use same hidden class in VM as ServerContext
	        _defaultValue: null,
	        _globalName: null
	      };
	      context.Provider = {
	        $$typeof: REACT_PROVIDER_TYPE,
	        _context: context
	      };
	      var hasWarnedAboutUsingNestedContextConsumers = false;
	      var hasWarnedAboutUsingConsumerProvider = false;
	      var hasWarnedAboutDisplayNameOnConsumer = false;
	      {
	        // A separate object, but proxies back to the original context object for
	        // backwards compatibility. It has a different $$typeof, so we can properly
	        // warn for the incorrect usage of Context as a Consumer.
	        var Consumer = {
	          $$typeof: REACT_CONTEXT_TYPE,
	          _context: context
	        }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

	        Object.defineProperties(Consumer, {
	          Provider: {
	            get: function () {
	              if (!hasWarnedAboutUsingConsumerProvider) {
	                hasWarnedAboutUsingConsumerProvider = true;
	                error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
	              }
	              return context.Provider;
	            },
	            set: function (_Provider) {
	              context.Provider = _Provider;
	            }
	          },
	          _currentValue: {
	            get: function () {
	              return context._currentValue;
	            },
	            set: function (_currentValue) {
	              context._currentValue = _currentValue;
	            }
	          },
	          _currentValue2: {
	            get: function () {
	              return context._currentValue2;
	            },
	            set: function (_currentValue2) {
	              context._currentValue2 = _currentValue2;
	            }
	          },
	          _threadCount: {
	            get: function () {
	              return context._threadCount;
	            },
	            set: function (_threadCount) {
	              context._threadCount = _threadCount;
	            }
	          },
	          Consumer: {
	            get: function () {
	              if (!hasWarnedAboutUsingNestedContextConsumers) {
	                hasWarnedAboutUsingNestedContextConsumers = true;
	                error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
	              }
	              return context.Consumer;
	            }
	          },
	          displayName: {
	            get: function () {
	              return context.displayName;
	            },
	            set: function (displayName) {
	              if (!hasWarnedAboutDisplayNameOnConsumer) {
	                warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);
	                hasWarnedAboutDisplayNameOnConsumer = true;
	              }
	            }
	          }
	        }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

	        context.Consumer = Consumer;
	      }
	      {
	        context._currentRenderer = null;
	        context._currentRenderer2 = null;
	      }
	      return context;
	    }
	    var Uninitialized = -1;
	    var Pending = 0;
	    var Resolved = 1;
	    var Rejected = 2;
	    function lazyInitializer(payload) {
	      if (payload._status === Uninitialized) {
	        var ctor = payload._result;
	        var thenable = ctor(); // Transition to the next state.
	        // This might throw either because it's missing or throws. If so, we treat it
	        // as still uninitialized and try again next time. Which is the same as what
	        // happens if the ctor or any wrappers processing the ctor throws. This might
	        // end up fixing it if the resolution was a concurrency bug.

	        thenable.then(function (moduleObject) {
	          if (payload._status === Pending || payload._status === Uninitialized) {
	            // Transition to the next state.
	            var resolved = payload;
	            resolved._status = Resolved;
	            resolved._result = moduleObject;
	          }
	        }, function (error) {
	          if (payload._status === Pending || payload._status === Uninitialized) {
	            // Transition to the next state.
	            var rejected = payload;
	            rejected._status = Rejected;
	            rejected._result = error;
	          }
	        });
	        if (payload._status === Uninitialized) {
	          // In case, we're still uninitialized, then we're waiting for the thenable
	          // to resolve. Set it as pending in the meantime.
	          var pending = payload;
	          pending._status = Pending;
	          pending._result = thenable;
	        }
	      }
	      if (payload._status === Resolved) {
	        var moduleObject = payload._result;
	        {
	          if (moduleObject === undefined) {
	            error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' +
	            // Break up imports to avoid accidentally parsing them as dependencies.
	            'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))\n\n" + 'Did you accidentally put curly braces around the import?', moduleObject);
	          }
	        }
	        {
	          if (!('default' in moduleObject)) {
	            error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' +
	            // Break up imports to avoid accidentally parsing them as dependencies.
	            'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
	          }
	        }
	        return moduleObject.default;
	      } else {
	        throw payload._result;
	      }
	    }
	    function lazy(ctor) {
	      var payload = {
	        // We use these fields to store the result.
	        _status: Uninitialized,
	        _result: ctor
	      };
	      var lazyType = {
	        $$typeof: REACT_LAZY_TYPE,
	        _payload: payload,
	        _init: lazyInitializer
	      };
	      {
	        // In production, this would just set it on the object.
	        var defaultProps;
	        var propTypes; // $FlowFixMe

	        Object.defineProperties(lazyType, {
	          defaultProps: {
	            configurable: true,
	            get: function () {
	              return defaultProps;
	            },
	            set: function (newDefaultProps) {
	              error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
	              defaultProps = newDefaultProps; // Match production behavior more closely:
	              // $FlowFixMe

	              Object.defineProperty(lazyType, 'defaultProps', {
	                enumerable: true
	              });
	            }
	          },
	          propTypes: {
	            configurable: true,
	            get: function () {
	              return propTypes;
	            },
	            set: function (newPropTypes) {
	              error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
	              propTypes = newPropTypes; // Match production behavior more closely:
	              // $FlowFixMe

	              Object.defineProperty(lazyType, 'propTypes', {
	                enumerable: true
	              });
	            }
	          }
	        });
	      }
	      return lazyType;
	    }
	    function forwardRef(render) {
	      {
	        if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
	          error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
	        } else if (typeof render !== 'function') {
	          error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
	        } else {
	          if (render.length !== 0 && render.length !== 2) {
	            error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
	          }
	        }
	        if (render != null) {
	          if (render.defaultProps != null || render.propTypes != null) {
	            error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
	          }
	        }
	      }
	      var elementType = {
	        $$typeof: REACT_FORWARD_REF_TYPE,
	        render: render
	      };
	      {
	        var ownName;
	        Object.defineProperty(elementType, 'displayName', {
	          enumerable: false,
	          configurable: true,
	          get: function () {
	            return ownName;
	          },
	          set: function (name) {
	            ownName = name; // The inner component shouldn't inherit this display name in most cases,
	            // because the component may be used elsewhere.
	            // But it's nice for anonymous functions to inherit the name,
	            // so that our component-stack generation logic will display their frames.
	            // An anonymous function generally suggests a pattern like:
	            //   React.forwardRef((props, ref) => {...});
	            // This kind of inner function is not used elsewhere so the side effect is okay.

	            if (!render.name && !render.displayName) {
	              render.displayName = name;
	            }
	          }
	        });
	      }
	      return elementType;
	    }
	    var REACT_MODULE_REFERENCE;
	    {
	      REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
	    }
	    function isValidElementType(type) {
	      if (typeof type === 'string' || typeof type === 'function') {
	        return true;
	      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).

	      if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
	        return true;
	      }
	      if (typeof type === 'object' && type !== null) {
	        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE ||
	        // This needs to include all possible module reference object
	        // types supported by any Flight configuration anywhere since
	        // we don't know which Flight build this will end up being used
	        // with.
	        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
	          return true;
	        }
	      }
	      return false;
	    }
	    function memo(type, compare) {
	      {
	        if (!isValidElementType(type)) {
	          error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
	        }
	      }
	      var elementType = {
	        $$typeof: REACT_MEMO_TYPE,
	        type: type,
	        compare: compare === undefined ? null : compare
	      };
	      {
	        var ownName;
	        Object.defineProperty(elementType, 'displayName', {
	          enumerable: false,
	          configurable: true,
	          get: function () {
	            return ownName;
	          },
	          set: function (name) {
	            ownName = name; // The inner component shouldn't inherit this display name in most cases,
	            // because the component may be used elsewhere.
	            // But it's nice for anonymous functions to inherit the name,
	            // so that our component-stack generation logic will display their frames.
	            // An anonymous function generally suggests a pattern like:
	            //   React.memo((props) => {...});
	            // This kind of inner function is not used elsewhere so the side effect is okay.

	            if (!type.name && !type.displayName) {
	              type.displayName = name;
	            }
	          }
	        });
	      }
	      return elementType;
	    }
	    function resolveDispatcher() {
	      var dispatcher = ReactCurrentDispatcher.current;
	      {
	        if (dispatcher === null) {
	          error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' + '2. You might be breaking the Rules of Hooks\n' + '3. You might have more than one copy of React in the same app\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');
	        }
	      } // Will result in a null access error if accessed outside render phase. We
	      // intentionally don't throw our own error because this is in a hot path.
	      // Also helps ensure this is inlined.

	      return dispatcher;
	    }
	    function useContext(Context) {
	      var dispatcher = resolveDispatcher();
	      {
	        // TODO: add a more generic warning for invalid values.
	        if (Context._context !== undefined) {
	          var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
	          // and nobody should be using this in existing code.

	          if (realContext.Consumer === Context) {
	            error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
	          } else if (realContext.Provider === Context) {
	            error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
	          }
	        }
	      }
	      return dispatcher.useContext(Context);
	    }
	    function useState(initialState) {
	      var dispatcher = resolveDispatcher();
	      return dispatcher.useState(initialState);
	    }
	    function useReducer(reducer, initialArg, init) {
	      var dispatcher = resolveDispatcher();
	      return dispatcher.useReducer(reducer, initialArg, init);
	    }
	    function useRef(initialValue) {
	      var dispatcher = resolveDispatcher();
	      return dispatcher.useRef(initialValue);
	    }
	    function useEffect(create, deps) {
	      var dispatcher = resolveDispatcher();
	      return dispatcher.useEffect(create, deps);
	    }
	    function useInsertionEffect(create, deps) {
	      var dispatcher = resolveDispatcher();
	      return dispatcher.useInsertionEffect(create, deps);
	    }
	    function useLayoutEffect(create, deps) {
	      var dispatcher = resolveDispatcher();
	      return dispatcher.useLayoutEffect(create, deps);
	    }
	    function useCallback(callback, deps) {
	      var dispatcher = resolveDispatcher();
	      return dispatcher.useCallback(callback, deps);
	    }
	    function useMemo(create, deps) {
	      var dispatcher = resolveDispatcher();
	      return dispatcher.useMemo(create, deps);
	    }
	    function useImperativeHandle(ref, create, deps) {
	      var dispatcher = resolveDispatcher();
	      return dispatcher.useImperativeHandle(ref, create, deps);
	    }
	    function useDebugValue(value, formatterFn) {
	      {
	        var dispatcher = resolveDispatcher();
	        return dispatcher.useDebugValue(value, formatterFn);
	      }
	    }
	    function useTransition() {
	      var dispatcher = resolveDispatcher();
	      return dispatcher.useTransition();
	    }
	    function useDeferredValue(value) {
	      var dispatcher = resolveDispatcher();
	      return dispatcher.useDeferredValue(value);
	    }
	    function useId() {
	      var dispatcher = resolveDispatcher();
	      return dispatcher.useId();
	    }
	    function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
	      var dispatcher = resolveDispatcher();
	      return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
	    }

	    // Helpers to patch console.logs to avoid logging during side-effect free
	    // replaying on render function. This currently only patches the object
	    // lazily which won't cover if the log function was extracted eagerly.
	    // We could also eagerly patch the method.
	    var disabledDepth = 0;
	    var prevLog;
	    var prevInfo;
	    var prevWarn;
	    var prevError;
	    var prevGroup;
	    var prevGroupCollapsed;
	    var prevGroupEnd;
	    function disabledLog() {}
	    disabledLog.__reactDisabledLog = true;
	    function disableLogs() {
	      {
	        if (disabledDepth === 0) {
	          /* eslint-disable react-internal/no-production-logging */
	          prevLog = console.log;
	          prevInfo = console.info;
	          prevWarn = console.warn;
	          prevError = console.error;
	          prevGroup = console.group;
	          prevGroupCollapsed = console.groupCollapsed;
	          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

	          var props = {
	            configurable: true,
	            enumerable: true,
	            value: disabledLog,
	            writable: true
	          }; // $FlowFixMe Flow thinks console is immutable.

	          Object.defineProperties(console, {
	            info: props,
	            log: props,
	            warn: props,
	            error: props,
	            group: props,
	            groupCollapsed: props,
	            groupEnd: props
	          });
	          /* eslint-enable react-internal/no-production-logging */
	        }

	        disabledDepth++;
	      }
	    }
	    function reenableLogs() {
	      {
	        disabledDepth--;
	        if (disabledDepth === 0) {
	          /* eslint-disable react-internal/no-production-logging */
	          var props = {
	            configurable: true,
	            enumerable: true,
	            writable: true
	          }; // $FlowFixMe Flow thinks console is immutable.

	          Object.defineProperties(console, {
	            log: assign({}, props, {
	              value: prevLog
	            }),
	            info: assign({}, props, {
	              value: prevInfo
	            }),
	            warn: assign({}, props, {
	              value: prevWarn
	            }),
	            error: assign({}, props, {
	              value: prevError
	            }),
	            group: assign({}, props, {
	              value: prevGroup
	            }),
	            groupCollapsed: assign({}, props, {
	              value: prevGroupCollapsed
	            }),
	            groupEnd: assign({}, props, {
	              value: prevGroupEnd
	            })
	          });
	          /* eslint-enable react-internal/no-production-logging */
	        }

	        if (disabledDepth < 0) {
	          error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
	        }
	      }
	    }
	    var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
	    var prefix;
	    function describeBuiltInComponentFrame(name, source, ownerFn) {
	      {
	        if (prefix === undefined) {
	          // Extract the VM specific prefix used by each line.
	          try {
	            throw Error();
	          } catch (x) {
	            var match = x.stack.trim().match(/\n( *(at )?)/);
	            prefix = match && match[1] || '';
	          }
	        } // We use the prefix to ensure our stacks line up with native stack frames.

	        return '\n' + prefix + name;
	      }
	    }
	    var reentry = false;
	    var componentFrameCache;
	    {
	      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
	      componentFrameCache = new PossiblyWeakMap();
	    }
	    function describeNativeComponentFrame(fn, construct) {
	      // If something asked for a stack inside a fake render, it should get ignored.
	      if (!fn || reentry) {
	        return '';
	      }
	      {
	        var frame = componentFrameCache.get(fn);
	        if (frame !== undefined) {
	          return frame;
	        }
	      }
	      var control;
	      reentry = true;
	      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

	      Error.prepareStackTrace = undefined;
	      var previousDispatcher;
	      {
	        previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function
	        // for warnings.

	        ReactCurrentDispatcher$1.current = null;
	        disableLogs();
	      }
	      try {
	        // This should throw.
	        if (construct) {
	          // Something should be setting the props in the constructor.
	          var Fake = function () {
	            throw Error();
	          }; // $FlowFixMe

	          Object.defineProperty(Fake.prototype, 'props', {
	            set: function () {
	              // We use a throwing setter instead of frozen or non-writable props
	              // because that won't throw in a non-strict mode function.
	              throw Error();
	            }
	          });
	          if (typeof Reflect === 'object' && Reflect.construct) {
	            // We construct a different control for this case to include any extra
	            // frames added by the construct call.
	            try {
	              Reflect.construct(Fake, []);
	            } catch (x) {
	              control = x;
	            }
	            Reflect.construct(fn, [], Fake);
	          } else {
	            try {
	              Fake.call();
	            } catch (x) {
	              control = x;
	            }
	            fn.call(Fake.prototype);
	          }
	        } else {
	          try {
	            throw Error();
	          } catch (x) {
	            control = x;
	          }
	          fn();
	        }
	      } catch (sample) {
	        // This is inlined manually because closure doesn't do it for us.
	        if (sample && control && typeof sample.stack === 'string') {
	          // This extracts the first frame from the sample that isn't also in the control.
	          // Skipping one frame that we assume is the frame that calls the two.
	          var sampleLines = sample.stack.split('\n');
	          var controlLines = control.stack.split('\n');
	          var s = sampleLines.length - 1;
	          var c = controlLines.length - 1;
	          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
	            // We expect at least one stack frame to be shared.
	            // Typically this will be the root most one. However, stack frames may be
	            // cut off due to maximum stack limits. In this case, one maybe cut off
	            // earlier than the other. We assume that the sample is longer or the same
	            // and there for cut off earlier. So we should find the root most frame in
	            // the sample somewhere in the control.
	            c--;
	          }
	          for (; s >= 1 && c >= 0; s--, c--) {
	            // Next we find the first one that isn't the same which should be the
	            // frame that called our sample function and the control.
	            if (sampleLines[s] !== controlLines[c]) {
	              // In V8, the first line is describing the message but other VMs don't.
	              // If we're about to return the first line, and the control is also on the same
	              // line, that's a pretty good indicator that our sample threw at same line as
	              // the control. I.e. before we entered the sample frame. So we ignore this result.
	              // This can happen if you passed a class to function component, or non-function.
	              if (s !== 1 || c !== 1) {
	                do {
	                  s--;
	                  c--; // We may still have similar intermediate frames from the construct call.
	                  // The next one that isn't the same should be our match though.

	                  if (c < 0 || sampleLines[s] !== controlLines[c]) {
	                    // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
	                    var _frame = '\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled "<anonymous>"
	                    // but we have a user-provided "displayName"
	                    // splice it in to make the stack more readable.

	                    if (fn.displayName && _frame.includes('<anonymous>')) {
	                      _frame = _frame.replace('<anonymous>', fn.displayName);
	                    }
	                    {
	                      if (typeof fn === 'function') {
	                        componentFrameCache.set(fn, _frame);
	                      }
	                    } // Return the line we found.

	                    return _frame;
	                  }
	                } while (s >= 1 && c >= 0);
	              }
	              break;
	            }
	          }
	        }
	      } finally {
	        reentry = false;
	        {
	          ReactCurrentDispatcher$1.current = previousDispatcher;
	          reenableLogs();
	        }
	        Error.prepareStackTrace = previousPrepareStackTrace;
	      } // Fallback to just using the name if we couldn't make it throw.

	      var name = fn ? fn.displayName || fn.name : '';
	      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
	      {
	        if (typeof fn === 'function') {
	          componentFrameCache.set(fn, syntheticFrame);
	        }
	      }
	      return syntheticFrame;
	    }
	    function describeFunctionComponentFrame(fn, source, ownerFn) {
	      {
	        return describeNativeComponentFrame(fn, false);
	      }
	    }
	    function shouldConstruct(Component) {
	      var prototype = Component.prototype;
	      return !!(prototype && prototype.isReactComponent);
	    }
	    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
	      if (type == null) {
	        return '';
	      }
	      if (typeof type === 'function') {
	        {
	          return describeNativeComponentFrame(type, shouldConstruct(type));
	        }
	      }
	      if (typeof type === 'string') {
	        return describeBuiltInComponentFrame(type);
	      }
	      switch (type) {
	        case REACT_SUSPENSE_TYPE:
	          return describeBuiltInComponentFrame('Suspense');
	        case REACT_SUSPENSE_LIST_TYPE:
	          return describeBuiltInComponentFrame('SuspenseList');
	      }
	      if (typeof type === 'object') {
	        switch (type.$$typeof) {
	          case REACT_FORWARD_REF_TYPE:
	            return describeFunctionComponentFrame(type.render);
	          case REACT_MEMO_TYPE:
	            // Memo may contain any component type so we recursively resolve it.
	            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
	          case REACT_LAZY_TYPE:
	            {
	              var lazyComponent = type;
	              var payload = lazyComponent._payload;
	              var init = lazyComponent._init;
	              try {
	                // Lazy may contain any component type so we recursively resolve it.
	                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
	              } catch (x) {}
	            }
	        }
	      }
	      return '';
	    }
	    var loggedTypeFailures = {};
	    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
	    function setCurrentlyValidatingElement(element) {
	      {
	        if (element) {
	          var owner = element._owner;
	          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
	          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
	        } else {
	          ReactDebugCurrentFrame$1.setExtraStackFrame(null);
	        }
	      }
	    }
	    function checkPropTypes(typeSpecs, values, location, componentName, element) {
	      {
	        // $FlowFixMe This is okay but Flow doesn't know it.
	        var has = Function.call.bind(hasOwnProperty);
	        for (var typeSpecName in typeSpecs) {
	          if (has(typeSpecs, typeSpecName)) {
	            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
	            // fail the render phase where it didn't fail before. So we log it.
	            // After these have been cleaned up, we'll let them throw.

	            try {
	              // This is intentionally an invariant that gets caught. It's the same
	              // behavior as without this statement except with a better message.
	              if (typeof typeSpecs[typeSpecName] !== 'function') {
	                // eslint-disable-next-line react-internal/prod-error-codes
	                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
	                err.name = 'Invariant Violation';
	                throw err;
	              }
	              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
	            } catch (ex) {
	              error$1 = ex;
	            }
	            if (error$1 && !(error$1 instanceof Error)) {
	              setCurrentlyValidatingElement(element);
	              error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);
	              setCurrentlyValidatingElement(null);
	            }
	            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
	              // Only monitor this failure once because there tends to be a lot of the
	              // same error.
	              loggedTypeFailures[error$1.message] = true;
	              setCurrentlyValidatingElement(element);
	              error('Failed %s type: %s', location, error$1.message);
	              setCurrentlyValidatingElement(null);
	            }
	          }
	        }
	      }
	    }
	    function setCurrentlyValidatingElement$1(element) {
	      {
	        if (element) {
	          var owner = element._owner;
	          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
	          setExtraStackFrame(stack);
	        } else {
	          setExtraStackFrame(null);
	        }
	      }
	    }
	    var propTypesMisspellWarningShown;
	    {
	      propTypesMisspellWarningShown = false;
	    }
	    function getDeclarationErrorAddendum() {
	      if (ReactCurrentOwner.current) {
	        var name = getComponentNameFromType(ReactCurrentOwner.current.type);
	        if (name) {
	          return '\n\nCheck the render method of `' + name + '`.';
	        }
	      }
	      return '';
	    }
	    function getSourceInfoErrorAddendum(source) {
	      if (source !== undefined) {
	        var fileName = source.fileName.replace(/^.*[\\\/]/, '');
	        var lineNumber = source.lineNumber;
	        return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
	      }
	      return '';
	    }
	    function getSourceInfoErrorAddendumForProps(elementProps) {
	      if (elementProps !== null && elementProps !== undefined) {
	        return getSourceInfoErrorAddendum(elementProps.__source);
	      }
	      return '';
	    }
	    /**
	     * Warn if there's no key explicitly set on dynamic arrays of children or
	     * object keys are not valid. This allows us to keep track of children between
	     * updates.
	     */

	    var ownerHasKeyUseWarning = {};
	    function getCurrentComponentErrorInfo(parentType) {
	      var info = getDeclarationErrorAddendum();
	      if (!info) {
	        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
	        if (parentName) {
	          info = "\n\nCheck the top-level render call using <" + parentName + ">.";
	        }
	      }
	      return info;
	    }
	    /**
	     * Warn if the element doesn't have an explicit key assigned to it.
	     * This element is in an array. The array could grow and shrink or be
	     * reordered. All children that haven't already been validated are required to
	     * have a "key" property assigned to it. Error statuses are cached so a warning
	     * will only be shown once.
	     *
	     * @internal
	     * @param {ReactElement} element Element that requires a key.
	     * @param {*} parentType element's parent's type.
	     */

	    function validateExplicitKey(element, parentType) {
	      if (!element._store || element._store.validated || element.key != null) {
	        return;
	      }
	      element._store.validated = true;
	      var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
	      if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
	        return;
	      }
	      ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
	      // property, it may be the creator of the child that's responsible for
	      // assigning it a key.

	      var childOwner = '';
	      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
	        // Give the component that originally created this child.
	        childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
	      }
	      {
	        setCurrentlyValidatingElement$1(element);
	        error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
	        setCurrentlyValidatingElement$1(null);
	      }
	    }
	    /**
	     * Ensure that every element either is passed in a static location, in an
	     * array with an explicit keys property defined, or in an object literal
	     * with valid key property.
	     *
	     * @internal
	     * @param {ReactNode} node Statically passed child of any type.
	     * @param {*} parentType node's parent's type.
	     */

	    function validateChildKeys(node, parentType) {
	      if (typeof node !== 'object') {
	        return;
	      }
	      if (isArray(node)) {
	        for (var i = 0; i < node.length; i++) {
	          var child = node[i];
	          if (isValidElement(child)) {
	            validateExplicitKey(child, parentType);
	          }
	        }
	      } else if (isValidElement(node)) {
	        // This element was passed in a valid location.
	        if (node._store) {
	          node._store.validated = true;
	        }
	      } else if (node) {
	        var iteratorFn = getIteratorFn(node);
	        if (typeof iteratorFn === 'function') {
	          // Entry iterators used to provide implicit keys,
	          // but now we print a separate warning for them later.
	          if (iteratorFn !== node.entries) {
	            var iterator = iteratorFn.call(node);
	            var step;
	            while (!(step = iterator.next()).done) {
	              if (isValidElement(step.value)) {
	                validateExplicitKey(step.value, parentType);
	              }
	            }
	          }
	        }
	      }
	    }
	    /**
	     * Given an element, validate that its props follow the propTypes definition,
	     * provided by the type.
	     *
	     * @param {ReactElement} element
	     */

	    function validatePropTypes(element) {
	      {
	        var type = element.type;
	        if (type === null || type === undefined || typeof type === 'string') {
	          return;
	        }
	        var propTypes;
	        if (typeof type === 'function') {
	          propTypes = type.propTypes;
	        } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE ||
	        // Note: Memo only checks outer props here.
	        // Inner props are checked in the reconciler.
	        type.$$typeof === REACT_MEMO_TYPE)) {
	          propTypes = type.propTypes;
	        } else {
	          return;
	        }
	        if (propTypes) {
	          // Intentionally inside to avoid triggering lazy initializers:
	          var name = getComponentNameFromType(type);
	          checkPropTypes(propTypes, element.props, 'prop', name, element);
	        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
	          propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

	          var _name = getComponentNameFromType(type);
	          error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
	        }
	        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
	          error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
	        }
	      }
	    }
	    /**
	     * Given a fragment, validate that it can only be provided with fragment props
	     * @param {ReactElement} fragment
	     */

	    function validateFragmentProps(fragment) {
	      {
	        var keys = Object.keys(fragment.props);
	        for (var i = 0; i < keys.length; i++) {
	          var key = keys[i];
	          if (key !== 'children' && key !== 'key') {
	            setCurrentlyValidatingElement$1(fragment);
	            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);
	            setCurrentlyValidatingElement$1(null);
	            break;
	          }
	        }
	        if (fragment.ref !== null) {
	          setCurrentlyValidatingElement$1(fragment);
	          error('Invalid attribute `ref` supplied to `React.Fragment`.');
	          setCurrentlyValidatingElement$1(null);
	        }
	      }
	    }
	    function createElementWithValidation(type, props, children) {
	      var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
	      // succeed and there will likely be errors in render.

	      if (!validType) {
	        var info = '';
	        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
	          info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
	        }
	        var sourceInfo = getSourceInfoErrorAddendumForProps(props);
	        if (sourceInfo) {
	          info += sourceInfo;
	        } else {
	          info += getDeclarationErrorAddendum();
	        }
	        var typeString;
	        if (type === null) {
	          typeString = 'null';
	        } else if (isArray(type)) {
	          typeString = 'array';
	        } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
	          typeString = "<" + (getComponentNameFromType(type.type) || 'Unknown') + " />";
	          info = ' Did you accidentally export a JSX literal instead of a component?';
	        } else {
	          typeString = typeof type;
	        }
	        {
	          error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
	        }
	      }
	      var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
	      // TODO: Drop this when these are no longer allowed as the type argument.

	      if (element == null) {
	        return element;
	      } // Skip key warning if the type isn't valid since our key validation logic
	      // doesn't expect a non-string/function type and can throw confusing errors.
	      // We don't want exception behavior to differ between dev and prod.
	      // (Rendering will throw with a helpful message and as soon as the type is
	      // fixed, the key warnings will appear.)

	      if (validType) {
	        for (var i = 2; i < arguments.length; i++) {
	          validateChildKeys(arguments[i], type);
	        }
	      }
	      if (type === REACT_FRAGMENT_TYPE) {
	        validateFragmentProps(element);
	      } else {
	        validatePropTypes(element);
	      }
	      return element;
	    }
	    var didWarnAboutDeprecatedCreateFactory = false;
	    function createFactoryWithValidation(type) {
	      var validatedFactory = createElementWithValidation.bind(null, type);
	      validatedFactory.type = type;
	      {
	        if (!didWarnAboutDeprecatedCreateFactory) {
	          didWarnAboutDeprecatedCreateFactory = true;
	          warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
	        } // Legacy hook: remove it

	        Object.defineProperty(validatedFactory, 'type', {
	          enumerable: false,
	          get: function () {
	            warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
	            Object.defineProperty(this, 'type', {
	              value: type
	            });
	            return type;
	          }
	        });
	      }
	      return validatedFactory;
	    }
	    function cloneElementWithValidation(element, props, children) {
	      var newElement = cloneElement.apply(this, arguments);
	      for (var i = 2; i < arguments.length; i++) {
	        validateChildKeys(arguments[i], newElement.type);
	      }
	      validatePropTypes(newElement);
	      return newElement;
	    }
	    function startTransition(scope, options) {
	      var prevTransition = ReactCurrentBatchConfig.transition;
	      ReactCurrentBatchConfig.transition = {};
	      var currentTransition = ReactCurrentBatchConfig.transition;
	      {
	        ReactCurrentBatchConfig.transition._updatedFibers = new Set();
	      }
	      try {
	        scope();
	      } finally {
	        ReactCurrentBatchConfig.transition = prevTransition;
	        {
	          if (prevTransition === null && currentTransition._updatedFibers) {
	            var updatedFibersCount = currentTransition._updatedFibers.size;
	            if (updatedFibersCount > 10) {
	              warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');
	            }
	            currentTransition._updatedFibers.clear();
	          }
	        }
	      }
	    }
	    var didWarnAboutMessageChannel = false;
	    var enqueueTaskImpl = null;
	    function enqueueTask(task) {
	      if (enqueueTaskImpl === null) {
	        try {
	          // read require off the module object to get around the bundlers.
	          // we don't want them to detect a require and bundle a Node polyfill.
	          var requireString = ('require' + Math.random()).slice(0, 7);
	          var nodeRequire = module && module[requireString]; // assuming we're in node, let's try to get node's
	          // version of setImmediate, bypassing fake timers if any.

	          enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate;
	        } catch (_err) {
	          // we're in a browser
	          // we can't use regular timers because they may still be faked
	          // so we try MessageChannel+postMessage instead
	          enqueueTaskImpl = function (callback) {
	            {
	              if (didWarnAboutMessageChannel === false) {
	                didWarnAboutMessageChannel = true;
	                if (typeof MessageChannel === 'undefined') {
	                  error('This browser does not have a MessageChannel implementation, ' + 'so enqueuing tasks via await act(async () => ...) will fail. ' + 'Please file an issue at https://github.com/facebook/react/issues ' + 'if you encounter this warning.');
	                }
	              }
	            }
	            var channel = new MessageChannel();
	            channel.port1.onmessage = callback;
	            channel.port2.postMessage(undefined);
	          };
	        }
	      }
	      return enqueueTaskImpl(task);
	    }
	    var actScopeDepth = 0;
	    var didWarnNoAwaitAct = false;
	    function act(callback) {
	      {
	        // `act` calls can be nested, so we track the depth. This represents the
	        // number of `act` scopes on the stack.
	        var prevActScopeDepth = actScopeDepth;
	        actScopeDepth++;
	        if (ReactCurrentActQueue.current === null) {
	          // This is the outermost `act` scope. Initialize the queue. The reconciler
	          // will detect the queue and use it instead of Scheduler.
	          ReactCurrentActQueue.current = [];
	        }
	        var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
	        var result;
	        try {
	          // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only
	          // set to `true` while the given callback is executed, not for updates
	          // triggered during an async event, because this is how the legacy
	          // implementation of `act` behaved.
	          ReactCurrentActQueue.isBatchingLegacy = true;
	          result = callback(); // Replicate behavior of original `act` implementation in legacy mode,
	          // which flushed updates immediately after the scope function exits, even
	          // if it's an async function.

	          if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
	            var queue = ReactCurrentActQueue.current;
	            if (queue !== null) {
	              ReactCurrentActQueue.didScheduleLegacyUpdate = false;
	              flushActQueue(queue);
	            }
	          }
	        } catch (error) {
	          popActScope(prevActScopeDepth);
	          throw error;
	        } finally {
	          ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
	        }
	        if (result !== null && typeof result === 'object' && typeof result.then === 'function') {
	          var thenableResult = result; // The callback is an async function (i.e. returned a promise). Wait
	          // for it to resolve before exiting the current scope.

	          var wasAwaited = false;
	          var thenable = {
	            then: function (resolve, reject) {
	              wasAwaited = true;
	              thenableResult.then(function (returnValue) {
	                popActScope(prevActScopeDepth);
	                if (actScopeDepth === 0) {
	                  // We've exited the outermost act scope. Recursively flush the
	                  // queue until there's no remaining work.
	                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);
	                } else {
	                  resolve(returnValue);
	                }
	              }, function (error) {
	                // The callback threw an error.
	                popActScope(prevActScopeDepth);
	                reject(error);
	              });
	            }
	          };
	          {
	            if (!didWarnNoAwaitAct && typeof Promise !== 'undefined') {
	              // eslint-disable-next-line no-undef
	              Promise.resolve().then(function () {}).then(function () {
	                if (!wasAwaited) {
	                  didWarnNoAwaitAct = true;
	                  error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');
	                }
	              });
	            }
	          }
	          return thenable;
	        } else {
	          var returnValue = result; // The callback is not an async function. Exit the current scope
	          // immediately, without awaiting.

	          popActScope(prevActScopeDepth);
	          if (actScopeDepth === 0) {
	            // Exiting the outermost act scope. Flush the queue.
	            var _queue = ReactCurrentActQueue.current;
	            if (_queue !== null) {
	              flushActQueue(_queue);
	              ReactCurrentActQueue.current = null;
	            } // Return a thenable. If the user awaits it, we'll flush again in
	            // case additional work was scheduled by a microtask.

	            var _thenable = {
	              then: function (resolve, reject) {
	                // Confirm we haven't re-entered another `act` scope, in case
	                // the user does something weird like await the thenable
	                // multiple times.
	                if (ReactCurrentActQueue.current === null) {
	                  // Recursively flush the queue until there's no remaining work.
	                  ReactCurrentActQueue.current = [];
	                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);
	                } else {
	                  resolve(returnValue);
	                }
	              }
	            };
	            return _thenable;
	          } else {
	            // Since we're inside a nested `act` scope, the returned thenable
	            // immediately resolves. The outer scope will flush the queue.
	            var _thenable2 = {
	              then: function (resolve, reject) {
	                resolve(returnValue);
	              }
	            };
	            return _thenable2;
	          }
	        }
	      }
	    }
	    function popActScope(prevActScopeDepth) {
	      {
	        if (prevActScopeDepth !== actScopeDepth - 1) {
	          error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');
	        }
	        actScopeDepth = prevActScopeDepth;
	      }
	    }
	    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
	      {
	        var queue = ReactCurrentActQueue.current;
	        if (queue !== null) {
	          try {
	            flushActQueue(queue);
	            enqueueTask(function () {
	              if (queue.length === 0) {
	                // No additional work was scheduled. Finish.
	                ReactCurrentActQueue.current = null;
	                resolve(returnValue);
	              } else {
	                // Keep flushing work until there's none left.
	                recursivelyFlushAsyncActWork(returnValue, resolve, reject);
	              }
	            });
	          } catch (error) {
	            reject(error);
	          }
	        } else {
	          resolve(returnValue);
	        }
	      }
	    }
	    var isFlushing = false;
	    function flushActQueue(queue) {
	      {
	        if (!isFlushing) {
	          // Prevent re-entrance.
	          isFlushing = true;
	          var i = 0;
	          try {
	            for (; i < queue.length; i++) {
	              var callback = queue[i];
	              do {
	                callback = callback(true);
	              } while (callback !== null);
	            }
	            queue.length = 0;
	          } catch (error) {
	            // If something throws, leave the remaining callbacks on the queue.
	            queue = queue.slice(i + 1);
	            throw error;
	          } finally {
	            isFlushing = false;
	          }
	        }
	      }
	    }
	    var createElement$1 = createElementWithValidation;
	    var cloneElement$1 = cloneElementWithValidation;
	    var createFactory = createFactoryWithValidation;
	    var Children = {
	      map: mapChildren,
	      forEach: forEachChildren,
	      count: countChildren,
	      toArray: toArray,
	      only: onlyChild
	    };
	    exports.Children = Children;
	    exports.Component = Component;
	    exports.Fragment = REACT_FRAGMENT_TYPE;
	    exports.Profiler = REACT_PROFILER_TYPE;
	    exports.PureComponent = PureComponent;
	    exports.StrictMode = REACT_STRICT_MODE_TYPE;
	    exports.Suspense = REACT_SUSPENSE_TYPE;
	    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
	    exports.cloneElement = cloneElement$1;
	    exports.createContext = createContext;
	    exports.createElement = createElement$1;
	    exports.createFactory = createFactory;
	    exports.createRef = createRef;
	    exports.forwardRef = forwardRef;
	    exports.isValidElement = isValidElement;
	    exports.lazy = lazy;
	    exports.memo = memo;
	    exports.startTransition = startTransition;
	    exports.unstable_act = act;
	    exports.useCallback = useCallback;
	    exports.useContext = useContext;
	    exports.useDebugValue = useDebugValue;
	    exports.useDeferredValue = useDeferredValue;
	    exports.useEffect = useEffect;
	    exports.useId = useId;
	    exports.useImperativeHandle = useImperativeHandle;
	    exports.useInsertionEffect = useInsertionEffect;
	    exports.useLayoutEffect = useLayoutEffect;
	    exports.useMemo = useMemo;
	    exports.useReducer = useReducer;
	    exports.useRef = useRef;
	    exports.useState = useState;
	    exports.useSyncExternalStore = useSyncExternalStore;
	    exports.useTransition = useTransition;
	    exports.version = ReactVersion;
	    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {
	      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
	    }
	  })();
	} 
} (react_development, react_development.exports));

var react_developmentExports = react_development.exports;

{
  react.exports = react_developmentExports;
}

var reactExports = react.exports;
var React = /*@__PURE__*/getDefaultExportFromCjs(reactExports);

var reactDom = {exports: {}};

var reactDom_development = {};

var scheduler = {exports: {}};

var scheduler_development = {};

/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

(function (exports) {

	{
	  (function () {

	    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {
	      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
	    }
	    var enableSchedulerDebugging = false;
	    var enableProfiling = false;
	    var frameYieldMs = 5;
	    function push(heap, node) {
	      var index = heap.length;
	      heap.push(node);
	      siftUp(heap, node, index);
	    }
	    function peek(heap) {
	      return heap.length === 0 ? null : heap[0];
	    }
	    function pop(heap) {
	      if (heap.length === 0) {
	        return null;
	      }
	      var first = heap[0];
	      var last = heap.pop();
	      if (last !== first) {
	        heap[0] = last;
	        siftDown(heap, last, 0);
	      }
	      return first;
	    }
	    function siftUp(heap, node, i) {
	      var index = i;
	      while (index > 0) {
	        var parentIndex = index - 1 >>> 1;
	        var parent = heap[parentIndex];
	        if (compare(parent, node) > 0) {
	          // The parent is larger. Swap positions.
	          heap[parentIndex] = node;
	          heap[index] = parent;
	          index = parentIndex;
	        } else {
	          // The parent is smaller. Exit.
	          return;
	        }
	      }
	    }
	    function siftDown(heap, node, i) {
	      var index = i;
	      var length = heap.length;
	      var halfLength = length >>> 1;
	      while (index < halfLength) {
	        var leftIndex = (index + 1) * 2 - 1;
	        var left = heap[leftIndex];
	        var rightIndex = leftIndex + 1;
	        var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.

	        if (compare(left, node) < 0) {
	          if (rightIndex < length && compare(right, left) < 0) {
	            heap[index] = right;
	            heap[rightIndex] = node;
	            index = rightIndex;
	          } else {
	            heap[index] = left;
	            heap[leftIndex] = node;
	            index = leftIndex;
	          }
	        } else if (rightIndex < length && compare(right, node) < 0) {
	          heap[index] = right;
	          heap[rightIndex] = node;
	          index = rightIndex;
	        } else {
	          // Neither child is smaller. Exit.
	          return;
	        }
	      }
	    }
	    function compare(a, b) {
	      // Compare sort index first, then task id.
	      var diff = a.sortIndex - b.sortIndex;
	      return diff !== 0 ? diff : a.id - b.id;
	    }

	    // TODO: Use symbols?
	    var ImmediatePriority = 1;
	    var UserBlockingPriority = 2;
	    var NormalPriority = 3;
	    var LowPriority = 4;
	    var IdlePriority = 5;
	    function markTaskErrored(task, ms) {}

	    /* eslint-disable no-var */

	    var hasPerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';
	    if (hasPerformanceNow) {
	      var localPerformance = performance;
	      exports.unstable_now = function () {
	        return localPerformance.now();
	      };
	    } else {
	      var localDate = Date;
	      var initialTime = localDate.now();
	      exports.unstable_now = function () {
	        return localDate.now() - initialTime;
	      };
	    } // Max 31 bit integer. The max integer size in V8 for 32-bit systems.
	    // Math.pow(2, 30) - 1
	    // 0b111111111111111111111111111111

	    var maxSigned31BitInt = 1073741823; // Times out immediately

	    var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out

	    var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
	    var NORMAL_PRIORITY_TIMEOUT = 5000;
	    var LOW_PRIORITY_TIMEOUT = 10000; // Never times out

	    var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap

	    var taskQueue = [];
	    var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.

	    var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.
	    var currentTask = null;
	    var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrance.

	    var isPerformingWork = false;
	    var isHostCallbackScheduled = false;
	    var isHostTimeoutScheduled = false; // Capture local references to native APIs, in case a polyfill overrides them.

	    var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : null;
	    var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : null;
	    var localSetImmediate = typeof setImmediate !== 'undefined' ? setImmediate : null; // IE and Node.js + jsdom

	    typeof navigator !== 'undefined' && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
	    function advanceTimers(currentTime) {
	      // Check for tasks that are no longer delayed and add them to the queue.
	      var timer = peek(timerQueue);
	      while (timer !== null) {
	        if (timer.callback === null) {
	          // Timer was cancelled.
	          pop(timerQueue);
	        } else if (timer.startTime <= currentTime) {
	          // Timer fired. Transfer to the task queue.
	          pop(timerQueue);
	          timer.sortIndex = timer.expirationTime;
	          push(taskQueue, timer);
	        } else {
	          // Remaining timers are pending.
	          return;
	        }
	        timer = peek(timerQueue);
	      }
	    }
	    function handleTimeout(currentTime) {
	      isHostTimeoutScheduled = false;
	      advanceTimers(currentTime);
	      if (!isHostCallbackScheduled) {
	        if (peek(taskQueue) !== null) {
	          isHostCallbackScheduled = true;
	          requestHostCallback(flushWork);
	        } else {
	          var firstTimer = peek(timerQueue);
	          if (firstTimer !== null) {
	            requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
	          }
	        }
	      }
	    }
	    function flushWork(hasTimeRemaining, initialTime) {
	      isHostCallbackScheduled = false;
	      if (isHostTimeoutScheduled) {
	        // We scheduled a timeout but it's no longer needed. Cancel it.
	        isHostTimeoutScheduled = false;
	        cancelHostTimeout();
	      }
	      isPerformingWork = true;
	      var previousPriorityLevel = currentPriorityLevel;
	      try {
	        var currentTime; if (enableProfiling) ; else {
	          // No catch in prod code path.
	          return workLoop(hasTimeRemaining, initialTime);
	        }
	      } finally {
	        currentTask = null;
	        currentPriorityLevel = previousPriorityLevel;
	        isPerformingWork = false;
	      }
	    }
	    function workLoop(hasTimeRemaining, initialTime) {
	      var currentTime = initialTime;
	      advanceTimers(currentTime);
	      currentTask = peek(taskQueue);
	      while (currentTask !== null && !enableSchedulerDebugging) {
	        if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
	          // This currentTask hasn't expired, and we've reached the deadline.
	          break;
	        }
	        var callback = currentTask.callback;
	        if (typeof callback === 'function') {
	          currentTask.callback = null;
	          currentPriorityLevel = currentTask.priorityLevel;
	          var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
	          var continuationCallback = callback(didUserCallbackTimeout);
	          currentTime = exports.unstable_now();
	          if (typeof continuationCallback === 'function') {
	            currentTask.callback = continuationCallback;
	          } else {
	            if (currentTask === peek(taskQueue)) {
	              pop(taskQueue);
	            }
	          }
	          advanceTimers(currentTime);
	        } else {
	          pop(taskQueue);
	        }
	        currentTask = peek(taskQueue);
	      } // Return whether there's additional work

	      if (currentTask !== null) {
	        return true;
	      } else {
	        var firstTimer = peek(timerQueue);
	        if (firstTimer !== null) {
	          requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
	        }
	        return false;
	      }
	    }
	    function unstable_runWithPriority(priorityLevel, eventHandler) {
	      switch (priorityLevel) {
	        case ImmediatePriority:
	        case UserBlockingPriority:
	        case NormalPriority:
	        case LowPriority:
	        case IdlePriority:
	          break;
	        default:
	          priorityLevel = NormalPriority;
	      }
	      var previousPriorityLevel = currentPriorityLevel;
	      currentPriorityLevel = priorityLevel;
	      try {
	        return eventHandler();
	      } finally {
	        currentPriorityLevel = previousPriorityLevel;
	      }
	    }
	    function unstable_next(eventHandler) {
	      var priorityLevel;
	      switch (currentPriorityLevel) {
	        case ImmediatePriority:
	        case UserBlockingPriority:
	        case NormalPriority:
	          // Shift down to normal priority
	          priorityLevel = NormalPriority;
	          break;
	        default:
	          // Anything lower than normal priority should remain at the current level.
	          priorityLevel = currentPriorityLevel;
	          break;
	      }
	      var previousPriorityLevel = currentPriorityLevel;
	      currentPriorityLevel = priorityLevel;
	      try {
	        return eventHandler();
	      } finally {
	        currentPriorityLevel = previousPriorityLevel;
	      }
	    }
	    function unstable_wrapCallback(callback) {
	      var parentPriorityLevel = currentPriorityLevel;
	      return function () {
	        // This is a fork of runWithPriority, inlined for performance.
	        var previousPriorityLevel = currentPriorityLevel;
	        currentPriorityLevel = parentPriorityLevel;
	        try {
	          return callback.apply(this, arguments);
	        } finally {
	          currentPriorityLevel = previousPriorityLevel;
	        }
	      };
	    }
	    function unstable_scheduleCallback(priorityLevel, callback, options) {
	      var currentTime = exports.unstable_now();
	      var startTime;
	      if (typeof options === 'object' && options !== null) {
	        var delay = options.delay;
	        if (typeof delay === 'number' && delay > 0) {
	          startTime = currentTime + delay;
	        } else {
	          startTime = currentTime;
	        }
	      } else {
	        startTime = currentTime;
	      }
	      var timeout;
	      switch (priorityLevel) {
	        case ImmediatePriority:
	          timeout = IMMEDIATE_PRIORITY_TIMEOUT;
	          break;
	        case UserBlockingPriority:
	          timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
	          break;
	        case IdlePriority:
	          timeout = IDLE_PRIORITY_TIMEOUT;
	          break;
	        case LowPriority:
	          timeout = LOW_PRIORITY_TIMEOUT;
	          break;
	        case NormalPriority:
	        default:
	          timeout = NORMAL_PRIORITY_TIMEOUT;
	          break;
	      }
	      var expirationTime = startTime + timeout;
	      var newTask = {
	        id: taskIdCounter++,
	        callback: callback,
	        priorityLevel: priorityLevel,
	        startTime: startTime,
	        expirationTime: expirationTime,
	        sortIndex: -1
	      };
	      if (startTime > currentTime) {
	        // This is a delayed task.
	        newTask.sortIndex = startTime;
	        push(timerQueue, newTask);
	        if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
	          // All tasks are delayed, and this is the task with the earliest delay.
	          if (isHostTimeoutScheduled) {
	            // Cancel an existing timeout.
	            cancelHostTimeout();
	          } else {
	            isHostTimeoutScheduled = true;
	          } // Schedule a timeout.

	          requestHostTimeout(handleTimeout, startTime - currentTime);
	        }
	      } else {
	        newTask.sortIndex = expirationTime;
	        push(taskQueue, newTask);
	        // wait until the next time we yield.

	        if (!isHostCallbackScheduled && !isPerformingWork) {
	          isHostCallbackScheduled = true;
	          requestHostCallback(flushWork);
	        }
	      }
	      return newTask;
	    }
	    function unstable_pauseExecution() {}
	    function unstable_continueExecution() {
	      if (!isHostCallbackScheduled && !isPerformingWork) {
	        isHostCallbackScheduled = true;
	        requestHostCallback(flushWork);
	      }
	    }
	    function unstable_getFirstCallbackNode() {
	      return peek(taskQueue);
	    }
	    function unstable_cancelCallback(task) {
	      // remove from the queue because you can't remove arbitrary nodes from an
	      // array based heap, only the first one.)

	      task.callback = null;
	    }
	    function unstable_getCurrentPriorityLevel() {
	      return currentPriorityLevel;
	    }
	    var isMessageLoopRunning = false;
	    var scheduledHostCallback = null;
	    var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main
	    // thread, like user events. By default, it yields multiple times per frame.
	    // It does not attempt to align with frame boundaries, since most tasks don't
	    // need to be frame aligned; for those that do, use requestAnimationFrame.

	    var frameInterval = frameYieldMs;
	    var startTime = -1;
	    function shouldYieldToHost() {
	      var timeElapsed = exports.unstable_now() - startTime;
	      if (timeElapsed < frameInterval) {
	        // The main thread has only been blocked for a really short amount of time;
	        // smaller than a single frame. Don't yield yet.
	        return false;
	      } // The main thread has been blocked for a non-negligible amount of time. We

	      return true;
	    }
	    function requestPaint() {}
	    function forceFrameRate(fps) {
	      if (fps < 0 || fps > 125) {
	        // Using console['error'] to evade Babel and ESLint
	        console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');
	        return;
	      }
	      if (fps > 0) {
	        frameInterval = Math.floor(1000 / fps);
	      } else {
	        // reset the framerate
	        frameInterval = frameYieldMs;
	      }
	    }
	    var performWorkUntilDeadline = function () {
	      if (scheduledHostCallback !== null) {
	        var currentTime = exports.unstable_now(); // Keep track of the start time so we can measure how long the main thread
	        // has been blocked.

	        startTime = currentTime;
	        var hasTimeRemaining = true; // If a scheduler task throws, exit the current browser task so the
	        // error can be observed.
	        //
	        // Intentionally not using a try-catch, since that makes some debugging
	        // techniques harder. Instead, if `scheduledHostCallback` errors, then
	        // `hasMoreWork` will remain true, and we'll continue the work loop.

	        var hasMoreWork = true;
	        try {
	          hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
	        } finally {
	          if (hasMoreWork) {
	            // If there's more work, schedule the next message event at the end
	            // of the preceding one.
	            schedulePerformWorkUntilDeadline();
	          } else {
	            isMessageLoopRunning = false;
	            scheduledHostCallback = null;
	          }
	        }
	      } else {
	        isMessageLoopRunning = false;
	      } // Yielding to the browser will give it a chance to paint, so we can
	    };

	    var schedulePerformWorkUntilDeadline;
	    if (typeof localSetImmediate === 'function') {
	      // Node.js and old IE.
	      // There's a few reasons for why we prefer setImmediate.
	      //
	      // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.
	      // (Even though this is a DOM fork of the Scheduler, you could get here
	      // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)
	      // https://github.com/facebook/react/issues/20756
	      //
	      // But also, it runs earlier which is the semantic we want.
	      // If other browsers ever implement it, it's better to use it.
	      // Although both of these would be inferior to native scheduling.
	      schedulePerformWorkUntilDeadline = function () {
	        localSetImmediate(performWorkUntilDeadline);
	      };
	    } else if (typeof MessageChannel !== 'undefined') {
	      // DOM and Worker environments.
	      // We prefer MessageChannel because of the 4ms setTimeout clamping.
	      var channel = new MessageChannel();
	      var port = channel.port2;
	      channel.port1.onmessage = performWorkUntilDeadline;
	      schedulePerformWorkUntilDeadline = function () {
	        port.postMessage(null);
	      };
	    } else {
	      // We should only fallback here in non-browser environments.
	      schedulePerformWorkUntilDeadline = function () {
	        localSetTimeout(performWorkUntilDeadline, 0);
	      };
	    }
	    function requestHostCallback(callback) {
	      scheduledHostCallback = callback;
	      if (!isMessageLoopRunning) {
	        isMessageLoopRunning = true;
	        schedulePerformWorkUntilDeadline();
	      }
	    }
	    function requestHostTimeout(callback, ms) {
	      taskTimeoutID = localSetTimeout(function () {
	        callback(exports.unstable_now());
	      }, ms);
	    }
	    function cancelHostTimeout() {
	      localClearTimeout(taskTimeoutID);
	      taskTimeoutID = -1;
	    }
	    var unstable_requestPaint = requestPaint;
	    var unstable_Profiling = null;
	    exports.unstable_IdlePriority = IdlePriority;
	    exports.unstable_ImmediatePriority = ImmediatePriority;
	    exports.unstable_LowPriority = LowPriority;
	    exports.unstable_NormalPriority = NormalPriority;
	    exports.unstable_Profiling = unstable_Profiling;
	    exports.unstable_UserBlockingPriority = UserBlockingPriority;
	    exports.unstable_cancelCallback = unstable_cancelCallback;
	    exports.unstable_continueExecution = unstable_continueExecution;
	    exports.unstable_forceFrameRate = forceFrameRate;
	    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
	    exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
	    exports.unstable_next = unstable_next;
	    exports.unstable_pauseExecution = unstable_pauseExecution;
	    exports.unstable_requestPaint = unstable_requestPaint;
	    exports.unstable_runWithPriority = unstable_runWithPriority;
	    exports.unstable_scheduleCallback = unstable_scheduleCallback;
	    exports.unstable_shouldYield = shouldYieldToHost;
	    exports.unstable_wrapCallback = unstable_wrapCallback;
	    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {
	      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
	    }
	  })();
	} 
} (scheduler_development));

{
  scheduler.exports = scheduler_development;
}

var schedulerExports = scheduler.exports;

/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
{(function(){/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined'&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart==='function'){__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());}var React=reactExports;var Scheduler=schedulerExports;var ReactSharedInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;var suppressWarning=false;function setSuppressWarning(newSuppressWarning){{suppressWarning=newSuppressWarning;}}// In DEV, calls to console.warn and console.error get replaced
// by calls to these methods by a Babel plugin.
//
// In PROD (or in packages without access to React internals),
// they are left as they are instead.
function warn(format){{if(!suppressWarning){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}printWarning('warn',format,args);}}}function error(format){{if(!suppressWarning){for(var _len2=arguments.length,args=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++){args[_key2-1]=arguments[_key2];}printWarning('error',format,args);}}}function printWarning(level,format,args){// When changing this logic, you might want to also
// update consoleWithStackDev.www.js as well.
{var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;var stack=ReactDebugCurrentFrame.getStackAddendum();if(stack!==''){format+='%s';args=args.concat([stack]);}// eslint-disable-next-line react-internal/safe-string-coercion
var argsWithFormat=args.map(function(item){return String(item);});// Careful: RN currently depends on this prefix
argsWithFormat.unshift('Warning: '+format);// We intentionally don't use spread (or .apply) directly because it
// breaks IE9: https://github.com/facebook/react/issues/13610
// eslint-disable-next-line react-internal/no-production-logging
Function.prototype.apply.call(console[level],console,argsWithFormat);}}var FunctionComponent=0;var ClassComponent=1;var IndeterminateComponent=2;// Before we know whether it is function or class
var HostRoot=3;// Root of a host tree. Could be nested inside another node.
var HostPortal=4;// A subtree. Could be an entry point to a different renderer.
var HostComponent=5;var HostText=6;var Fragment=7;var Mode=8;var ContextConsumer=9;var ContextProvider=10;var ForwardRef=11;var Profiler=12;var SuspenseComponent=13;var MemoComponent=14;var SimpleMemoComponent=15;var LazyComponent=16;var IncompleteClassComponent=17;var DehydratedFragment=18;var SuspenseListComponent=19;var ScopeComponent=21;var OffscreenComponent=22;var LegacyHiddenComponent=23;var CacheComponent=24;var TracingMarkerComponent=25;// -----------------------------------------------------------------------------
var enableClientRenderFallbackOnTextMismatch=true;// TODO: Need to review this code one more time before landing
// the react-reconciler package.
var enableNewReconciler=false;// Support legacy Primer support on internal FB www
var enableLazyContextPropagation=false;// FB-only usage. The new API has different semantics.
var enableLegacyHidden=false;// Enables unstable_avoidThisFallback feature in Fiber
var enableSuspenseAvoidThisFallback=false;// Enables unstable_avoidThisFallback feature in Fizz
// React DOM Chopping Block
//
// Similar to main Chopping Block but only flags related to React DOM. These are
// grouped because we will likely batch all of them into a single major release.
// -----------------------------------------------------------------------------
// Disable support for comment nodes as React DOM containers. Already disabled
// in open source, but www codebase still relies on it. Need to remove.
var disableCommentsAsDOMContainers=true;// Disable javascript: URL strings in href for XSS protection.
// and client rendering, mostly to allow JSX attributes to apply to the custom
// element's object properties instead of only HTML attributes.
// https://github.com/facebook/react/issues/11347
var enableCustomElementPropertySupport=false;// Disables children for <textarea> elements
var warnAboutStringRefs=false;// -----------------------------------------------------------------------------
// Debugging and DevTools
// -----------------------------------------------------------------------------
// Adds user timing marks for e.g. state updates, suspense, and work loop stuff,
// for an experimental timeline tool.
var enableSchedulingProfiler=true;// Helps identify side effects in render-phase lifecycle hooks and setState
var enableProfilerTimer=true;// Record durations for commit and passive effects phases.
var enableProfilerCommitHooks=true;// Phase param passed to onRender callback differentiates between an "update" and a "cascading-update".
var allNativeEvents=new Set();/**
 * Mapping from registration name to event name
 */var registrationNameDependencies={};/**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */var possibleRegistrationNames={};// Trust the developer to only use possibleRegistrationNames in true
function registerTwoPhaseEvent(registrationName,dependencies){registerDirectEvent(registrationName,dependencies);registerDirectEvent(registrationName+'Capture',dependencies);}function registerDirectEvent(registrationName,dependencies){{if(registrationNameDependencies[registrationName]){error('EventRegistry: More than one plugin attempted to publish the same '+'registration name, `%s`.',registrationName);}}registrationNameDependencies[registrationName]=dependencies;{var lowerCasedName=registrationName.toLowerCase();possibleRegistrationNames[lowerCasedName]=registrationName;if(registrationName==='onDoubleClick'){possibleRegistrationNames.ondblclick=registrationName;}}for(var i=0;i<dependencies.length;i++){allNativeEvents.add(dependencies[i]);}}var canUseDOM=!!(typeof window!=='undefined'&&typeof window.document!=='undefined'&&typeof window.document.createElement!=='undefined');var hasOwnProperty=Object.prototype.hasOwnProperty;/*
 * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol
 * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
 *
 * The functions in this module will throw an easier-to-understand,
 * easier-to-debug exception with a clear errors message message explaining the
 * problem. (Instead of a confusing exception thrown inside the implementation
 * of the `value` object).
 */ // $FlowFixMe only called in DEV, so void return is not possible.
function typeName(value){{// toStringTag is needed for namespaced types like Temporal.Instant
var hasToStringTag=typeof Symbol==='function'&&Symbol.toStringTag;var type=hasToStringTag&&value[Symbol.toStringTag]||value.constructor.name||'Object';return type;}}// $FlowFixMe only called in DEV, so void return is not possible.
function willCoercionThrow(value){{try{testStringCoercion(value);return false;}catch(e){return true;}}}function testStringCoercion(value){// If you ended up here by following an exception call stack, here's what's
// happened: you supplied an object or symbol value to React (as a prop, key,
// DOM attribute, CSS property, string ref, etc.) and when React tried to
// coerce it to a string using `'' + value`, an exception was thrown.
//
// The most common types that will cause this exception are `Symbol` instances
// and Temporal objects like `Temporal.Instant`. But any object that has a
// `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
// exception. (Library authors do this to prevent users from using built-in
// numeric operators like `+` or comparison operators like `>=` because custom
// methods are needed to perform accurate arithmetic or comparison.)
//
// To fix the problem, coerce this object or symbol value to a string before
// passing it to React. The most reliable way is usually `String(value)`.
//
// To find which value is throwing, check the browser or debugger console.
// Before this exception was thrown, there should be `console.error` output
// that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
// problem and how that type was used: key, atrribute, input value prop, etc.
// In most cases, this console output also shows the component and its
// ancestor components where the exception happened.
//
// eslint-disable-next-line react-internal/safe-string-coercion
return ''+value;}function checkAttributeStringCoercion(value,attributeName){{if(willCoercionThrow(value)){error('The provided `%s` attribute is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',attributeName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)
}}}function checkKeyStringCoercion(value){{if(willCoercionThrow(value)){error('The provided key is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)
}}}function checkPropStringCoercion(value,propName){{if(willCoercionThrow(value)){error('The provided `%s` prop is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',propName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)
}}}function checkCSSPropertyStringCoercion(value,propName){{if(willCoercionThrow(value)){error('The provided `%s` CSS property is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',propName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)
}}}function checkHtmlStringCoercion(value){{if(willCoercionThrow(value)){error('The provided HTML markup uses a value of unsupported type %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)
}}}function checkFormFieldValueStringCoercion(value){{if(willCoercionThrow(value)){error('Form field values (value, checked, defaultValue, or defaultChecked props)'+' must be strings, not %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)
}}}// A reserved attribute.
// It is handled by React separately and shouldn't be written to the DOM.
var RESERVED=0;// A simple string attribute.
// Attributes that aren't in the filter are presumed to have this type.
var STRING=1;// A string attribute that accepts booleans in React. In HTML, these are called
// "enumerated" attributes with "true" and "false" as possible values.
// When true, it should be set to a "true" string.
// When false, it should be set to a "false" string.
var BOOLEANISH_STRING=2;// A real boolean attribute.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.
var BOOLEAN=3;// An attribute that can be used as a flag as well as with a value.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.
// For any other value, should be present with that value.
var OVERLOADED_BOOLEAN=4;// An attribute that must be numeric or parse as a numeric.
// When falsy, it should be removed.
var NUMERIC=5;// An attribute that must be positive numeric or parse as a positive numeric.
// When falsy, it should be removed.
var POSITIVE_NUMERIC=6;/* eslint-disable max-len */var ATTRIBUTE_NAME_START_CHAR=":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";/* eslint-enable max-len */var ATTRIBUTE_NAME_CHAR=ATTRIBUTE_NAME_START_CHAR+"\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";var VALID_ATTRIBUTE_NAME_REGEX=new RegExp('^['+ATTRIBUTE_NAME_START_CHAR+']['+ATTRIBUTE_NAME_CHAR+']*$');var illegalAttributeNameCache={};var validatedAttributeNameCache={};function isAttributeNameSafe(attributeName){if(hasOwnProperty.call(validatedAttributeNameCache,attributeName)){return true;}if(hasOwnProperty.call(illegalAttributeNameCache,attributeName)){return false;}if(VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)){validatedAttributeNameCache[attributeName]=true;return true;}illegalAttributeNameCache[attributeName]=true;{error('Invalid attribute name: `%s`',attributeName);}return false;}function shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag){if(propertyInfo!==null){return propertyInfo.type===RESERVED;}if(isCustomComponentTag){return false;}if(name.length>2&&(name[0]==='o'||name[0]==='O')&&(name[1]==='n'||name[1]==='N')){return true;}return false;}function shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag){if(propertyInfo!==null&&propertyInfo.type===RESERVED){return false;}switch(typeof value){case'function':// $FlowIssue symbol is perfectly valid here
case'symbol':// eslint-disable-line
return true;case'boolean':{if(isCustomComponentTag){return false;}if(propertyInfo!==null){return !propertyInfo.acceptsBooleans;}else {var prefix=name.toLowerCase().slice(0,5);return prefix!=='data-'&&prefix!=='aria-';}}default:return false;}}function shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag){if(value===null||typeof value==='undefined'){return true;}if(shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag)){return true;}if(isCustomComponentTag){return false;}if(propertyInfo!==null){switch(propertyInfo.type){case BOOLEAN:return !value;case OVERLOADED_BOOLEAN:return value===false;case NUMERIC:return isNaN(value);case POSITIVE_NUMERIC:return isNaN(value)||value<1;}}return false;}function getPropertyInfo(name){return properties.hasOwnProperty(name)?properties[name]:null;}function PropertyInfoRecord(name,type,mustUseProperty,attributeName,attributeNamespace,sanitizeURL,removeEmptyString){this.acceptsBooleans=type===BOOLEANISH_STRING||type===BOOLEAN||type===OVERLOADED_BOOLEAN;this.attributeName=attributeName;this.attributeNamespace=attributeNamespace;this.mustUseProperty=mustUseProperty;this.propertyName=name;this.type=type;this.sanitizeURL=sanitizeURL;this.removeEmptyString=removeEmptyString;}// When adding attributes to this list, be sure to also add them to
// the `possibleStandardNames` module to ensure casing and incorrect
// name warnings.
var properties={};// These props are reserved by React. They shouldn't be written to the DOM.
var reservedProps=['children','dangerouslySetInnerHTML',// TODO: This prevents the assignment of defaultValue to regular
// elements (not just inputs). Now that ReactDOMInput assigns to the
// defaultValue property -- do we need this?
'defaultValue','defaultChecked','innerHTML','suppressContentEditableWarning','suppressHydrationWarning','style'];reservedProps.forEach(function(name){properties[name]=new PropertyInfoRecord(name,RESERVED,false,// mustUseProperty
name,// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});// A few React string attributes have a different name.
// This is a mapping from React prop names to the attribute names.
[['acceptCharset','accept-charset'],['className','class'],['htmlFor','for'],['httpEquiv','http-equiv']].forEach(function(_ref){var name=_ref[0],attributeName=_ref[1];properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty
attributeName,// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});// These are "enumerated" HTML attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).
['contentEditable','draggable','spellCheck','value'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty
name.toLowerCase(),// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});// These are "enumerated" SVG attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).
// Since these are SVG attributes, their attribute names are case-sensitive.
['autoReverse','externalResourcesRequired','focusable','preserveAlpha'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty
name,// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});// These are HTML boolean attributes.
['allowFullScreen','async',// Note: there is a special case that prevents it from being written to the DOM
// on the client side because the browsers are inconsistent. Instead we call focus().
'autoFocus','autoPlay','controls','default','defer','disabled','disablePictureInPicture','disableRemotePlayback','formNoValidate','hidden','loop','noModule','noValidate','open','playsInline','readOnly','required','reversed','scoped','seamless',// Microdata
'itemScope'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,false,// mustUseProperty
name.toLowerCase(),// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});// These are the few React props that we set as DOM properties
// rather than attributes. These are all booleans.
['checked',// Note: `option.selected` is not updated if `select.multiple` is
// disabled with `removeAttribute`. We have special logic for handling this.
'multiple','muted','selected'// NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,true,// mustUseProperty
name,// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});// These are HTML attributes that are "overloaded booleans": they behave like
// booleans, but can also accept a string value.
['capture','download'// NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function(name){properties[name]=new PropertyInfoRecord(name,OVERLOADED_BOOLEAN,false,// mustUseProperty
name,// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});// These are HTML attributes that must be positive numbers.
['cols','rows','size','span'// NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function(name){properties[name]=new PropertyInfoRecord(name,POSITIVE_NUMERIC,false,// mustUseProperty
name,// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});// These are HTML attributes that must be numbers.
['rowSpan','start'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,NUMERIC,false,// mustUseProperty
name.toLowerCase(),// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});var CAMELIZE=/[\-\:]([a-z])/g;var capitalize=function(token){return token[1].toUpperCase();};// This is a list of all SVG attributes that need special casing, namespacing,
// or boolean value assignment. Regular attributes that just accept strings
// and have the same names are omitted, just like in the HTML attribute filter.
// Some of these attributes can be hard to find. This list was created by
// scraping the MDN documentation.
['accent-height','alignment-baseline','arabic-form','baseline-shift','cap-height','clip-path','clip-rule','color-interpolation','color-interpolation-filters','color-profile','color-rendering','dominant-baseline','enable-background','fill-opacity','fill-rule','flood-color','flood-opacity','font-family','font-size','font-size-adjust','font-stretch','font-style','font-variant','font-weight','glyph-name','glyph-orientation-horizontal','glyph-orientation-vertical','horiz-adv-x','horiz-origin-x','image-rendering','letter-spacing','lighting-color','marker-end','marker-mid','marker-start','overline-position','overline-thickness','paint-order','panose-1','pointer-events','rendering-intent','shape-rendering','stop-color','stop-opacity','strikethrough-position','strikethrough-thickness','stroke-dasharray','stroke-dashoffset','stroke-linecap','stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke-width','text-anchor','text-decoration','text-rendering','underline-position','underline-thickness','unicode-bidi','unicode-range','units-per-em','v-alphabetic','v-hanging','v-ideographic','v-mathematical','vector-effect','vert-adv-y','vert-origin-x','vert-origin-y','word-spacing','writing-mode','xmlns:xlink','x-height'// NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty
attributeName,null,// attributeNamespace
false,// sanitizeURL
false);});// String SVG attributes with the xlink namespace.
['xlink:actuate','xlink:arcrole','xlink:role','xlink:show','xlink:title','xlink:type'// NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty
attributeName,'http://www.w3.org/1999/xlink',false,// sanitizeURL
false);});// String SVG attributes with the xml namespace.
['xml:base','xml:lang','xml:space'// NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty
attributeName,'http://www.w3.org/XML/1998/namespace',false,// sanitizeURL
false);});// These attribute exists both in HTML and SVG.
// The attribute name is case-sensitive in SVG so we can't just use
// the React name like we do for attributes that exist only in HTML.
['tabIndex','crossOrigin'].forEach(function(attributeName){properties[attributeName]=new PropertyInfoRecord(attributeName,STRING,false,// mustUseProperty
attributeName.toLowerCase(),// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});// These attributes accept URLs. These must not allow javascript: URLS.
// These will also need to accept Trusted Types object in the future.
var xlinkHref='xlinkHref';properties[xlinkHref]=new PropertyInfoRecord('xlinkHref',STRING,false,// mustUseProperty
'xlink:href','http://www.w3.org/1999/xlink',true,// sanitizeURL
false);['src','href','action','formAction'].forEach(function(attributeName){properties[attributeName]=new PropertyInfoRecord(attributeName,STRING,false,// mustUseProperty
attributeName.toLowerCase(),// attributeName
null,// attributeNamespace
true,// sanitizeURL
true);});// and any newline or tab are filtered out as if they're not part of the URL.
// https://url.spec.whatwg.org/#url-parsing
// Tab or newline are defined as \r\n\t:
// https://infra.spec.whatwg.org/#ascii-tab-or-newline
// A C0 control is a code point in the range \u0000 NULL to \u001F
// INFORMATION SEPARATOR ONE, inclusive:
// https://infra.spec.whatwg.org/#c0-control-or-space
/* eslint-disable max-len */var isJavaScriptProtocol=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;var didWarn=false;function sanitizeURL(url){{if(!didWarn&&isJavaScriptProtocol.test(url)){didWarn=true;error('A future version of React will block javascript: URLs as a security precaution. '+'Use event handlers instead if you can. If you need to generate unsafe HTML try '+'using dangerouslySetInnerHTML instead. React was passed %s.',JSON.stringify(url));}}}/**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */function getValueForProperty(node,name,expected,propertyInfo){{if(propertyInfo.mustUseProperty){var propertyName=propertyInfo.propertyName;return node[propertyName];}else {// This check protects multiple uses of `expected`, which is why the
// react-internal/safe-string-coercion rule is disabled in several spots
// below.
{checkAttributeStringCoercion(expected,name);}if(propertyInfo.sanitizeURL){// If we haven't fully disabled javascript: URLs, and if
// the hydration is successful of a javascript: URL, we
// still want to warn on the client.
// eslint-disable-next-line react-internal/safe-string-coercion
sanitizeURL(''+expected);}var attributeName=propertyInfo.attributeName;var stringValue=null;if(propertyInfo.type===OVERLOADED_BOOLEAN){if(node.hasAttribute(attributeName)){var value=node.getAttribute(attributeName);if(value===''){return true;}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return value;}// eslint-disable-next-line react-internal/safe-string-coercion
if(value===''+expected){return expected;}return value;}}else if(node.hasAttribute(attributeName)){if(shouldRemoveAttribute(name,expected,propertyInfo,false)){// We had an attribute but shouldn't have had one, so read it
// for the error message.
return node.getAttribute(attributeName);}if(propertyInfo.type===BOOLEAN){// If this was a boolean, it doesn't matter what the value is
// the fact that we have it is the same as the expected.
return expected;}// Even if this property uses a namespace we use getAttribute
// because we assume its namespaced name is the same as our config.
// To use getAttributeNS we need the local name which we don't have
// in our config atm.
stringValue=node.getAttribute(attributeName);}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return stringValue===null?expected:stringValue;// eslint-disable-next-line react-internal/safe-string-coercion
}else if(stringValue===''+expected){return expected;}else {return stringValue;}}}}/**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */function getValueForAttribute(node,name,expected,isCustomComponentTag){{if(!isAttributeNameSafe(name)){return;}if(!node.hasAttribute(name)){return expected===undefined?undefined:null;}var value=node.getAttribute(name);{checkAttributeStringCoercion(expected,name);}if(value===''+expected){return expected;}return value;}}/**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */function setValueForProperty(node,name,value,isCustomComponentTag){var propertyInfo=getPropertyInfo(name);if(shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag)){return;}if(shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag)){value=null;}if(isCustomComponentTag||propertyInfo===null){if(isAttributeNameSafe(name)){var _attributeName=name;if(value===null){node.removeAttribute(_attributeName);}else {{checkAttributeStringCoercion(value,name);}node.setAttribute(_attributeName,''+value);}}return;}var mustUseProperty=propertyInfo.mustUseProperty;if(mustUseProperty){var propertyName=propertyInfo.propertyName;if(value===null){var type=propertyInfo.type;node[propertyName]=type===BOOLEAN?false:'';}else {// Contrary to `setAttribute`, object properties are properly
// `toString`ed by IE8/9.
node[propertyName]=value;}return;}// The rest are treated as attributes with special cases.
var attributeName=propertyInfo.attributeName,attributeNamespace=propertyInfo.attributeNamespace;if(value===null){node.removeAttribute(attributeName);}else {var _type=propertyInfo.type;var attributeValue;if(_type===BOOLEAN||_type===OVERLOADED_BOOLEAN&&value===true){// If attribute type is boolean, we know for sure it won't be an execution sink
// and we won't require Trusted Type here.
attributeValue='';}else {// `setAttribute` with objects becomes only `[object]` in IE8/9,
// ('' + value) makes it output the correct toString()-value.
{{checkAttributeStringCoercion(value,attributeName);}attributeValue=''+value;}if(propertyInfo.sanitizeURL){sanitizeURL(attributeValue.toString());}}if(attributeNamespace){node.setAttributeNS(attributeNamespace,attributeName,attributeValue);}else {node.setAttribute(attributeName,attributeValue);}}}// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types.
var REACT_ELEMENT_TYPE=Symbol.for('react.element');var REACT_PORTAL_TYPE=Symbol.for('react.portal');var REACT_FRAGMENT_TYPE=Symbol.for('react.fragment');var REACT_STRICT_MODE_TYPE=Symbol.for('react.strict_mode');var REACT_PROFILER_TYPE=Symbol.for('react.profiler');var REACT_PROVIDER_TYPE=Symbol.for('react.provider');var REACT_CONTEXT_TYPE=Symbol.for('react.context');var REACT_FORWARD_REF_TYPE=Symbol.for('react.forward_ref');var REACT_SUSPENSE_TYPE=Symbol.for('react.suspense');var REACT_SUSPENSE_LIST_TYPE=Symbol.for('react.suspense_list');var REACT_MEMO_TYPE=Symbol.for('react.memo');var REACT_LAZY_TYPE=Symbol.for('react.lazy');var REACT_SCOPE_TYPE=Symbol.for('react.scope');var REACT_DEBUG_TRACING_MODE_TYPE=Symbol.for('react.debug_trace_mode');var REACT_OFFSCREEN_TYPE=Symbol.for('react.offscreen');var REACT_LEGACY_HIDDEN_TYPE=Symbol.for('react.legacy_hidden');var REACT_CACHE_TYPE=Symbol.for('react.cache');var REACT_TRACING_MARKER_TYPE=Symbol.for('react.tracing_marker');var MAYBE_ITERATOR_SYMBOL=Symbol.iterator;var FAUX_ITERATOR_SYMBOL='@@iterator';function getIteratorFn(maybeIterable){if(maybeIterable===null||typeof maybeIterable!=='object'){return null;}var maybeIterator=MAYBE_ITERATOR_SYMBOL&&maybeIterable[MAYBE_ITERATOR_SYMBOL]||maybeIterable[FAUX_ITERATOR_SYMBOL];if(typeof maybeIterator==='function'){return maybeIterator;}return null;}var assign=Object.assign;// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth=0;var prevLog;var prevInfo;var prevWarn;var prevError;var prevGroup;var prevGroupCollapsed;var prevGroupEnd;function disabledLog(){}disabledLog.__reactDisabledLog=true;function disableLogs(){{if(disabledDepth===0){/* eslint-disable react-internal/no-production-logging */prevLog=console.log;prevInfo=console.info;prevWarn=console.warn;prevError=console.error;prevGroup=console.group;prevGroupCollapsed=console.groupCollapsed;prevGroupEnd=console.groupEnd;// https://github.com/facebook/react/issues/19099
var props={configurable:true,enumerable:true,value:disabledLog,writable:true};// $FlowFixMe Flow thinks console is immutable.
Object.defineProperties(console,{info:props,log:props,warn:props,error:props,group:props,groupCollapsed:props,groupEnd:props});/* eslint-enable react-internal/no-production-logging */}disabledDepth++;}}function reenableLogs(){{disabledDepth--;if(disabledDepth===0){/* eslint-disable react-internal/no-production-logging */var props={configurable:true,enumerable:true,writable:true};// $FlowFixMe Flow thinks console is immutable.
Object.defineProperties(console,{log:assign({},props,{value:prevLog}),info:assign({},props,{value:prevInfo}),warn:assign({},props,{value:prevWarn}),error:assign({},props,{value:prevError}),group:assign({},props,{value:prevGroup}),groupCollapsed:assign({},props,{value:prevGroupCollapsed}),groupEnd:assign({},props,{value:prevGroupEnd})});/* eslint-enable react-internal/no-production-logging */}if(disabledDepth<0){error('disabledDepth fell below zero. '+'This is a bug in React. Please file an issue.');}}}var ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;var prefix;function describeBuiltInComponentFrame(name,source,ownerFn){{if(prefix===undefined){// Extract the VM specific prefix used by each line.
try{throw Error();}catch(x){var match=x.stack.trim().match(/\n( *(at )?)/);prefix=match&&match[1]||'';}}// We use the prefix to ensure our stacks line up with native stack frames.
return '\n'+prefix+name;}}var reentry=false;var componentFrameCache;{var PossiblyWeakMap=typeof WeakMap==='function'?WeakMap:Map;componentFrameCache=new PossiblyWeakMap();}function describeNativeComponentFrame(fn,construct){// If something asked for a stack inside a fake render, it should get ignored.
if(!fn||reentry){return '';}{var frame=componentFrameCache.get(fn);if(frame!==undefined){return frame;}}var control;reentry=true;var previousPrepareStackTrace=Error.prepareStackTrace;// $FlowFixMe It does accept undefined.
Error.prepareStackTrace=undefined;var previousDispatcher;{previousDispatcher=ReactCurrentDispatcher.current;// Set the dispatcher in DEV because this might be call in the render function
// for warnings.
ReactCurrentDispatcher.current=null;disableLogs();}try{// This should throw.
if(construct){// Something should be setting the props in the constructor.
var Fake=function(){throw Error();};// $FlowFixMe
Object.defineProperty(Fake.prototype,'props',{set:function(){// We use a throwing setter instead of frozen or non-writable props
// because that won't throw in a non-strict mode function.
throw Error();}});if(typeof Reflect==='object'&&Reflect.construct){// We construct a different control for this case to include any extra
// frames added by the construct call.
try{Reflect.construct(Fake,[]);}catch(x){control=x;}Reflect.construct(fn,[],Fake);}else {try{Fake.call();}catch(x){control=x;}fn.call(Fake.prototype);}}else {try{throw Error();}catch(x){control=x;}fn();}}catch(sample){// This is inlined manually because closure doesn't do it for us.
if(sample&&control&&typeof sample.stack==='string'){// This extracts the first frame from the sample that isn't also in the control.
// Skipping one frame that we assume is the frame that calls the two.
var sampleLines=sample.stack.split('\n');var controlLines=control.stack.split('\n');var s=sampleLines.length-1;var c=controlLines.length-1;while(s>=1&&c>=0&&sampleLines[s]!==controlLines[c]){// We expect at least one stack frame to be shared.
// Typically this will be the root most one. However, stack frames may be
// cut off due to maximum stack limits. In this case, one maybe cut off
// earlier than the other. We assume that the sample is longer or the same
// and there for cut off earlier. So we should find the root most frame in
// the sample somewhere in the control.
c--;}for(;s>=1&&c>=0;s--,c--){// Next we find the first one that isn't the same which should be the
// frame that called our sample function and the control.
if(sampleLines[s]!==controlLines[c]){// In V8, the first line is describing the message but other VMs don't.
// If we're about to return the first line, and the control is also on the same
// line, that's a pretty good indicator that our sample threw at same line as
// the control. I.e. before we entered the sample frame. So we ignore this result.
// This can happen if you passed a class to function component, or non-function.
if(s!==1||c!==1){do{s--;c--;// We may still have similar intermediate frames from the construct call.
// The next one that isn't the same should be our match though.
if(c<0||sampleLines[s]!==controlLines[c]){// V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
var _frame='\n'+sampleLines[s].replace(' at new ',' at ');// If our component frame is labeled "<anonymous>"
// but we have a user-provided "displayName"
// splice it in to make the stack more readable.
if(fn.displayName&&_frame.includes('<anonymous>')){_frame=_frame.replace('<anonymous>',fn.displayName);}{if(typeof fn==='function'){componentFrameCache.set(fn,_frame);}}// Return the line we found.
return _frame;}}while(s>=1&&c>=0);}break;}}}}finally{reentry=false;{ReactCurrentDispatcher.current=previousDispatcher;reenableLogs();}Error.prepareStackTrace=previousPrepareStackTrace;}// Fallback to just using the name if we couldn't make it throw.
var name=fn?fn.displayName||fn.name:'';var syntheticFrame=name?describeBuiltInComponentFrame(name):'';{if(typeof fn==='function'){componentFrameCache.set(fn,syntheticFrame);}}return syntheticFrame;}function describeClassComponentFrame(ctor,source,ownerFn){{return describeNativeComponentFrame(ctor,true);}}function describeFunctionComponentFrame(fn,source,ownerFn){{return describeNativeComponentFrame(fn,false);}}function shouldConstruct(Component){var prototype=Component.prototype;return !!(prototype&&prototype.isReactComponent);}function describeUnknownElementTypeFrameInDEV(type,source,ownerFn){if(type==null){return '';}if(typeof type==='function'){{return describeNativeComponentFrame(type,shouldConstruct(type));}}if(typeof type==='string'){return describeBuiltInComponentFrame(type);}switch(type){case REACT_SUSPENSE_TYPE:return describeBuiltInComponentFrame('Suspense');case REACT_SUSPENSE_LIST_TYPE:return describeBuiltInComponentFrame('SuspenseList');}if(typeof type==='object'){switch(type.$$typeof){case REACT_FORWARD_REF_TYPE:return describeFunctionComponentFrame(type.render);case REACT_MEMO_TYPE:// Memo may contain any component type so we recursively resolve it.
return describeUnknownElementTypeFrameInDEV(type.type,source,ownerFn);case REACT_LAZY_TYPE:{var lazyComponent=type;var payload=lazyComponent._payload;var init=lazyComponent._init;try{// Lazy may contain any component type so we recursively resolve it.
return describeUnknownElementTypeFrameInDEV(init(payload),source,ownerFn);}catch(x){}}}}return '';}function describeFiber(fiber){fiber._debugOwner?fiber._debugOwner.type:null;fiber._debugSource;switch(fiber.tag){case HostComponent:return describeBuiltInComponentFrame(fiber.type);case LazyComponent:return describeBuiltInComponentFrame('Lazy');case SuspenseComponent:return describeBuiltInComponentFrame('Suspense');case SuspenseListComponent:return describeBuiltInComponentFrame('SuspenseList');case FunctionComponent:case IndeterminateComponent:case SimpleMemoComponent:return describeFunctionComponentFrame(fiber.type);case ForwardRef:return describeFunctionComponentFrame(fiber.type.render);case ClassComponent:return describeClassComponentFrame(fiber.type);default:return '';}}function getStackByFiberInDevAndProd(workInProgress){try{var info='';var node=workInProgress;do{info+=describeFiber(node);node=node.return;}while(node);return info;}catch(x){return '\nError generating stack: '+x.message+'\n'+x.stack;}}function getWrappedName(outerType,innerType,wrapperName){var displayName=outerType.displayName;if(displayName){return displayName;}var functionName=innerType.displayName||innerType.name||'';return functionName!==''?wrapperName+"("+functionName+")":wrapperName;}// Keep in sync with react-reconciler/getComponentNameFromFiber
function getContextName(type){return type.displayName||'Context';}// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.
function getComponentNameFromType(type){if(type==null){// Host root, text node or just invalid type.
return null;}{if(typeof type.tag==='number'){error('Received an unexpected object in getComponentNameFromType(). '+'This is likely a bug in React. Please file an issue.');}}if(typeof type==='function'){return type.displayName||type.name||null;}if(typeof type==='string'){return type;}switch(type){case REACT_FRAGMENT_TYPE:return 'Fragment';case REACT_PORTAL_TYPE:return 'Portal';case REACT_PROFILER_TYPE:return 'Profiler';case REACT_STRICT_MODE_TYPE:return 'StrictMode';case REACT_SUSPENSE_TYPE:return 'Suspense';case REACT_SUSPENSE_LIST_TYPE:return 'SuspenseList';}if(typeof type==='object'){switch(type.$$typeof){case REACT_CONTEXT_TYPE:var context=type;return getContextName(context)+'.Consumer';case REACT_PROVIDER_TYPE:var provider=type;return getContextName(provider._context)+'.Provider';case REACT_FORWARD_REF_TYPE:return getWrappedName(type,type.render,'ForwardRef');case REACT_MEMO_TYPE:var outerName=type.displayName||null;if(outerName!==null){return outerName;}return getComponentNameFromType(type.type)||'Memo';case REACT_LAZY_TYPE:{var lazyComponent=type;var payload=lazyComponent._payload;var init=lazyComponent._init;try{return getComponentNameFromType(init(payload));}catch(x){return null;}}// eslint-disable-next-line no-fallthrough
}}return null;}function getWrappedName$1(outerType,innerType,wrapperName){var functionName=innerType.displayName||innerType.name||'';return outerType.displayName||(functionName!==''?wrapperName+"("+functionName+")":wrapperName);}// Keep in sync with shared/getComponentNameFromType
function getContextName$1(type){return type.displayName||'Context';}function getComponentNameFromFiber(fiber){var tag=fiber.tag,type=fiber.type;switch(tag){case CacheComponent:return 'Cache';case ContextConsumer:var context=type;return getContextName$1(context)+'.Consumer';case ContextProvider:var provider=type;return getContextName$1(provider._context)+'.Provider';case DehydratedFragment:return 'DehydratedFragment';case ForwardRef:return getWrappedName$1(type,type.render,'ForwardRef');case Fragment:return 'Fragment';case HostComponent:// Host component type is the display name (e.g. "div", "View")
return type;case HostPortal:return 'Portal';case HostRoot:return 'Root';case HostText:return 'Text';case LazyComponent:// Name comes from the type in this case; we don't have a tag.
return getComponentNameFromType(type);case Mode:if(type===REACT_STRICT_MODE_TYPE){// Don't be less specific than shared/getComponentNameFromType
return 'StrictMode';}return 'Mode';case OffscreenComponent:return 'Offscreen';case Profiler:return 'Profiler';case ScopeComponent:return 'Scope';case SuspenseComponent:return 'Suspense';case SuspenseListComponent:return 'SuspenseList';case TracingMarkerComponent:return 'TracingMarker';// The display name for this tags come from the user-provided type:
case ClassComponent:case FunctionComponent:case IncompleteClassComponent:case IndeterminateComponent:case MemoComponent:case SimpleMemoComponent:if(typeof type==='function'){return type.displayName||type.name||null;}if(typeof type==='string'){return type;}break;}return null;}var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;var current=null;var isRendering=false;function getCurrentFiberOwnerNameInDevOrNull(){{if(current===null){return null;}var owner=current._debugOwner;if(owner!==null&&typeof owner!=='undefined'){return getComponentNameFromFiber(owner);}}return null;}function getCurrentFiberStackInDev(){{if(current===null){return '';}// Safe because if current fiber exists, we are reconciling,
// and it is guaranteed to be the work-in-progress version.
return getStackByFiberInDevAndProd(current);}}function resetCurrentFiber(){{ReactDebugCurrentFrame.getCurrentStack=null;current=null;isRendering=false;}}function setCurrentFiber(fiber){{ReactDebugCurrentFrame.getCurrentStack=fiber===null?null:getCurrentFiberStackInDev;current=fiber;isRendering=false;}}function getCurrentFiber(){{return current;}}function setIsRendering(rendering){{isRendering=rendering;}}// Flow does not allow string concatenation of most non-string types. To work
// around this limitation, we use an opaque type that can only be obtained by
// passing the value through getToStringValue first.
function toString(value){// The coercion safety check is performed in getToStringValue().
// eslint-disable-next-line react-internal/safe-string-coercion
return ''+value;}function getToStringValue(value){switch(typeof value){case'boolean':case'number':case'string':case'undefined':return value;case'object':{checkFormFieldValueStringCoercion(value);}return value;default:// function, symbol are assigned as empty strings
return '';}}var hasReadOnlyValue={button:true,checkbox:true,image:true,hidden:true,radio:true,reset:true,submit:true};function checkControlledValueProps(tagName,props){{if(!(hasReadOnlyValue[props.type]||props.onChange||props.onInput||props.readOnly||props.disabled||props.value==null)){error('You provided a `value` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultValue`. Otherwise, '+'set either `onChange` or `readOnly`.');}if(!(props.onChange||props.readOnly||props.disabled||props.checked==null)){error('You provided a `checked` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultChecked`. Otherwise, '+'set either `onChange` or `readOnly`.');}}}function isCheckable(elem){var type=elem.type;var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(type==='checkbox'||type==='radio');}function getTracker(node){return node._valueTracker;}function detachTracker(node){node._valueTracker=null;}function getValueFromNode(node){var value='';if(!node){return value;}if(isCheckable(node)){value=node.checked?'true':'false';}else {value=node.value;}return value;}function trackValueOnNode(node){var valueField=isCheckable(node)?'checked':'value';var descriptor=Object.getOwnPropertyDescriptor(node.constructor.prototype,valueField);{checkFormFieldValueStringCoercion(node[valueField]);}var currentValue=''+node[valueField];// if someone has already defined a value or Safari, then bail
// and don't track value will cause over reporting of changes,
// but it's better then a hard failure
// (needed for certain tests that spyOn input values and Safari)
if(node.hasOwnProperty(valueField)||typeof descriptor==='undefined'||typeof descriptor.get!=='function'||typeof descriptor.set!=='function'){return;}var get=descriptor.get,set=descriptor.set;Object.defineProperty(node,valueField,{configurable:true,get:function(){return get.call(this);},set:function(value){{checkFormFieldValueStringCoercion(value);}currentValue=''+value;set.call(this,value);}});// We could've passed this the first time
// but it triggers a bug in IE11 and Edge 14/15.
// Calling defineProperty() again should be equivalent.
// https://github.com/facebook/react/issues/11768
Object.defineProperty(node,valueField,{enumerable:descriptor.enumerable});var tracker={getValue:function(){return currentValue;},setValue:function(value){{checkFormFieldValueStringCoercion(value);}currentValue=''+value;},stopTracking:function(){detachTracker(node);delete node[valueField];}};return tracker;}function track(node){if(getTracker(node)){return;}// TODO: Once it's just Fiber we can move this to node._wrapperState
node._valueTracker=trackValueOnNode(node);}function updateValueIfChanged(node){if(!node){return false;}var tracker=getTracker(node);// if there is no tracker at this point it's unlikely
// that trying again will succeed
if(!tracker){return true;}var lastValue=tracker.getValue();var nextValue=getValueFromNode(node);if(nextValue!==lastValue){tracker.setValue(nextValue);return true;}return false;}function getActiveElement(doc){doc=doc||(typeof document!=='undefined'?document:undefined);if(typeof doc==='undefined'){return null;}try{return doc.activeElement||doc.body;}catch(e){return doc.body;}}var didWarnValueDefaultValue=false;var didWarnCheckedDefaultChecked=false;var didWarnControlledToUncontrolled=false;var didWarnUncontrolledToControlled=false;function isControlled(props){var usesChecked=props.type==='checkbox'||props.type==='radio';return usesChecked?props.checked!=null:props.value!=null;}/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */function getHostProps(element,props){var node=element;var checked=props.checked;var hostProps=assign({},props,{defaultChecked:undefined,defaultValue:undefined,value:undefined,checked:checked!=null?checked:node._wrapperState.initialChecked});return hostProps;}function initWrapperState(element,props){{checkControlledValueProps('input',props);if(props.checked!==undefined&&props.defaultChecked!==undefined&&!didWarnCheckedDefaultChecked){error('%s contains an input of type %s with both checked and defaultChecked props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the checked prop, or the defaultChecked prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnCheckedDefaultChecked=true;}if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue){error('%s contains an input of type %s with both value and defaultValue props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnValueDefaultValue=true;}}var node=element;var defaultValue=props.defaultValue==null?'':props.defaultValue;node._wrapperState={initialChecked:props.checked!=null?props.checked:props.defaultChecked,initialValue:getToStringValue(props.value!=null?props.value:defaultValue),controlled:isControlled(props)};}function updateChecked(element,props){var node=element;var checked=props.checked;if(checked!=null){setValueForProperty(node,'checked',checked,false);}}function updateWrapper(element,props){var node=element;{var controlled=isControlled(props);if(!node._wrapperState.controlled&&controlled&&!didWarnUncontrolledToControlled){error('A component is changing an uncontrolled input to be controlled. '+'This is likely caused by the value changing from undefined to '+'a defined value, which should not happen. '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');didWarnUncontrolledToControlled=true;}if(node._wrapperState.controlled&&!controlled&&!didWarnControlledToUncontrolled){error('A component is changing a controlled input to be uncontrolled. '+'This is likely caused by the value changing from a defined to '+'undefined, which should not happen. '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');didWarnControlledToUncontrolled=true;}}updateChecked(element,props);var value=getToStringValue(props.value);var type=props.type;if(value!=null){if(type==='number'){if(value===0&&node.value===''||// We explicitly want to coerce to number here if possible.
// eslint-disable-next-line
node.value!=value){node.value=toString(value);}}else if(node.value!==toString(value)){node.value=toString(value);}}else if(type==='submit'||type==='reset'){// Submit/reset inputs need the attribute removed completely to avoid
// blank-text buttons.
node.removeAttribute('value');return;}{// When syncing the value attribute, the value comes from a cascade of
// properties:
//  1. The value React property
//  2. The defaultValue React property
//  3. Otherwise there should be no change
if(props.hasOwnProperty('value')){setDefaultValue(node,props.type,value);}else if(props.hasOwnProperty('defaultValue')){setDefaultValue(node,props.type,getToStringValue(props.defaultValue));}}{// When syncing the checked attribute, it only changes when it needs
// to be removed, such as transitioning from a checkbox into a text input
if(props.checked==null&&props.defaultChecked!=null){node.defaultChecked=!!props.defaultChecked;}}}function postMountWrapper(element,props,isHydrating){var node=element;// Do not assign value if it is already set. This prevents user text input
// from being lost during SSR hydration.
if(props.hasOwnProperty('value')||props.hasOwnProperty('defaultValue')){var type=props.type;var isButton=type==='submit'||type==='reset';// Avoid setting value attribute on submit/reset inputs as it overrides the
// default value provided by the browser. See: #12872
if(isButton&&(props.value===undefined||props.value===null)){return;}var initialValue=toString(node._wrapperState.initialValue);// Do not assign value if it is already set. This prevents user text input
// from being lost during SSR hydration.
if(!isHydrating){{// When syncing the value attribute, the value property should use
// the wrapperState._initialValue property. This uses:
//
//   1. The value React property when present
//   2. The defaultValue React property when present
//   3. An empty string
if(initialValue!==node.value){node.value=initialValue;}}}{// Otherwise, the value attribute is synchronized to the property,
// so we assign defaultValue to the same thing as the value property
// assignment step above.
node.defaultValue=initialValue;}}// Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
// this is needed to work around a chrome bug where setting defaultChecked
// will sometimes influence the value of checked (even after detachment).
// Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
// We need to temporarily unset name to avoid disrupting radio button groups.
var name=node.name;if(name!==''){node.name='';}{// When syncing the checked attribute, both the checked property and
// attribute are assigned at the same time using defaultChecked. This uses:
//
//   1. The checked React property when present
//   2. The defaultChecked React property when present
//   3. Otherwise, false
node.defaultChecked=!node.defaultChecked;node.defaultChecked=!!node._wrapperState.initialChecked;}if(name!==''){node.name=name;}}function restoreControlledState(element,props){var node=element;updateWrapper(node,props);updateNamedCousins(node,props);}function updateNamedCousins(rootNode,props){var name=props.name;if(props.type==='radio'&&name!=null){var queryRoot=rootNode;while(queryRoot.parentNode){queryRoot=queryRoot.parentNode;}// If `rootNode.form` was non-null, then we could try `form.elements`,
// but that sometimes behaves strangely in IE8. We could also try using
// `form.getElementsByName`, but that will only return direct children
// and won't include inputs that use the HTML5 `form=` attribute. Since
// the input might not even be in a form. It might not even be in the
// document. Let's just use the local `querySelectorAll` to ensure we don't
// miss anything.
{checkAttributeStringCoercion(name,'name');}var group=queryRoot.querySelectorAll('input[name='+JSON.stringify(''+name)+'][type="radio"]');for(var i=0;i<group.length;i++){var otherNode=group[i];if(otherNode===rootNode||otherNode.form!==rootNode.form){continue;}// This will throw if radio buttons rendered by different copies of React
// and the same name are rendered into the same form (same as #1939).
// That's probably okay; we don't support it just as we don't support
// mixing React radio buttons with non-React ones.
var otherProps=getFiberCurrentPropsFromNode(otherNode);if(!otherProps){throw new Error('ReactDOMInput: Mixing React and non-React radio inputs with the '+'same `name` is not supported.');}// We need update the tracked value on the named cousin since the value
// was changed but the input saw no event or value set
updateValueIfChanged(otherNode);// If this is a controlled radio button group, forcing the input that
// was previously checked to update will cause it to be come re-checked
// as appropriate.
updateWrapper(otherNode,otherProps);}}}// In Chrome, assigning defaultValue to certain input types triggers input validation.
// For number inputs, the display value loses trailing decimal points. For email inputs,
// Chrome raises "The specified value <x> is not a valid email address".
//
// Here we check to see if the defaultValue has actually changed, avoiding these problems
// when the user is inputting text
//
// https://github.com/facebook/react/issues/7253
function setDefaultValue(node,type,value){if(// Focused number inputs synchronize on blur. See ChangeEventPlugin.js
type!=='number'||getActiveElement(node.ownerDocument)!==node){if(value==null){node.defaultValue=toString(node._wrapperState.initialValue);}else if(node.defaultValue!==toString(value)){node.defaultValue=toString(value);}}}var didWarnSelectedSetOnOption=false;var didWarnInvalidChild=false;var didWarnInvalidInnerHTML=false;/**
 * Implements an <option> host component that warns when `selected` is set.
 */function validateProps(element,props){{// If a value is not provided, then the children must be simple.
if(props.value==null){if(typeof props.children==='object'&&props.children!==null){React.Children.forEach(props.children,function(child){if(child==null){return;}if(typeof child==='string'||typeof child==='number'){return;}if(!didWarnInvalidChild){didWarnInvalidChild=true;error('Cannot infer the option value of complex children. '+'Pass a `value` prop or use a plain string as children to <option>.');}});}else if(props.dangerouslySetInnerHTML!=null){if(!didWarnInvalidInnerHTML){didWarnInvalidInnerHTML=true;error('Pass a `value` prop if you set dangerouslyInnerHTML so React knows '+'which value should be selected.');}}}// TODO: Remove support for `selected` in <option>.
if(props.selected!=null&&!didWarnSelectedSetOnOption){error('Use the `defaultValue` or `value` props on <select> instead of '+'setting `selected` on <option>.');didWarnSelectedSetOnOption=true;}}}function postMountWrapper$1(element,props){// value="" should make a value attribute (#6219)
if(props.value!=null){element.setAttribute('value',toString(getToStringValue(props.value)));}}var isArrayImpl=Array.isArray;// eslint-disable-next-line no-redeclare
function isArray(a){return isArrayImpl(a);}var didWarnValueDefaultValue$1;{didWarnValueDefaultValue$1=false;}function getDeclarationErrorAddendum(){var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){return '\n\nCheck the render method of `'+ownerName+'`.';}return '';}var valuePropNames=['value','defaultValue'];/**
 * Validation function for `value` and `defaultValue`.
 */function checkSelectPropTypes(props){{checkControlledValueProps('select',props);for(var i=0;i<valuePropNames.length;i++){var propName=valuePropNames[i];if(props[propName]==null){continue;}var propNameIsArray=isArray(props[propName]);if(props.multiple&&!propNameIsArray){error('The `%s` prop supplied to <select> must be an array if '+'`multiple` is true.%s',propName,getDeclarationErrorAddendum());}else if(!props.multiple&&propNameIsArray){error('The `%s` prop supplied to <select> must be a scalar '+'value if `multiple` is false.%s',propName,getDeclarationErrorAddendum());}}}}function updateOptions(node,multiple,propValue,setDefaultSelected){var options=node.options;if(multiple){var selectedValues=propValue;var selectedValue={};for(var i=0;i<selectedValues.length;i++){// Prefix to avoid chaos with special keys.
selectedValue['$'+selectedValues[i]]=true;}for(var _i=0;_i<options.length;_i++){var selected=selectedValue.hasOwnProperty('$'+options[_i].value);if(options[_i].selected!==selected){options[_i].selected=selected;}if(selected&&setDefaultSelected){options[_i].defaultSelected=true;}}}else {// Do not set `select.value` as exact behavior isn't consistent across all
// browsers for all cases.
var _selectedValue=toString(getToStringValue(propValue));var defaultSelected=null;for(var _i2=0;_i2<options.length;_i2++){if(options[_i2].value===_selectedValue){options[_i2].selected=true;if(setDefaultSelected){options[_i2].defaultSelected=true;}return;}if(defaultSelected===null&&!options[_i2].disabled){defaultSelected=options[_i2];}}if(defaultSelected!==null){defaultSelected.selected=true;}}}/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */function getHostProps$1(element,props){return assign({},props,{value:undefined});}function initWrapperState$1(element,props){var node=element;{checkSelectPropTypes(props);}node._wrapperState={wasMultiple:!!props.multiple};{if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue$1){error('Select elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled select '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components');didWarnValueDefaultValue$1=true;}}}function postMountWrapper$2(element,props){var node=element;node.multiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}}function postUpdateWrapper(element,props){var node=element;var wasMultiple=node._wrapperState.wasMultiple;node._wrapperState.wasMultiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(wasMultiple!==!!props.multiple){// For simplicity, reapply `defaultValue` if `multiple` is toggled.
if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}else {// Revert the select back to its default unselected state.
updateOptions(node,!!props.multiple,props.multiple?[]:'',false);}}}function restoreControlledState$1(element,props){var node=element;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}}var didWarnValDefaultVal=false;/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */function getHostProps$2(element,props){var node=element;if(props.dangerouslySetInnerHTML!=null){throw new Error('`dangerouslySetInnerHTML` does not make sense on <textarea>.');}// Always set children to the same thing. In IE9, the selection range will
// get reset if `textContent` is mutated.  We could add a check in setTextContent
// to only set the value if/when the value differs from the node value (which would
// completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
// solution. The value can be a boolean or object so that's why it's forced
// to be a string.
var hostProps=assign({},props,{value:undefined,defaultValue:undefined,children:toString(node._wrapperState.initialValue)});return hostProps;}function initWrapperState$2(element,props){var node=element;{checkControlledValueProps('textarea',props);if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValDefaultVal){error('%s contains a textarea with both value and defaultValue props. '+'Textarea elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled textarea '+'and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component');didWarnValDefaultVal=true;}}var initialValue=props.value;// Only bother fetching default value if we're going to use it
if(initialValue==null){var children=props.children,defaultValue=props.defaultValue;if(children!=null){{error('Use the `defaultValue` or `value` props instead of setting '+'children on <textarea>.');}{if(defaultValue!=null){throw new Error('If you supply `defaultValue` on a <textarea>, do not pass children.');}if(isArray(children)){if(children.length>1){throw new Error('<textarea> can only have at most one child.');}children=children[0];}defaultValue=children;}}if(defaultValue==null){defaultValue='';}initialValue=defaultValue;}node._wrapperState={initialValue:getToStringValue(initialValue)};}function updateWrapper$1(element,props){var node=element;var value=getToStringValue(props.value);var defaultValue=getToStringValue(props.defaultValue);if(value!=null){// Cast `value` to a string to ensure the value is set correctly. While
// browsers typically do this as necessary, jsdom doesn't.
var newValue=toString(value);// To avoid side effects (such as losing text selection), only set value if changed
if(newValue!==node.value){node.value=newValue;}if(props.defaultValue==null&&node.defaultValue!==newValue){node.defaultValue=newValue;}}if(defaultValue!=null){node.defaultValue=toString(defaultValue);}}function postMountWrapper$3(element,props){var node=element;// This is in postMount because we need access to the DOM node, which is not
// available until after the component has mounted.
var textContent=node.textContent;// Only set node.value if textContent is equal to the expected
// initial value. In IE10/IE11 there is a bug where the placeholder attribute
// will populate textContent as well.
// https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
if(textContent===node._wrapperState.initialValue){if(textContent!==''&&textContent!==null){node.value=textContent;}}}function restoreControlledState$2(element,props){// DOM component is still mounted; update
updateWrapper$1(element,props);}var HTML_NAMESPACE='http://www.w3.org/1999/xhtml';var MATH_NAMESPACE='http://www.w3.org/1998/Math/MathML';var SVG_NAMESPACE='http://www.w3.org/2000/svg';// Assumes there is no parent namespace.
function getIntrinsicNamespace(type){switch(type){case'svg':return SVG_NAMESPACE;case'math':return MATH_NAMESPACE;default:return HTML_NAMESPACE;}}function getChildNamespace(parentNamespace,type){if(parentNamespace==null||parentNamespace===HTML_NAMESPACE){// No (or default) parent namespace: potential entry point.
return getIntrinsicNamespace(type);}if(parentNamespace===SVG_NAMESPACE&&type==='foreignObject'){// We're leaving SVG.
return HTML_NAMESPACE;}// By default, pass namespace below.
return parentNamespace;}/* globals MSApp */ /**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */var createMicrosoftUnsafeLocalFunction=function(func){if(typeof MSApp!=='undefined'&&MSApp.execUnsafeLocalFunction){return function(arg0,arg1,arg2,arg3){MSApp.execUnsafeLocalFunction(function(){return func(arg0,arg1,arg2,arg3);});};}else {return func;}};var reusableSVGContainer;/**
 * Set the innerHTML property of a node
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */var setInnerHTML=createMicrosoftUnsafeLocalFunction(function(node,html){if(node.namespaceURI===SVG_NAMESPACE){if(!('innerHTML'in node)){// IE does not have innerHTML for SVG nodes, so instead we inject the
// new markup in a temp node and then move the child nodes across into
// the target node
reusableSVGContainer=reusableSVGContainer||document.createElement('div');reusableSVGContainer.innerHTML='<svg>'+html.valueOf().toString()+'</svg>';var svgNode=reusableSVGContainer.firstChild;while(node.firstChild){node.removeChild(node.firstChild);}while(svgNode.firstChild){node.appendChild(svgNode.firstChild);}return;}}node.innerHTML=html;});/**
 * HTML nodeType values that represent the type of the node
 */var ELEMENT_NODE=1;var TEXT_NODE=3;var COMMENT_NODE=8;var DOCUMENT_NODE=9;var DOCUMENT_FRAGMENT_NODE=11;/**
 * Set the textContent property of a node. For text updates, it's faster
 * to set the `nodeValue` of the Text node directly instead of using
 * `.textContent` which will remove the existing node and create a new one.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */var setTextContent=function(node,text){if(text){var firstChild=node.firstChild;if(firstChild&&firstChild===node.lastChild&&firstChild.nodeType===TEXT_NODE){firstChild.nodeValue=text;return;}}node.textContent=text;};// List derived from Gecko source code:
// https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js
var shorthandToLonghand={animation:['animationDelay','animationDirection','animationDuration','animationFillMode','animationIterationCount','animationName','animationPlayState','animationTimingFunction'],background:['backgroundAttachment','backgroundClip','backgroundColor','backgroundImage','backgroundOrigin','backgroundPositionX','backgroundPositionY','backgroundRepeat','backgroundSize'],backgroundPosition:['backgroundPositionX','backgroundPositionY'],border:['borderBottomColor','borderBottomStyle','borderBottomWidth','borderImageOutset','borderImageRepeat','borderImageSlice','borderImageSource','borderImageWidth','borderLeftColor','borderLeftStyle','borderLeftWidth','borderRightColor','borderRightStyle','borderRightWidth','borderTopColor','borderTopStyle','borderTopWidth'],borderBlockEnd:['borderBlockEndColor','borderBlockEndStyle','borderBlockEndWidth'],borderBlockStart:['borderBlockStartColor','borderBlockStartStyle','borderBlockStartWidth'],borderBottom:['borderBottomColor','borderBottomStyle','borderBottomWidth'],borderColor:['borderBottomColor','borderLeftColor','borderRightColor','borderTopColor'],borderImage:['borderImageOutset','borderImageRepeat','borderImageSlice','borderImageSource','borderImageWidth'],borderInlineEnd:['borderInlineEndColor','borderInlineEndStyle','borderInlineEndWidth'],borderInlineStart:['borderInlineStartColor','borderInlineStartStyle','borderInlineStartWidth'],borderLeft:['borderLeftColor','borderLeftStyle','borderLeftWidth'],borderRadius:['borderBottomLeftRadius','borderBottomRightRadius','borderTopLeftRadius','borderTopRightRadius'],borderRight:['borderRightColor','borderRightStyle','borderRightWidth'],borderStyle:['borderBottomStyle','borderLeftStyle','borderRightStyle','borderTopStyle'],borderTop:['borderTopColor','borderTopStyle','borderTopWidth'],borderWidth:['borderBottomWidth','borderLeftWidth','borderRightWidth','borderTopWidth'],columnRule:['columnRuleColor','columnRuleStyle','columnRuleWidth'],columns:['columnCount','columnWidth'],flex:['flexBasis','flexGrow','flexShrink'],flexFlow:['flexDirection','flexWrap'],font:['fontFamily','fontFeatureSettings','fontKerning','fontLanguageOverride','fontSize','fontSizeAdjust','fontStretch','fontStyle','fontVariant','fontVariantAlternates','fontVariantCaps','fontVariantEastAsian','fontVariantLigatures','fontVariantNumeric','fontVariantPosition','fontWeight','lineHeight'],fontVariant:['fontVariantAlternates','fontVariantCaps','fontVariantEastAsian','fontVariantLigatures','fontVariantNumeric','fontVariantPosition'],gap:['columnGap','rowGap'],grid:['gridAutoColumns','gridAutoFlow','gridAutoRows','gridTemplateAreas','gridTemplateColumns','gridTemplateRows'],gridArea:['gridColumnEnd','gridColumnStart','gridRowEnd','gridRowStart'],gridColumn:['gridColumnEnd','gridColumnStart'],gridColumnGap:['columnGap'],gridGap:['columnGap','rowGap'],gridRow:['gridRowEnd','gridRowStart'],gridRowGap:['rowGap'],gridTemplate:['gridTemplateAreas','gridTemplateColumns','gridTemplateRows'],listStyle:['listStyleImage','listStylePosition','listStyleType'],margin:['marginBottom','marginLeft','marginRight','marginTop'],marker:['markerEnd','markerMid','markerStart'],mask:['maskClip','maskComposite','maskImage','maskMode','maskOrigin','maskPositionX','maskPositionY','maskRepeat','maskSize'],maskPosition:['maskPositionX','maskPositionY'],outline:['outlineColor','outlineStyle','outlineWidth'],overflow:['overflowX','overflowY'],padding:['paddingBottom','paddingLeft','paddingRight','paddingTop'],placeContent:['alignContent','justifyContent'],placeItems:['alignItems','justifyItems'],placeSelf:['alignSelf','justifySelf'],textDecoration:['textDecorationColor','textDecorationLine','textDecorationStyle'],textEmphasis:['textEmphasisColor','textEmphasisStyle'],transition:['transitionDelay','transitionDuration','transitionProperty','transitionTimingFunction'],wordWrap:['overflowWrap']};/**
 * CSS properties which accept numbers but are not in units of "px".
 */var isUnitlessNumber={animationIterationCount:true,aspectRatio:true,borderImageOutset:true,borderImageSlice:true,borderImageWidth:true,boxFlex:true,boxFlexGroup:true,boxOrdinalGroup:true,columnCount:true,columns:true,flex:true,flexGrow:true,flexPositive:true,flexShrink:true,flexNegative:true,flexOrder:true,gridArea:true,gridRow:true,gridRowEnd:true,gridRowSpan:true,gridRowStart:true,gridColumn:true,gridColumnEnd:true,gridColumnSpan:true,gridColumnStart:true,fontWeight:true,lineClamp:true,lineHeight:true,opacity:true,order:true,orphans:true,tabSize:true,widows:true,zIndex:true,zoom:true,// SVG-related properties
fillOpacity:true,floodOpacity:true,stopOpacity:true,strokeDasharray:true,strokeDashoffset:true,strokeMiterlimit:true,strokeOpacity:true,strokeWidth:true};/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */function prefixKey(prefix,key){return prefix+key.charAt(0).toUpperCase()+key.substring(1);}/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */var prefixes=['Webkit','ms','Moz','O'];// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function(prop){prefixes.forEach(function(prefix){isUnitlessNumber[prefixKey(prefix,prop)]=isUnitlessNumber[prop];});});/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */function dangerousStyleValue(name,value,isCustomProperty){// Note that we've removed escapeTextForBrowser() calls here since the
// whole string will be escaped when the attribute is injected into
// the markup. If you provide unsafe user data here they can inject
// arbitrary CSS which may be problematic (I couldn't repro this):
// https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
// http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
// This is not an XSS hole but instead a potential CSS injection issue
// which has lead to a greater discussion about how we're going to
// trust URLs moving forward. See #2115901
var isEmpty=value==null||typeof value==='boolean'||value==='';if(isEmpty){return '';}if(!isCustomProperty&&typeof value==='number'&&value!==0&&!(isUnitlessNumber.hasOwnProperty(name)&&isUnitlessNumber[name])){return value+'px';// Presumes implicit 'px' suffix for unitless numbers
}{checkCSSPropertyStringCoercion(value,name);}return (''+value).trim();}var uppercasePattern=/([A-Z])/g;var msPattern=/^ms-/;/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 */function hyphenateStyleName(name){return name.replace(uppercasePattern,'-$1').toLowerCase().replace(msPattern,'-ms-');}var warnValidStyle=function(){};{// 'msTransform' is correct, but the other prefixes should be capitalized
var badVendoredStyleNamePattern=/^(?:webkit|moz|o)[A-Z]/;var msPattern$1=/^-ms-/;var hyphenPattern=/-(.)/g;// style values shouldn't contain a semicolon
var badStyleValueWithSemicolonPattern=/;\s*$/;var warnedStyleNames={};var warnedStyleValues={};var warnedForNaNValue=false;var warnedForInfinityValue=false;var camelize=function(string){return string.replace(hyphenPattern,function(_,character){return character.toUpperCase();});};var warnHyphenatedStyleName=function(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;error('Unsupported style property %s. Did you mean %s?',name,// As Andi Smith suggests
// (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
// is converted to lowercase `ms`.
camelize(name.replace(msPattern$1,'ms-')));};var warnBadVendoredStyleName=function(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;error('Unsupported vendor-prefixed style property %s. Did you mean %s?',name,name.charAt(0).toUpperCase()+name.slice(1));};var warnStyleValueWithSemicolon=function(name,value){if(warnedStyleValues.hasOwnProperty(value)&&warnedStyleValues[value]){return;}warnedStyleValues[value]=true;error("Style property values shouldn't contain a semicolon. "+'Try "%s: %s" instead.',name,value.replace(badStyleValueWithSemicolonPattern,''));};var warnStyleValueIsNaN=function(name,value){if(warnedForNaNValue){return;}warnedForNaNValue=true;error('`NaN` is an invalid value for the `%s` css style property.',name);};var warnStyleValueIsInfinity=function(name,value){if(warnedForInfinityValue){return;}warnedForInfinityValue=true;error('`Infinity` is an invalid value for the `%s` css style property.',name);};warnValidStyle=function(name,value){if(name.indexOf('-')>-1){warnHyphenatedStyleName(name);}else if(badVendoredStyleNamePattern.test(name)){warnBadVendoredStyleName(name);}else if(badStyleValueWithSemicolonPattern.test(value)){warnStyleValueWithSemicolon(name,value);}if(typeof value==='number'){if(isNaN(value)){warnStyleValueIsNaN(name,value);}else if(!isFinite(value)){warnStyleValueIsInfinity(name,value);}}};}var warnValidStyle$1=warnValidStyle;/**
 * Operations for dealing with CSS properties.
 */ /**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */function createDangerousStringForStyles(styles){{var serialized='';var delimiter='';for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var styleValue=styles[styleName];if(styleValue!=null){var isCustomProperty=styleName.indexOf('--')===0;serialized+=delimiter+(isCustomProperty?styleName:hyphenateStyleName(styleName))+':';serialized+=dangerousStyleValue(styleName,styleValue,isCustomProperty);delimiter=';';}}return serialized||null;}}/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */function setValueForStyles(node,styles){var style=node.style;for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var isCustomProperty=styleName.indexOf('--')===0;{if(!isCustomProperty){warnValidStyle$1(styleName,styles[styleName]);}}var styleValue=dangerousStyleValue(styleName,styles[styleName],isCustomProperty);if(styleName==='float'){styleName='cssFloat';}if(isCustomProperty){style.setProperty(styleName,styleValue);}else {style[styleName]=styleValue;}}}function isValueEmpty(value){return value==null||typeof value==='boolean'||value==='';}/**
 * Given {color: 'red', overflow: 'hidden'} returns {
 *   color: 'color',
 *   overflowX: 'overflow',
 *   overflowY: 'overflow',
 * }. This can be read as "the overflowY property was set by the overflow
 * shorthand". That is, the values are the property that each was derived from.
 */function expandShorthandMap(styles){var expanded={};for(var key in styles){var longhands=shorthandToLonghand[key]||[key];for(var i=0;i<longhands.length;i++){expanded[longhands[i]]=key;}}return expanded;}/**
 * When mixing shorthand and longhand property names, we warn during updates if
 * we expect an incorrect result to occur. In particular, we warn for:
 *
 * Updating a shorthand property (longhand gets overwritten):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}
 *   becomes .style.font = 'baz'
 * Removing a shorthand property (longhand gets lost too):
 *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}
 *   becomes .style.font = ''
 * Removing a longhand property (should revert to shorthand; doesn't):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}
 *   becomes .style.fontVariant = ''
 */function validateShorthandPropertyCollisionInDev(styleUpdates,nextStyles){{if(!nextStyles){return;}var expandedUpdates=expandShorthandMap(styleUpdates);var expandedStyles=expandShorthandMap(nextStyles);var warnedAbout={};for(var key in expandedUpdates){var originalKey=expandedUpdates[key];var correctOriginalKey=expandedStyles[key];if(correctOriginalKey&&originalKey!==correctOriginalKey){var warningKey=originalKey+','+correctOriginalKey;if(warnedAbout[warningKey]){continue;}warnedAbout[warningKey]=true;error('%s a style property during rerender (%s) when a '+'conflicting property is set (%s) can lead to styling bugs. To '+"avoid this, don't mix shorthand and non-shorthand properties "+'for the same value; instead, replace the shorthand with '+'separate values.',isValueEmpty(styleUpdates[originalKey])?'Removing':'Updating',originalKey,correctOriginalKey);}}}}// For HTML, certain tags should omit their close tag. We keep a list for
// those special-case tags.
var omittedCloseTags={area:true,base:true,br:true,col:true,embed:true,hr:true,img:true,input:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true// NOTE: menuitem's close tag should be omitted, but that causes problems.
};// `omittedCloseTags` except that `menuitem` should still have its closing tag.
var voidElementTags=assign({menuitem:true},omittedCloseTags);var HTML='__html';function assertValidProps(tag,props){if(!props){return;}// Note the use of `==` which checks for null or undefined.
if(voidElementTags[tag]){if(props.children!=null||props.dangerouslySetInnerHTML!=null){throw new Error(tag+" is a void element tag and must neither have `children` nor "+'use `dangerouslySetInnerHTML`.');}}if(props.dangerouslySetInnerHTML!=null){if(props.children!=null){throw new Error('Can only set one of `children` or `props.dangerouslySetInnerHTML`.');}if(typeof props.dangerouslySetInnerHTML!=='object'||!(HTML in props.dangerouslySetInnerHTML)){throw new Error('`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. '+'Please visit https://reactjs.org/link/dangerously-set-inner-html '+'for more information.');}}{if(!props.suppressContentEditableWarning&&props.contentEditable&&props.children!=null){error('A component is `contentEditable` and contains `children` managed by '+'React. It is now your responsibility to guarantee that none of '+'those nodes are unexpectedly modified or duplicated. This is '+'probably not intentional.');}}if(props.style!=null&&typeof props.style!=='object'){throw new Error('The `style` prop expects a mapping from style properties to values, '+"not a string. For example, style={{marginRight: spacing + 'em'}} when "+'using JSX.');}}function isCustomComponent(tagName,props){if(tagName.indexOf('-')===-1){return typeof props.is==='string';}switch(tagName){// These are reserved SVG and MathML elements.
// We don't mind this list too much because we expect it to never grow.
// The alternative is to track the namespace in a few places which is convoluted.
// https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
case'annotation-xml':case'color-profile':case'font-face':case'font-face-src':case'font-face-uri':case'font-face-format':case'font-face-name':case'missing-glyph':return false;default:return true;}}// When adding attributes to the HTML or SVG allowed attribute list, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames={// HTML
accept:'accept',acceptcharset:'acceptCharset','accept-charset':'acceptCharset',accesskey:'accessKey',action:'action',allowfullscreen:'allowFullScreen',alt:'alt',as:'as',async:'async',autocapitalize:'autoCapitalize',autocomplete:'autoComplete',autocorrect:'autoCorrect',autofocus:'autoFocus',autoplay:'autoPlay',autosave:'autoSave',capture:'capture',cellpadding:'cellPadding',cellspacing:'cellSpacing',challenge:'challenge',charset:'charSet',checked:'checked',children:'children',cite:'cite',class:'className',classid:'classID',classname:'className',cols:'cols',colspan:'colSpan',content:'content',contenteditable:'contentEditable',contextmenu:'contextMenu',controls:'controls',controlslist:'controlsList',coords:'coords',crossorigin:'crossOrigin',dangerouslysetinnerhtml:'dangerouslySetInnerHTML',data:'data',datetime:'dateTime',default:'default',defaultchecked:'defaultChecked',defaultvalue:'defaultValue',defer:'defer',dir:'dir',disabled:'disabled',disablepictureinpicture:'disablePictureInPicture',disableremoteplayback:'disableRemotePlayback',download:'download',draggable:'draggable',enctype:'encType',enterkeyhint:'enterKeyHint',for:'htmlFor',form:'form',formmethod:'formMethod',formaction:'formAction',formenctype:'formEncType',formnovalidate:'formNoValidate',formtarget:'formTarget',frameborder:'frameBorder',headers:'headers',height:'height',hidden:'hidden',high:'high',href:'href',hreflang:'hrefLang',htmlfor:'htmlFor',httpequiv:'httpEquiv','http-equiv':'httpEquiv',icon:'icon',id:'id',imagesizes:'imageSizes',imagesrcset:'imageSrcSet',innerhtml:'innerHTML',inputmode:'inputMode',integrity:'integrity',is:'is',itemid:'itemID',itemprop:'itemProp',itemref:'itemRef',itemscope:'itemScope',itemtype:'itemType',keyparams:'keyParams',keytype:'keyType',kind:'kind',label:'label',lang:'lang',list:'list',loop:'loop',low:'low',manifest:'manifest',marginwidth:'marginWidth',marginheight:'marginHeight',max:'max',maxlength:'maxLength',media:'media',mediagroup:'mediaGroup',method:'method',min:'min',minlength:'minLength',multiple:'multiple',muted:'muted',name:'name',nomodule:'noModule',nonce:'nonce',novalidate:'noValidate',open:'open',optimum:'optimum',pattern:'pattern',placeholder:'placeholder',playsinline:'playsInline',poster:'poster',preload:'preload',profile:'profile',radiogroup:'radioGroup',readonly:'readOnly',referrerpolicy:'referrerPolicy',rel:'rel',required:'required',reversed:'reversed',role:'role',rows:'rows',rowspan:'rowSpan',sandbox:'sandbox',scope:'scope',scoped:'scoped',scrolling:'scrolling',seamless:'seamless',selected:'selected',shape:'shape',size:'size',sizes:'sizes',span:'span',spellcheck:'spellCheck',src:'src',srcdoc:'srcDoc',srclang:'srcLang',srcset:'srcSet',start:'start',step:'step',style:'style',summary:'summary',tabindex:'tabIndex',target:'target',title:'title',type:'type',usemap:'useMap',value:'value',width:'width',wmode:'wmode',wrap:'wrap',// SVG
about:'about',accentheight:'accentHeight','accent-height':'accentHeight',accumulate:'accumulate',additive:'additive',alignmentbaseline:'alignmentBaseline','alignment-baseline':'alignmentBaseline',allowreorder:'allowReorder',alphabetic:'alphabetic',amplitude:'amplitude',arabicform:'arabicForm','arabic-form':'arabicForm',ascent:'ascent',attributename:'attributeName',attributetype:'attributeType',autoreverse:'autoReverse',azimuth:'azimuth',basefrequency:'baseFrequency',baselineshift:'baselineShift','baseline-shift':'baselineShift',baseprofile:'baseProfile',bbox:'bbox',begin:'begin',bias:'bias',by:'by',calcmode:'calcMode',capheight:'capHeight','cap-height':'capHeight',clip:'clip',clippath:'clipPath','clip-path':'clipPath',clippathunits:'clipPathUnits',cliprule:'clipRule','clip-rule':'clipRule',color:'color',colorinterpolation:'colorInterpolation','color-interpolation':'colorInterpolation',colorinterpolationfilters:'colorInterpolationFilters','color-interpolation-filters':'colorInterpolationFilters',colorprofile:'colorProfile','color-profile':'colorProfile',colorrendering:'colorRendering','color-rendering':'colorRendering',contentscripttype:'contentScriptType',contentstyletype:'contentStyleType',cursor:'cursor',cx:'cx',cy:'cy',d:'d',datatype:'datatype',decelerate:'decelerate',descent:'descent',diffuseconstant:'diffuseConstant',direction:'direction',display:'display',divisor:'divisor',dominantbaseline:'dominantBaseline','dominant-baseline':'dominantBaseline',dur:'dur',dx:'dx',dy:'dy',edgemode:'edgeMode',elevation:'elevation',enablebackground:'enableBackground','enable-background':'enableBackground',end:'end',exponent:'exponent',externalresourcesrequired:'externalResourcesRequired',fill:'fill',fillopacity:'fillOpacity','fill-opacity':'fillOpacity',fillrule:'fillRule','fill-rule':'fillRule',filter:'filter',filterres:'filterRes',filterunits:'filterUnits',floodopacity:'floodOpacity','flood-opacity':'floodOpacity',floodcolor:'floodColor','flood-color':'floodColor',focusable:'focusable',fontfamily:'fontFamily','font-family':'fontFamily',fontsize:'fontSize','font-size':'fontSize',fontsizeadjust:'fontSizeAdjust','font-size-adjust':'fontSizeAdjust',fontstretch:'fontStretch','font-stretch':'fontStretch',fontstyle:'fontStyle','font-style':'fontStyle',fontvariant:'fontVariant','font-variant':'fontVariant',fontweight:'fontWeight','font-weight':'fontWeight',format:'format',from:'from',fx:'fx',fy:'fy',g1:'g1',g2:'g2',glyphname:'glyphName','glyph-name':'glyphName',glyphorientationhorizontal:'glyphOrientationHorizontal','glyph-orientation-horizontal':'glyphOrientationHorizontal',glyphorientationvertical:'glyphOrientationVertical','glyph-orientation-vertical':'glyphOrientationVertical',glyphref:'glyphRef',gradienttransform:'gradientTransform',gradientunits:'gradientUnits',hanging:'hanging',horizadvx:'horizAdvX','horiz-adv-x':'horizAdvX',horizoriginx:'horizOriginX','horiz-origin-x':'horizOriginX',ideographic:'ideographic',imagerendering:'imageRendering','image-rendering':'imageRendering',in2:'in2',in:'in',inlist:'inlist',intercept:'intercept',k1:'k1',k2:'k2',k3:'k3',k4:'k4',k:'k',kernelmatrix:'kernelMatrix',kernelunitlength:'kernelUnitLength',kerning:'kerning',keypoints:'keyPoints',keysplines:'keySplines',keytimes:'keyTimes',lengthadjust:'lengthAdjust',letterspacing:'letterSpacing','letter-spacing':'letterSpacing',lightingcolor:'lightingColor','lighting-color':'lightingColor',limitingconeangle:'limitingConeAngle',local:'local',markerend:'markerEnd','marker-end':'markerEnd',markerheight:'markerHeight',markermid:'markerMid','marker-mid':'markerMid',markerstart:'markerStart','marker-start':'markerStart',markerunits:'markerUnits',markerwidth:'markerWidth',mask:'mask',maskcontentunits:'maskContentUnits',maskunits:'maskUnits',mathematical:'mathematical',mode:'mode',numoctaves:'numOctaves',offset:'offset',opacity:'opacity',operator:'operator',order:'order',orient:'orient',orientation:'orientation',origin:'origin',overflow:'overflow',overlineposition:'overlinePosition','overline-position':'overlinePosition',overlinethickness:'overlineThickness','overline-thickness':'overlineThickness',paintorder:'paintOrder','paint-order':'paintOrder',panose1:'panose1','panose-1':'panose1',pathlength:'pathLength',patterncontentunits:'patternContentUnits',patterntransform:'patternTransform',patternunits:'patternUnits',pointerevents:'pointerEvents','pointer-events':'pointerEvents',points:'points',pointsatx:'pointsAtX',pointsaty:'pointsAtY',pointsatz:'pointsAtZ',prefix:'prefix',preservealpha:'preserveAlpha',preserveaspectratio:'preserveAspectRatio',primitiveunits:'primitiveUnits',property:'property',r:'r',radius:'radius',refx:'refX',refy:'refY',renderingintent:'renderingIntent','rendering-intent':'renderingIntent',repeatcount:'repeatCount',repeatdur:'repeatDur',requiredextensions:'requiredExtensions',requiredfeatures:'requiredFeatures',resource:'resource',restart:'restart',result:'result',results:'results',rotate:'rotate',rx:'rx',ry:'ry',scale:'scale',security:'security',seed:'seed',shaperendering:'shapeRendering','shape-rendering':'shapeRendering',slope:'slope',spacing:'spacing',specularconstant:'specularConstant',specularexponent:'specularExponent',speed:'speed',spreadmethod:'spreadMethod',startoffset:'startOffset',stddeviation:'stdDeviation',stemh:'stemh',stemv:'stemv',stitchtiles:'stitchTiles',stopcolor:'stopColor','stop-color':'stopColor',stopopacity:'stopOpacity','stop-opacity':'stopOpacity',strikethroughposition:'strikethroughPosition','strikethrough-position':'strikethroughPosition',strikethroughthickness:'strikethroughThickness','strikethrough-thickness':'strikethroughThickness',string:'string',stroke:'stroke',strokedasharray:'strokeDasharray','stroke-dasharray':'strokeDasharray',strokedashoffset:'strokeDashoffset','stroke-dashoffset':'strokeDashoffset',strokelinecap:'strokeLinecap','stroke-linecap':'strokeLinecap',strokelinejoin:'strokeLinejoin','stroke-linejoin':'strokeLinejoin',strokemiterlimit:'strokeMiterlimit','stroke-miterlimit':'strokeMiterlimit',strokewidth:'strokeWidth','stroke-width':'strokeWidth',strokeopacity:'strokeOpacity','stroke-opacity':'strokeOpacity',suppresscontenteditablewarning:'suppressContentEditableWarning',suppresshydrationwarning:'suppressHydrationWarning',surfacescale:'surfaceScale',systemlanguage:'systemLanguage',tablevalues:'tableValues',targetx:'targetX',targety:'targetY',textanchor:'textAnchor','text-anchor':'textAnchor',textdecoration:'textDecoration','text-decoration':'textDecoration',textlength:'textLength',textrendering:'textRendering','text-rendering':'textRendering',to:'to',transform:'transform',typeof:'typeof',u1:'u1',u2:'u2',underlineposition:'underlinePosition','underline-position':'underlinePosition',underlinethickness:'underlineThickness','underline-thickness':'underlineThickness',unicode:'unicode',unicodebidi:'unicodeBidi','unicode-bidi':'unicodeBidi',unicoderange:'unicodeRange','unicode-range':'unicodeRange',unitsperem:'unitsPerEm','units-per-em':'unitsPerEm',unselectable:'unselectable',valphabetic:'vAlphabetic','v-alphabetic':'vAlphabetic',values:'values',vectoreffect:'vectorEffect','vector-effect':'vectorEffect',version:'version',vertadvy:'vertAdvY','vert-adv-y':'vertAdvY',vertoriginx:'vertOriginX','vert-origin-x':'vertOriginX',vertoriginy:'vertOriginY','vert-origin-y':'vertOriginY',vhanging:'vHanging','v-hanging':'vHanging',videographic:'vIdeographic','v-ideographic':'vIdeographic',viewbox:'viewBox',viewtarget:'viewTarget',visibility:'visibility',vmathematical:'vMathematical','v-mathematical':'vMathematical',vocab:'vocab',widths:'widths',wordspacing:'wordSpacing','word-spacing':'wordSpacing',writingmode:'writingMode','writing-mode':'writingMode',x1:'x1',x2:'x2',x:'x',xchannelselector:'xChannelSelector',xheight:'xHeight','x-height':'xHeight',xlinkactuate:'xlinkActuate','xlink:actuate':'xlinkActuate',xlinkarcrole:'xlinkArcrole','xlink:arcrole':'xlinkArcrole',xlinkhref:'xlinkHref','xlink:href':'xlinkHref',xlinkrole:'xlinkRole','xlink:role':'xlinkRole',xlinkshow:'xlinkShow','xlink:show':'xlinkShow',xlinktitle:'xlinkTitle','xlink:title':'xlinkTitle',xlinktype:'xlinkType','xlink:type':'xlinkType',xmlbase:'xmlBase','xml:base':'xmlBase',xmllang:'xmlLang','xml:lang':'xmlLang',xmlns:'xmlns','xml:space':'xmlSpace',xmlnsxlink:'xmlnsXlink','xmlns:xlink':'xmlnsXlink',xmlspace:'xmlSpace',y1:'y1',y2:'y2',y:'y',ychannelselector:'yChannelSelector',z:'z',zoomandpan:'zoomAndPan'};var ariaProperties={'aria-current':0,// state
'aria-description':0,'aria-details':0,'aria-disabled':0,// state
'aria-hidden':0,// state
'aria-invalid':0,// state
'aria-keyshortcuts':0,'aria-label':0,'aria-roledescription':0,// Widget Attributes
'aria-autocomplete':0,'aria-checked':0,'aria-expanded':0,'aria-haspopup':0,'aria-level':0,'aria-modal':0,'aria-multiline':0,'aria-multiselectable':0,'aria-orientation':0,'aria-placeholder':0,'aria-pressed':0,'aria-readonly':0,'aria-required':0,'aria-selected':0,'aria-sort':0,'aria-valuemax':0,'aria-valuemin':0,'aria-valuenow':0,'aria-valuetext':0,// Live Region Attributes
'aria-atomic':0,'aria-busy':0,'aria-live':0,'aria-relevant':0,// Drag-and-Drop Attributes
'aria-dropeffect':0,'aria-grabbed':0,// Relationship Attributes
'aria-activedescendant':0,'aria-colcount':0,'aria-colindex':0,'aria-colspan':0,'aria-controls':0,'aria-describedby':0,'aria-errormessage':0,'aria-flowto':0,'aria-labelledby':0,'aria-owns':0,'aria-posinset':0,'aria-rowcount':0,'aria-rowindex':0,'aria-rowspan':0,'aria-setsize':0};var warnedProperties={};var rARIA=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');function validateProperty(tagName,name){{if(hasOwnProperty.call(warnedProperties,name)&&warnedProperties[name]){return true;}if(rARIACamel.test(name)){var ariaName='aria-'+name.slice(4).toLowerCase();var correctName=ariaProperties.hasOwnProperty(ariaName)?ariaName:null;// If this is an aria-* attribute, but is not listed in the known DOM
// DOM properties, then it is an invalid aria-* attribute.
if(correctName==null){error('Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.',name);warnedProperties[name]=true;return true;}// aria-* attributes should be lowercase; suggest the lowercase version.
if(name!==correctName){error('Invalid ARIA attribute `%s`. Did you mean `%s`?',name,correctName);warnedProperties[name]=true;return true;}}if(rARIA.test(name)){var lowerCasedName=name.toLowerCase();var standardName=ariaProperties.hasOwnProperty(lowerCasedName)?lowerCasedName:null;// If this is an aria-* attribute, but is not listed in the known DOM
// DOM properties, then it is an invalid aria-* attribute.
if(standardName==null){warnedProperties[name]=true;return false;}// aria-* attributes should be lowercase; suggest the lowercase version.
if(name!==standardName){error('Unknown ARIA attribute `%s`. Did you mean `%s`?',name,standardName);warnedProperties[name]=true;return true;}}}return true;}function warnInvalidARIAProps(type,props){{var invalidProps=[];for(var key in props){var isValid=validateProperty(type,key);if(!isValid){invalidProps.push(key);}}var unknownPropString=invalidProps.map(function(prop){return '`'+prop+'`';}).join(', ');if(invalidProps.length===1){error('Invalid aria prop %s on <%s> tag. '+'For details, see https://reactjs.org/link/invalid-aria-props',unknownPropString,type);}else if(invalidProps.length>1){error('Invalid aria props %s on <%s> tag. '+'For details, see https://reactjs.org/link/invalid-aria-props',unknownPropString,type);}}}function validateProperties(type,props){if(isCustomComponent(type,props)){return;}warnInvalidARIAProps(type,props);}var didWarnValueNull=false;function validateProperties$1(type,props){{if(type!=='input'&&type!=='textarea'&&type!=='select'){return;}if(props!=null&&props.value===null&&!didWarnValueNull){didWarnValueNull=true;if(type==='select'&&props.multiple){error('`value` prop on `%s` should not be null. '+'Consider using an empty array when `multiple` is set to `true` '+'to clear the component or `undefined` for uncontrolled components.',type);}else {error('`value` prop on `%s` should not be null. '+'Consider using an empty string to clear the component or `undefined` '+'for uncontrolled components.',type);}}}}var validateProperty$1=function(){};{var warnedProperties$1={};var EVENT_NAME_REGEX=/^on./;var INVALID_EVENT_NAME_REGEX=/^on[^A-Z]/;var rARIA$1=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel$1=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');validateProperty$1=function(tagName,name,value,eventRegistry){if(hasOwnProperty.call(warnedProperties$1,name)&&warnedProperties$1[name]){return true;}var lowerCasedName=name.toLowerCase();if(lowerCasedName==='onfocusin'||lowerCasedName==='onfocusout'){error('React uses onFocus and onBlur instead of onFocusIn and onFocusOut. '+'All React events are normalized to bubble, so onFocusIn and onFocusOut '+'are not needed/supported by React.');warnedProperties$1[name]=true;return true;}// We can't rely on the event system being injected on the server.
if(eventRegistry!=null){var registrationNameDependencies=eventRegistry.registrationNameDependencies,possibleRegistrationNames=eventRegistry.possibleRegistrationNames;if(registrationNameDependencies.hasOwnProperty(name)){return true;}var registrationName=possibleRegistrationNames.hasOwnProperty(lowerCasedName)?possibleRegistrationNames[lowerCasedName]:null;if(registrationName!=null){error('Invalid event handler property `%s`. Did you mean `%s`?',name,registrationName);warnedProperties$1[name]=true;return true;}if(EVENT_NAME_REGEX.test(name)){error('Unknown event handler property `%s`. It will be ignored.',name);warnedProperties$1[name]=true;return true;}}else if(EVENT_NAME_REGEX.test(name)){// If no event plugins have been injected, we are in a server environment.
// So we can't tell if the event name is correct for sure, but we can filter
// out known bad ones like `onclick`. We can't suggest a specific replacement though.
if(INVALID_EVENT_NAME_REGEX.test(name)){error('Invalid event handler property `%s`. '+'React events use the camelCase naming convention, for example `onClick`.',name);}warnedProperties$1[name]=true;return true;}// Let the ARIA attribute hook validate ARIA attributes
if(rARIA$1.test(name)||rARIACamel$1.test(name)){return true;}if(lowerCasedName==='innerhtml'){error('Directly setting property `innerHTML` is not permitted. '+'For more information, lookup documentation on `dangerouslySetInnerHTML`.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='aria'){error('The `aria` attribute is reserved for future use in React. '+'Pass individual `aria-` attributes instead.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='is'&&value!==null&&value!==undefined&&typeof value!=='string'){error('Received a `%s` for a string attribute `is`. If this is expected, cast '+'the value to a string.',typeof value);warnedProperties$1[name]=true;return true;}if(typeof value==='number'&&isNaN(value)){error('Received NaN for the `%s` attribute. If this is expected, cast '+'the value to a string.',name);warnedProperties$1[name]=true;return true;}var propertyInfo=getPropertyInfo(name);var isReserved=propertyInfo!==null&&propertyInfo.type===RESERVED;// Known attributes should match the casing specified in the property config.
if(possibleStandardNames.hasOwnProperty(lowerCasedName)){var standardName=possibleStandardNames[lowerCasedName];if(standardName!==name){error('Invalid DOM property `%s`. Did you mean `%s`?',name,standardName);warnedProperties$1[name]=true;return true;}}else if(!isReserved&&name!==lowerCasedName){// Unknown attributes should have lowercase casing since that's how they
// will be cased anyway with server rendering.
error('React does not recognize the `%s` prop on a DOM element. If you '+'intentionally want it to appear in the DOM as a custom '+'attribute, spell it as lowercase `%s` instead. '+'If you accidentally passed it from a parent component, remove '+'it from the DOM element.',name,lowerCasedName);warnedProperties$1[name]=true;return true;}if(typeof value==='boolean'&&shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){if(value){error('Received `%s` for a non-boolean attribute `%s`.\n\n'+'If you want to write it to the DOM, pass a string instead: '+'%s="%s" or %s={value.toString()}.',value,name,name,value,name);}else {error('Received `%s` for a non-boolean attribute `%s`.\n\n'+'If you want to write it to the DOM, pass a string instead: '+'%s="%s" or %s={value.toString()}.\n\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',value,name,name,value,name,name,name);}warnedProperties$1[name]=true;return true;}// Now that we've validated casing, do not validate
// data types for reserved props
if(isReserved){return true;}// Warn when a known attribute is a bad type
if(shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){warnedProperties$1[name]=true;return false;}// Warn when passing the strings 'false' or 'true' into a boolean prop
if((value==='false'||value==='true')&&propertyInfo!==null&&propertyInfo.type===BOOLEAN){error('Received the string `%s` for the boolean attribute `%s`. '+'%s '+'Did you mean %s={%s}?',value,name,value==='false'?'The browser will interpret it as a truthy value.':'Although this works, it will not work as expected if you pass the string "false".',name,value);warnedProperties$1[name]=true;return true;}return true;};}var warnUnknownProperties=function(type,props,eventRegistry){{var unknownProps=[];for(var key in props){var isValid=validateProperty$1(type,key,props[key],eventRegistry);if(!isValid){unknownProps.push(key);}}var unknownPropString=unknownProps.map(function(prop){return '`'+prop+'`';}).join(', ');if(unknownProps.length===1){error('Invalid value for prop %s on <%s> tag. Either remove it from the element, '+'or pass a string or number value to keep it in the DOM. '+'For details, see https://reactjs.org/link/attribute-behavior ',unknownPropString,type);}else if(unknownProps.length>1){error('Invalid values for props %s on <%s> tag. Either remove them from the element, '+'or pass a string or number value to keep them in the DOM. '+'For details, see https://reactjs.org/link/attribute-behavior ',unknownPropString,type);}}};function validateProperties$2(type,props,eventRegistry){if(isCustomComponent(type,props)){return;}warnUnknownProperties(type,props,eventRegistry);}var IS_EVENT_HANDLE_NON_MANAGED_NODE=1;var IS_NON_DELEGATED=1<<1;var IS_CAPTURE_PHASE=1<<2;// set to LEGACY_FB_SUPPORT. LEGACY_FB_SUPPORT only gets set when
// we call willDeferLaterForLegacyFBSupport, thus not bailing out
// will result in endless cycles like an infinite loop.
// We also don't want to defer during event replaying.
var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS=IS_EVENT_HANDLE_NON_MANAGED_NODE|IS_NON_DELEGATED|IS_CAPTURE_PHASE;// This exists to avoid circular dependency between ReactDOMEventReplaying
// and DOMPluginEventSystem.
var currentReplayingEvent=null;function setReplayingEvent(event){{if(currentReplayingEvent!==null){error('Expected currently replaying event to be null. This error '+'is likely caused by a bug in React. Please file an issue.');}}currentReplayingEvent=event;}function resetReplayingEvent(){{if(currentReplayingEvent===null){error('Expected currently replaying event to not be null. This error '+'is likely caused by a bug in React. Please file an issue.');}}currentReplayingEvent=null;}function isReplayingEvent(event){return event===currentReplayingEvent;}/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */function getEventTarget(nativeEvent){// Fallback to nativeEvent.srcElement for IE9
// https://github.com/facebook/react/issues/12506
var target=nativeEvent.target||nativeEvent.srcElement||window;// Normalize SVG <use> element events #4963
if(target.correspondingUseElement){target=target.correspondingUseElement;}// Safari may fire events on text nodes (Node.TEXT_NODE is 3).
// @see http://www.quirksmode.org/js/events_properties.html
return target.nodeType===TEXT_NODE?target.parentNode:target;}var restoreImpl=null;var restoreTarget=null;var restoreQueue=null;function restoreStateOfTarget(target){// We perform this translation at the end of the event loop so that we
// always receive the correct fiber here
var internalInstance=getInstanceFromNode(target);if(!internalInstance){// Unmounted
return;}if(typeof restoreImpl!=='function'){throw new Error('setRestoreImplementation() needs to be called to handle a target for controlled '+'events. This error is likely caused by a bug in React. Please file an issue.');}var stateNode=internalInstance.stateNode;// Guard against Fiber being unmounted.
if(stateNode){var _props=getFiberCurrentPropsFromNode(stateNode);restoreImpl(internalInstance.stateNode,internalInstance.type,_props);}}function setRestoreImplementation(impl){restoreImpl=impl;}function enqueueStateRestore(target){if(restoreTarget){if(restoreQueue){restoreQueue.push(target);}else {restoreQueue=[target];}}else {restoreTarget=target;}}function needsStateRestore(){return restoreTarget!==null||restoreQueue!==null;}function restoreStateIfNeeded(){if(!restoreTarget){return;}var target=restoreTarget;var queuedTargets=restoreQueue;restoreTarget=null;restoreQueue=null;restoreStateOfTarget(target);if(queuedTargets){for(var i=0;i<queuedTargets.length;i++){restoreStateOfTarget(queuedTargets[i]);}}}// the renderer. Such as when we're dispatching events or if third party
// libraries need to call batchedUpdates. Eventually, this API will go away when
// everything is batched by default. We'll then have a similar API to opt-out of
// scheduled work and instead do synchronous work.
// Defaults
var batchedUpdatesImpl=function(fn,bookkeeping){return fn(bookkeeping);};var flushSyncImpl=function(){};var isInsideEventHandler=false;function finishEventHandler(){// Here we wait until all updates have propagated, which is important
// when using controlled components within layers:
// https://github.com/facebook/react/issues/1698
// Then we restore state of any controlled component.
var controlledComponentsHavePendingUpdates=needsStateRestore();if(controlledComponentsHavePendingUpdates){// If a controlled event was fired, we may need to restore the state of
// the DOM node back to the controlled value. This is necessary when React
// bails out of the update without touching the DOM.
// TODO: Restore state in the microtask, after the discrete updates flush,
// instead of early flushing them here.
flushSyncImpl();restoreStateIfNeeded();}}function batchedUpdates(fn,a,b){if(isInsideEventHandler){// If we are currently inside another batch, we need to wait until it
// fully completes before restoring state.
return fn(a,b);}isInsideEventHandler=true;try{return batchedUpdatesImpl(fn,a,b);}finally{isInsideEventHandler=false;finishEventHandler();}}// TODO: Replace with flushSync
function setBatchingImplementation(_batchedUpdatesImpl,_discreteUpdatesImpl,_flushSyncImpl){batchedUpdatesImpl=_batchedUpdatesImpl;flushSyncImpl=_flushSyncImpl;}function isInteractive(tag){return tag==='button'||tag==='input'||tag==='select'||tag==='textarea';}function shouldPreventMouseEvent(name,type,props){switch(name){case'onClick':case'onClickCapture':case'onDoubleClick':case'onDoubleClickCapture':case'onMouseDown':case'onMouseDownCapture':case'onMouseMove':case'onMouseMoveCapture':case'onMouseUp':case'onMouseUpCapture':case'onMouseEnter':return !!(props.disabled&&isInteractive(type));default:return false;}}/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */function getListener(inst,registrationName){var stateNode=inst.stateNode;if(stateNode===null){// Work in progress (ex: onload events in incremental mode).
return null;}var props=getFiberCurrentPropsFromNode(stateNode);if(props===null){// Work in progress.
return null;}var listener=props[registrationName];if(shouldPreventMouseEvent(registrationName,inst.type,props)){return null;}if(listener&&typeof listener!=='function'){throw new Error("Expected `"+registrationName+"` listener to be a function, instead got a value of `"+typeof listener+"` type.");}return listener;}var passiveBrowserEventsSupported=false;// Check if browser support events with passive listeners
// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
if(canUseDOM){try{var options={};// $FlowFixMe: Ignore Flow complaining about needing a value
Object.defineProperty(options,'passive',{get:function(){passiveBrowserEventsSupported=true;}});window.addEventListener('test',options,options);window.removeEventListener('test',options,options);}catch(e){passiveBrowserEventsSupported=false;}}function invokeGuardedCallbackProd(name,func,context,a,b,c,d,e,f){var funcArgs=Array.prototype.slice.call(arguments,3);try{func.apply(context,funcArgs);}catch(error){this.onError(error);}}var invokeGuardedCallbackImpl=invokeGuardedCallbackProd;{// In DEV mode, we swap out invokeGuardedCallback for a special version
// that plays more nicely with the browser's DevTools. The idea is to preserve
// "Pause on exceptions" behavior. Because React wraps all user-provided
// functions in invokeGuardedCallback, and the production version of
// invokeGuardedCallback uses a try-catch, all user exceptions are treated
// like caught exceptions, and the DevTools won't pause unless the developer
// takes the extra step of enabling pause on caught exceptions. This is
// unintuitive, though, because even though React has caught the error, from
// the developer's perspective, the error is uncaught.
//
// To preserve the expected "Pause on exceptions" behavior, we don't use a
// try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
// DOM node, and call the user-provided callback from inside an event handler
// for that fake event. If the callback throws, the error is "captured" using
// a global event handler. But because the error happens in a different
// event loop context, it does not interrupt the normal program flow.
// Effectively, this gives us try-catch behavior without actually using
// try-catch. Neat!
// Check that the browser supports the APIs we need to implement our special
// DEV version of invokeGuardedCallback
if(typeof window!=='undefined'&&typeof window.dispatchEvent==='function'&&typeof document!=='undefined'&&typeof document.createEvent==='function'){var fakeNode=document.createElement('react');invokeGuardedCallbackImpl=function invokeGuardedCallbackDev(name,func,context,a,b,c,d,e,f){// If document doesn't exist we know for sure we will crash in this method
// when we call document.createEvent(). However this can cause confusing
// errors: https://github.com/facebook/create-react-app/issues/3482
// So we preemptively throw with a better message instead.
if(typeof document==='undefined'||document===null){throw new Error('The `document` global was defined when React was initialized, but is not '+'defined anymore. This can happen in a test environment if a component '+'schedules an update from an asynchronous callback, but the test has already '+'finished running. To solve this, you can either unmount the component at '+'the end of your test (and ensure that any asynchronous operations get '+'canceled in `componentWillUnmount`), or you can change the test itself '+'to be asynchronous.');}var evt=document.createEvent('Event');var didCall=false;// Keeps track of whether the user-provided callback threw an error. We
// set this to true at the beginning, then set it to false right after
// calling the function. If the function errors, `didError` will never be
// set to false. This strategy works even if the browser is flaky and
// fails to call our global error handler, because it doesn't rely on
// the error event at all.
var didError=true;// Keeps track of the value of window.event so that we can reset it
// during the callback to let user code access window.event in the
// browsers that support it.
var windowEvent=window.event;// Keeps track of the descriptor of window.event to restore it after event
// dispatching: https://github.com/facebook/react/issues/13688
var windowEventDescriptor=Object.getOwnPropertyDescriptor(window,'event');function restoreAfterDispatch(){// We immediately remove the callback from event listeners so that
// nested `invokeGuardedCallback` calls do not clash. Otherwise, a
// nested call would trigger the fake event handlers of any call higher
// in the stack.
fakeNode.removeEventListener(evtType,callCallback,false);// We check for window.hasOwnProperty('event') to prevent the
// window.event assignment in both IE <= 10 as they throw an error
// "Member not found" in strict mode, and in Firefox which does not
// support window.event.
if(typeof window.event!=='undefined'&&window.hasOwnProperty('event')){window.event=windowEvent;}}// Create an event handler for our fake event. We will synchronously
// dispatch our fake event using `dispatchEvent`. Inside the handler, we
// call the user-provided callback.
var funcArgs=Array.prototype.slice.call(arguments,3);function callCallback(){didCall=true;restoreAfterDispatch();func.apply(context,funcArgs);didError=false;}// Create a global error event handler. We use this to capture the value
// that was thrown. It's possible that this error handler will fire more
// than once; for example, if non-React code also calls `dispatchEvent`
// and a handler for that event throws. We should be resilient to most of
// those cases. Even if our error event handler fires more than once, the
// last error event is always used. If the callback actually does error,
// we know that the last error event is the correct one, because it's not
// possible for anything else to have happened in between our callback
// erroring and the code that follows the `dispatchEvent` call below. If
// the callback doesn't error, but the error event was fired, we know to
// ignore it because `didError` will be false, as described above.
var error;// Use this to track whether the error event is ever called.
var didSetError=false;var isCrossOriginError=false;function handleWindowError(event){error=event.error;didSetError=true;if(error===null&&event.colno===0&&event.lineno===0){isCrossOriginError=true;}if(event.defaultPrevented){// Some other error handler has prevented default.
// Browsers silence the error report if this happens.
// We'll remember this to later decide whether to log it or not.
if(error!=null&&typeof error==='object'){try{error._suppressLogging=true;}catch(inner){// Ignore.
}}}}// Create a fake event type.
var evtType="react-"+(name?name:'invokeguardedcallback');// Attach our event handlers
window.addEventListener('error',handleWindowError);fakeNode.addEventListener(evtType,callCallback,false);// Synchronously dispatch our fake event. If the user-provided function
// errors, it will trigger our global error handler.
evt.initEvent(evtType,false,false);fakeNode.dispatchEvent(evt);if(windowEventDescriptor){Object.defineProperty(window,'event',windowEventDescriptor);}if(didCall&&didError){if(!didSetError){// The callback errored, but the error event never fired.
// eslint-disable-next-line react-internal/prod-error-codes
error=new Error('An error was thrown inside one of your components, but React '+"doesn't know what it was. This is likely due to browser "+'flakiness. React does its best to preserve the "Pause on '+'exceptions" behavior of the DevTools, which requires some '+"DEV-mode only tricks. It's possible that these don't work in "+'your browser. Try triggering the error in production mode, '+'or switching to a modern browser. If you suspect that this is '+'actually an issue with React, please file an issue.');}else if(isCrossOriginError){// eslint-disable-next-line react-internal/prod-error-codes
error=new Error("A cross-origin error was thrown. React doesn't have access to "+'the actual error object in development. '+'See https://reactjs.org/link/crossorigin-error for more information.');}this.onError(error);}// Remove our event listeners
window.removeEventListener('error',handleWindowError);if(!didCall){// Something went really wrong, and our event was not dispatched.
// https://github.com/facebook/react/issues/16734
// https://github.com/facebook/react/issues/16585
// Fall back to the production implementation.
restoreAfterDispatch();return invokeGuardedCallbackProd.apply(this,arguments);}};}}var invokeGuardedCallbackImpl$1=invokeGuardedCallbackImpl;var hasError=false;var caughtError=null;// Used by event system to capture/rethrow the first error.
var hasRethrowError=false;var rethrowError=null;var reporter={onError:function(error){hasError=true;caughtError=error;}};/**
 * Call a function while guarding against errors that happens within it.
 * Returns an error if it throws, otherwise null.
 *
 * In production, this is implemented using a try-catch. The reason we don't
 * use a try-catch directly is so that we can swap out a different
 * implementation in DEV mode.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */function invokeGuardedCallback(name,func,context,a,b,c,d,e,f){hasError=false;caughtError=null;invokeGuardedCallbackImpl$1.apply(reporter,arguments);}/**
 * Same as invokeGuardedCallback, but instead of returning an error, it stores
 * it in a global so it can be rethrown by `rethrowCaughtError` later.
 * TODO: See if caughtError and rethrowError can be unified.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */function invokeGuardedCallbackAndCatchFirstError(name,func,context,a,b,c,d,e,f){invokeGuardedCallback.apply(this,arguments);if(hasError){var error=clearCaughtError();if(!hasRethrowError){hasRethrowError=true;rethrowError=error;}}}/**
 * During execution of guarded functions we will capture the first error which
 * we will rethrow to be handled by the top level error handler.
 */function rethrowCaughtError(){if(hasRethrowError){var error=rethrowError;hasRethrowError=false;rethrowError=null;throw error;}}function hasCaughtError(){return hasError;}function clearCaughtError(){if(hasError){var error=caughtError;hasError=false;caughtError=null;return error;}else {throw new Error('clearCaughtError was called but no error was captured. This error '+'is likely caused by a bug in React. Please file an issue.');}}/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 */function get(key){return key._reactInternals;}function has(key){return key._reactInternals!==undefined;}function set(key,value){key._reactInternals=value;}// Don't change these two values. They're used by React Dev Tools.
var NoFlags=/*                      */0;var PerformedWork=/*                */1;// You can change the rest (and add more).
var Placement=/*                    */2;var Update=/*                       */4;var ChildDeletion=/*                */16;var ContentReset=/*                 */32;var Callback=/*                     */64;var DidCapture=/*                   */128;var ForceClientRender=/*            */256;var Ref=/*                          */512;var Snapshot=/*                     */1024;var Passive=/*                      */2048;var Hydrating=/*                    */4096;var Visibility=/*                   */8192;var StoreConsistency=/*             */16384;var LifecycleEffectMask=Passive|Update|Callback|Ref|Snapshot|StoreConsistency;// Union of all commit flags (flags with the lifetime of a particular commit)
var HostEffectMask=/*               */32767;// These are not really side effects, but we still reuse this field.
var Incomplete=/*                   */32768;var ShouldCapture=/*                */65536;var ForceUpdateForLegacySuspense=/* */131072;var Forked=/*                       */1048576;// Static tags describe aspects of a fiber that are not specific to a render,
// e.g. a fiber uses a passive effect (even if there are no updates on this particular render).
// This enables us to defer more work in the unmount case,
// since we can defer traversing the tree during layout to look for Passive effects,
// and instead rely on the static flag as a signal that there may be cleanup work.
var RefStatic=/*                    */2097152;var LayoutStatic=/*                 */4194304;var PassiveStatic=/*                */8388608;// These flags allow us to traverse to fibers that have effects on mount
// without traversing the entire tree after every commit for
// double invoking
var MountLayoutDev=/*               */16777216;var MountPassiveDev=/*              */33554432;// Groups of flags that are used in the commit phase to skip over trees that
// don't contain effects, by checking subtreeFlags.
var BeforeMutationMask=// TODO: Remove Update flag from before mutation phase by re-landing Visibility
// flag logic (see #20043)
Update|Snapshot|0;var MutationMask=Placement|Update|ChildDeletion|ContentReset|Ref|Hydrating|Visibility;var LayoutMask=Update|Callback|Ref|Visibility;// TODO: Split into PassiveMountMask and PassiveUnmountMask
var PassiveMask=Passive|ChildDeletion;// Union of tags that don't get reset on clones.
// This allows certain concepts to persist without recalculating them,
// e.g. whether a subtree contains passive effects or portals.
var StaticMask=LayoutStatic|PassiveStatic|RefStatic;var ReactCurrentOwner=ReactSharedInternals.ReactCurrentOwner;function getNearestMountedFiber(fiber){var node=fiber;var nearestMounted=fiber;if(!fiber.alternate){// If there is no alternate, this might be a new tree that isn't inserted
// yet. If it is, then it will have a pending insertion effect on it.
var nextNode=node;do{node=nextNode;if((node.flags&(Placement|Hydrating))!==NoFlags){// This is an insertion or in-progress hydration. The nearest possible
// mounted fiber is the parent but we need to continue to figure out
// if that one is still mounted.
nearestMounted=node.return;}nextNode=node.return;}while(nextNode);}else {while(node.return){node=node.return;}}if(node.tag===HostRoot){// TODO: Check if this was a nested HostRoot when used with
// renderContainerIntoSubtree.
return nearestMounted;}// If we didn't hit the root, that means that we're in an disconnected tree
// that has been unmounted.
return null;}function getSuspenseInstanceFromFiber(fiber){if(fiber.tag===SuspenseComponent){var suspenseState=fiber.memoizedState;if(suspenseState===null){var current=fiber.alternate;if(current!==null){suspenseState=current.memoizedState;}}if(suspenseState!==null){return suspenseState.dehydrated;}}return null;}function getContainerFromFiber(fiber){return fiber.tag===HostRoot?fiber.stateNode.containerInfo:null;}function isFiberMounted(fiber){return getNearestMountedFiber(fiber)===fiber;}function isMounted(component){{var owner=ReactCurrentOwner.current;if(owner!==null&&owner.tag===ClassComponent){var ownerFiber=owner;var instance=ownerFiber.stateNode;if(!instance._warnedAboutRefsInRender){error('%s is accessing isMounted inside its render() function. '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentNameFromFiber(ownerFiber)||'A component');}instance._warnedAboutRefsInRender=true;}}var fiber=get(component);if(!fiber){return false;}return getNearestMountedFiber(fiber)===fiber;}function assertIsMounted(fiber){if(getNearestMountedFiber(fiber)!==fiber){throw new Error('Unable to find node on an unmounted component.');}}function findCurrentFiberUsingSlowPath(fiber){var alternate=fiber.alternate;if(!alternate){// If there is no alternate, then we only need to check if it is mounted.
var nearestMounted=getNearestMountedFiber(fiber);if(nearestMounted===null){throw new Error('Unable to find node on an unmounted component.');}if(nearestMounted!==fiber){return null;}return fiber;}// If we have two possible branches, we'll walk backwards up to the root
// to see what path the root points to. On the way we may hit one of the
// special cases and we'll deal with them.
var a=fiber;var b=alternate;while(true){var parentA=a.return;if(parentA===null){// We're at the root.
break;}var parentB=parentA.alternate;if(parentB===null){// There is no alternate. This is an unusual case. Currently, it only
// happens when a Suspense component is hidden. An extra fragment fiber
// is inserted in between the Suspense fiber and its children. Skip
// over this extra fragment fiber and proceed to the next parent.
var nextParent=parentA.return;if(nextParent!==null){a=b=nextParent;continue;}// If there's no parent, we're at the root.
break;}// If both copies of the parent fiber point to the same child, we can
// assume that the child is current. This happens when we bailout on low
// priority: the bailed out fiber's child reuses the current child.
if(parentA.child===parentB.child){var child=parentA.child;while(child){if(child===a){// We've determined that A is the current branch.
assertIsMounted(parentA);return fiber;}if(child===b){// We've determined that B is the current branch.
assertIsMounted(parentA);return alternate;}child=child.sibling;}// We should never have an alternate for any mounting node. So the only
// way this could possibly happen is if this was unmounted, if at all.
throw new Error('Unable to find node on an unmounted component.');}if(a.return!==b.return){// The return pointer of A and the return pointer of B point to different
// fibers. We assume that return pointers never criss-cross, so A must
// belong to the child set of A.return, and B must belong to the child
// set of B.return.
a=parentA;b=parentB;}else {// The return pointers point to the same fiber. We'll have to use the
// default, slow path: scan the child sets of each parent alternate to see
// which child belongs to which set.
//
// Search parent A's child set
var didFindChild=false;var _child=parentA.child;while(_child){if(_child===a){didFindChild=true;a=parentA;b=parentB;break;}if(_child===b){didFindChild=true;b=parentA;a=parentB;break;}_child=_child.sibling;}if(!didFindChild){// Search parent B's child set
_child=parentB.child;while(_child){if(_child===a){didFindChild=true;a=parentB;b=parentA;break;}if(_child===b){didFindChild=true;b=parentB;a=parentA;break;}_child=_child.sibling;}if(!didFindChild){throw new Error('Child was not found in either parent set. This indicates a bug '+'in React related to the return pointer. Please file an issue.');}}}if(a.alternate!==b){throw new Error("Return fibers should always be each others' alternates. "+'This error is likely caused by a bug in React. Please file an issue.');}}// If the root is not a host container, we're in a disconnected tree. I.e.
// unmounted.
if(a.tag!==HostRoot){throw new Error('Unable to find node on an unmounted component.');}if(a.stateNode.current===a){// We've determined that A is the current branch.
return fiber;}// Otherwise B has to be current branch.
return alternate;}function findCurrentHostFiber(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);return currentParent!==null?findCurrentHostFiberImpl(currentParent):null;}function findCurrentHostFiberImpl(node){// Next we'll drill down this component to find the first HostComponent/Text.
if(node.tag===HostComponent||node.tag===HostText){return node;}var child=node.child;while(child!==null){var match=findCurrentHostFiberImpl(child);if(match!==null){return match;}child=child.sibling;}return null;}function findCurrentHostFiberWithNoPortals(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);return currentParent!==null?findCurrentHostFiberWithNoPortalsImpl(currentParent):null;}function findCurrentHostFiberWithNoPortalsImpl(node){// Next we'll drill down this component to find the first HostComponent/Text.
if(node.tag===HostComponent||node.tag===HostText){return node;}var child=node.child;while(child!==null){if(child.tag!==HostPortal){var match=findCurrentHostFiberWithNoPortalsImpl(child);if(match!==null){return match;}}child=child.sibling;}return null;}// This module only exists as an ESM wrapper around the external CommonJS
var scheduleCallback=Scheduler.unstable_scheduleCallback;var cancelCallback=Scheduler.unstable_cancelCallback;var shouldYield=Scheduler.unstable_shouldYield;var requestPaint=Scheduler.unstable_requestPaint;var now=Scheduler.unstable_now;var getCurrentPriorityLevel=Scheduler.unstable_getCurrentPriorityLevel;var ImmediatePriority=Scheduler.unstable_ImmediatePriority;var UserBlockingPriority=Scheduler.unstable_UserBlockingPriority;var NormalPriority=Scheduler.unstable_NormalPriority;var LowPriority=Scheduler.unstable_LowPriority;var IdlePriority=Scheduler.unstable_IdlePriority;// this doesn't actually exist on the scheduler, but it *does*
// on scheduler/unstable_mock, which we'll need for internal testing
var unstable_yieldValue=Scheduler.unstable_yieldValue;var unstable_setDisableYieldValue=Scheduler.unstable_setDisableYieldValue;var rendererID=null;var injectedHook=null;var injectedProfilingHooks=null;var hasLoggedError=false;var isDevToolsPresent=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined';function injectInternals(internals){if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__==='undefined'){// No DevTools
return false;}var hook=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(hook.isDisabled){// This isn't a real property on the hook, but it can be set to opt out
// of DevTools integration and associated warnings and logs.
// https://github.com/facebook/react/issues/3877
return true;}if(!hook.supportsFiber){{error('The installed version of React DevTools is too old and will not work '+'with the current version of React. Please update React DevTools. '+'https://reactjs.org/link/react-devtools');}// DevTools exists, even though it doesn't support Fiber.
return true;}try{if(enableSchedulingProfiler){// Conditionally inject these hooks only if Timeline profiler is supported by this build.
// This gives DevTools a way to feature detect that isn't tied to version number
// (since profiling and timeline are controlled by different feature flags).
internals=assign({},internals,{getLaneLabelMap:getLaneLabelMap,injectProfilingHooks:injectProfilingHooks});}rendererID=hook.inject(internals);// We have successfully injected, so now it is safe to set up hooks.
injectedHook=hook;}catch(err){// Catch all errors because it is unsafe to throw during initialization.
{error('React instrumentation encountered an error: %s.',err);}}if(hook.checkDCE){// This is the real DevTools.
return true;}else {// This is likely a hook installed by Fast Refresh runtime.
return false;}}function onScheduleRoot(root,children){{if(injectedHook&&typeof injectedHook.onScheduleFiberRoot==='function'){try{injectedHook.onScheduleFiberRoot(rendererID,root,children);}catch(err){if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onCommitRoot(root,eventPriority){if(injectedHook&&typeof injectedHook.onCommitFiberRoot==='function'){try{var didError=(root.current.flags&DidCapture)===DidCapture;if(enableProfilerTimer){var schedulerPriority;switch(eventPriority){case DiscreteEventPriority:schedulerPriority=ImmediatePriority;break;case ContinuousEventPriority:schedulerPriority=UserBlockingPriority;break;case DefaultEventPriority:schedulerPriority=NormalPriority;break;case IdleEventPriority:schedulerPriority=IdlePriority;break;default:schedulerPriority=NormalPriority;break;}injectedHook.onCommitFiberRoot(rendererID,root,schedulerPriority,didError);}}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onPostCommitRoot(root){if(injectedHook&&typeof injectedHook.onPostCommitFiberRoot==='function'){try{injectedHook.onPostCommitFiberRoot(rendererID,root);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onCommitUnmount(fiber){if(injectedHook&&typeof injectedHook.onCommitFiberUnmount==='function'){try{injectedHook.onCommitFiberUnmount(rendererID,fiber);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function setIsStrictModeForDevtools(newIsStrictMode){{if(typeof unstable_yieldValue==='function'){// We're in a test because Scheduler.unstable_yieldValue only exists
// in SchedulerMock. To reduce the noise in strict mode tests,
// suppress warnings and disable scheduler yielding during the double render
unstable_setDisableYieldValue(newIsStrictMode);setSuppressWarning(newIsStrictMode);}if(injectedHook&&typeof injectedHook.setStrictMode==='function'){try{injectedHook.setStrictMode(rendererID,newIsStrictMode);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}}// Profiler API hooks
function injectProfilingHooks(profilingHooks){injectedProfilingHooks=profilingHooks;}function getLaneLabelMap(){{var map=new Map();var lane=1;for(var index=0;index<TotalLanes;index++){var label=getLabelForLane(lane);map.set(lane,label);lane*=2;}return map;}}function markCommitStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markCommitStarted==='function'){injectedProfilingHooks.markCommitStarted(lanes);}}}function markCommitStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markCommitStopped==='function'){injectedProfilingHooks.markCommitStopped();}}}function markComponentRenderStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentRenderStarted==='function'){injectedProfilingHooks.markComponentRenderStarted(fiber);}}}function markComponentRenderStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentRenderStopped==='function'){injectedProfilingHooks.markComponentRenderStopped();}}}function markComponentPassiveEffectMountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted==='function'){injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);}}}function markComponentPassiveEffectMountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped==='function'){injectedProfilingHooks.markComponentPassiveEffectMountStopped();}}}function markComponentPassiveEffectUnmountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted==='function'){injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);}}}function markComponentPassiveEffectUnmountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped==='function'){injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();}}}function markComponentLayoutEffectMountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted==='function'){injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);}}}function markComponentLayoutEffectMountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped==='function'){injectedProfilingHooks.markComponentLayoutEffectMountStopped();}}}function markComponentLayoutEffectUnmountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted==='function'){injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);}}}function markComponentLayoutEffectUnmountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped==='function'){injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();}}}function markComponentErrored(fiber,thrownValue,lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentErrored==='function'){injectedProfilingHooks.markComponentErrored(fiber,thrownValue,lanes);}}}function markComponentSuspended(fiber,wakeable,lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentSuspended==='function'){injectedProfilingHooks.markComponentSuspended(fiber,wakeable,lanes);}}}function markLayoutEffectsStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markLayoutEffectsStarted==='function'){injectedProfilingHooks.markLayoutEffectsStarted(lanes);}}}function markLayoutEffectsStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markLayoutEffectsStopped==='function'){injectedProfilingHooks.markLayoutEffectsStopped();}}}function markPassiveEffectsStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markPassiveEffectsStarted==='function'){injectedProfilingHooks.markPassiveEffectsStarted(lanes);}}}function markPassiveEffectsStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markPassiveEffectsStopped==='function'){injectedProfilingHooks.markPassiveEffectsStopped();}}}function markRenderStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderStarted==='function'){injectedProfilingHooks.markRenderStarted(lanes);}}}function markRenderYielded(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderYielded==='function'){injectedProfilingHooks.markRenderYielded();}}}function markRenderStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderStopped==='function'){injectedProfilingHooks.markRenderStopped();}}}function markRenderScheduled(lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderScheduled==='function'){injectedProfilingHooks.markRenderScheduled(lane);}}}function markForceUpdateScheduled(fiber,lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markForceUpdateScheduled==='function'){injectedProfilingHooks.markForceUpdateScheduled(fiber,lane);}}}function markStateUpdateScheduled(fiber,lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markStateUpdateScheduled==='function'){injectedProfilingHooks.markStateUpdateScheduled(fiber,lane);}}}var NoMode=/*                         */0;// TODO: Remove ConcurrentMode by reading from the root tag instead
var ConcurrentMode=/*                 */1;var ProfileMode=/*                    */2;var StrictLegacyMode=/*               */8;var StrictEffectsMode=/*              */16;// TODO: This is pretty well supported by browsers. Maybe we can drop it.
var clz32=Math.clz32?Math.clz32:clz32Fallback;// Count leading zeros.
// Based on:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32
var log=Math.log;var LN2=Math.LN2;function clz32Fallback(x){var asUint=x>>>0;if(asUint===0){return 32;}return 31-(log(asUint)/LN2|0)|0;}// If those values are changed that package should be rebuilt and redeployed.
var TotalLanes=31;var NoLanes=/*                        */0;var NoLane=/*                          */0;var SyncLane=/*                        */1;var InputContinuousHydrationLane=/*    */2;var InputContinuousLane=/*             */4;var DefaultHydrationLane=/*            */8;var DefaultLane=/*                     */16;var TransitionHydrationLane=/*                */32;var TransitionLanes=/*                       */4194240;var TransitionLane1=/*                        */64;var TransitionLane2=/*                        */128;var TransitionLane3=/*                        */256;var TransitionLane4=/*                        */512;var TransitionLane5=/*                        */1024;var TransitionLane6=/*                        */2048;var TransitionLane7=/*                        */4096;var TransitionLane8=/*                        */8192;var TransitionLane9=/*                        */16384;var TransitionLane10=/*                       */32768;var TransitionLane11=/*                       */65536;var TransitionLane12=/*                       */131072;var TransitionLane13=/*                       */262144;var TransitionLane14=/*                       */524288;var TransitionLane15=/*                       */1048576;var TransitionLane16=/*                       */2097152;var RetryLanes=/*                            */130023424;var RetryLane1=/*                             */4194304;var RetryLane2=/*                             */8388608;var RetryLane3=/*                             */16777216;var RetryLane4=/*                             */33554432;var RetryLane5=/*                             */67108864;var SomeRetryLane=RetryLane1;var SelectiveHydrationLane=/*          */134217728;var NonIdleLanes=/*                          */268435455;var IdleHydrationLane=/*               */268435456;var IdleLane=/*                        */536870912;var OffscreenLane=/*                   */1073741824;// This function is used for the experimental timeline (react-devtools-timeline)
// It should be kept in sync with the Lanes values above.
function getLabelForLane(lane){{if(lane&SyncLane){return 'Sync';}if(lane&InputContinuousHydrationLane){return 'InputContinuousHydration';}if(lane&InputContinuousLane){return 'InputContinuous';}if(lane&DefaultHydrationLane){return 'DefaultHydration';}if(lane&DefaultLane){return 'Default';}if(lane&TransitionHydrationLane){return 'TransitionHydration';}if(lane&TransitionLanes){return 'Transition';}if(lane&RetryLanes){return 'Retry';}if(lane&SelectiveHydrationLane){return 'SelectiveHydration';}if(lane&IdleHydrationLane){return 'IdleHydration';}if(lane&IdleLane){return 'Idle';}if(lane&OffscreenLane){return 'Offscreen';}}}var NoTimestamp=-1;var nextTransitionLane=TransitionLane1;var nextRetryLane=RetryLane1;function getHighestPriorityLanes(lanes){switch(getHighestPriorityLane(lanes)){case SyncLane:return SyncLane;case InputContinuousHydrationLane:return InputContinuousHydrationLane;case InputContinuousLane:return InputContinuousLane;case DefaultHydrationLane:return DefaultHydrationLane;case DefaultLane:return DefaultLane;case TransitionHydrationLane:return TransitionHydrationLane;case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:return lanes&TransitionLanes;case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:return lanes&RetryLanes;case SelectiveHydrationLane:return SelectiveHydrationLane;case IdleHydrationLane:return IdleHydrationLane;case IdleLane:return IdleLane;case OffscreenLane:return OffscreenLane;default:{error('Should have found matching lanes. This is a bug in React.');}// This shouldn't be reachable, but as a fallback, return the entire bitmask.
return lanes;}}function getNextLanes(root,wipLanes){// Early bailout if there's no pending work left.
var pendingLanes=root.pendingLanes;if(pendingLanes===NoLanes){return NoLanes;}var nextLanes=NoLanes;var suspendedLanes=root.suspendedLanes;var pingedLanes=root.pingedLanes;// Do not work on any idle work until all the non-idle work has finished,
// even if the work is suspended.
var nonIdlePendingLanes=pendingLanes&NonIdleLanes;if(nonIdlePendingLanes!==NoLanes){var nonIdleUnblockedLanes=nonIdlePendingLanes&~suspendedLanes;if(nonIdleUnblockedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(nonIdleUnblockedLanes);}else {var nonIdlePingedLanes=nonIdlePendingLanes&pingedLanes;if(nonIdlePingedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(nonIdlePingedLanes);}}}else {// The only remaining work is Idle.
var unblockedLanes=pendingLanes&~suspendedLanes;if(unblockedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(unblockedLanes);}else {if(pingedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(pingedLanes);}}}if(nextLanes===NoLanes){// This should only be reachable if we're suspended
// TODO: Consider warning in this path if a fallback timer is not scheduled.
return NoLanes;}// If we're already in the middle of a render, switching lanes will interrupt
// it and we'll lose our progress. We should only do this if the new lanes are
// higher priority.
if(wipLanes!==NoLanes&&wipLanes!==nextLanes&&// If we already suspended with a delay, then interrupting is fine. Don't
// bother waiting until the root is complete.
(wipLanes&suspendedLanes)===NoLanes){var nextLane=getHighestPriorityLane(nextLanes);var wipLane=getHighestPriorityLane(wipLanes);if(// Tests whether the next lane is equal or lower priority than the wip
// one. This works because the bits decrease in priority as you go left.
nextLane>=wipLane||// Default priority updates should not interrupt transition updates. The
// only difference between default updates and transition updates is that
// default updates do not support refresh transitions.
nextLane===DefaultLane&&(wipLane&TransitionLanes)!==NoLanes){// Keep working on the existing in-progress tree. Do not interrupt.
return wipLanes;}}if((nextLanes&InputContinuousLane)!==NoLanes){// When updates are sync by default, we entangle continuous priority updates
// and default updates, so they render in the same batch. The only reason
// they use separate lanes is because continuous updates should interrupt
// transitions, but default updates should not.
nextLanes|=pendingLanes&DefaultLane;}// Check for entangled lanes and add them to the batch.
//
// A lane is said to be entangled with another when it's not allowed to render
// in a batch that does not also include the other lane. Typically we do this
// when multiple updates have the same source, and we only want to respond to
// the most recent event from that source.
//
// Note that we apply entanglements *after* checking for partial work above.
// This means that if a lane is entangled during an interleaved event while
// it's already rendering, we won't interrupt it. This is intentional, since
// entanglement is usually "best effort": we'll try our best to render the
// lanes in the same batch, but it's not worth throwing out partially
// completed work in order to do it.
// TODO: Reconsider this. The counter-argument is that the partial work
// represents an intermediate state, which we don't want to show to the user.
// And by spending extra time finishing it, we're increasing the amount of
// time it takes to show the final state, which is what they are actually
// waiting for.
//
// For those exceptions where entanglement is semantically important, like
// useMutableSource, we should ensure that there is no partial work at the
// time we apply the entanglement.
var entangledLanes=root.entangledLanes;if(entangledLanes!==NoLanes){var entanglements=root.entanglements;var lanes=nextLanes&entangledLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;nextLanes|=entanglements[index];lanes&=~lane;}}return nextLanes;}function getMostRecentEventTime(root,lanes){var eventTimes=root.eventTimes;var mostRecentEventTime=NoTimestamp;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;var eventTime=eventTimes[index];if(eventTime>mostRecentEventTime){mostRecentEventTime=eventTime;}lanes&=~lane;}return mostRecentEventTime;}function computeExpirationTime(lane,currentTime){switch(lane){case SyncLane:case InputContinuousHydrationLane:case InputContinuousLane:// User interactions should expire slightly more quickly.
//
// NOTE: This is set to the corresponding constant as in Scheduler.js.
// When we made it larger, a product metric in www regressed, suggesting
// there's a user interaction that's being starved by a series of
// synchronous updates. If that theory is correct, the proper solution is
// to fix the starvation. However, this scenario supports the idea that
// expiration times are an important safeguard when starvation
// does happen.
return currentTime+250;case DefaultHydrationLane:case DefaultLane:case TransitionHydrationLane:case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:return currentTime+5000;case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:// TODO: Retries should be allowed to expire if they are CPU bound for
// too long, but when I made this change it caused a spike in browser
// crashes. There must be some other underlying bug; not super urgent but
// ideally should figure out why and fix it. Unfortunately we don't have
// a repro for the crashes, only detected via production metrics.
return NoTimestamp;case SelectiveHydrationLane:case IdleHydrationLane:case IdleLane:case OffscreenLane:// Anything idle priority or lower should never expire.
return NoTimestamp;default:{error('Should have found matching lanes. This is a bug in React.');}return NoTimestamp;}}function markStarvedLanesAsExpired(root,currentTime){// TODO: This gets called every time we yield. We can optimize by storing
// the earliest expiration time on the root. Then use that to quickly bail out
// of this function.
var pendingLanes=root.pendingLanes;var suspendedLanes=root.suspendedLanes;var pingedLanes=root.pingedLanes;var expirationTimes=root.expirationTimes;// Iterate through the pending lanes and check if we've reached their
// expiration time. If so, we'll assume the update is being starved and mark
// it as expired to force it to finish.
var lanes=pendingLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;var expirationTime=expirationTimes[index];if(expirationTime===NoTimestamp){// Found a pending lane with no expiration time. If it's not suspended, or
// if it's pinged, assume it's CPU-bound. Compute a new expiration time
// using the current time.
if((lane&suspendedLanes)===NoLanes||(lane&pingedLanes)!==NoLanes){// Assumes timestamps are monotonically increasing.
expirationTimes[index]=computeExpirationTime(lane,currentTime);}}else if(expirationTime<=currentTime){// This lane expired
root.expiredLanes|=lane;}lanes&=~lane;}}// This returns the highest priority pending lanes regardless of whether they
// are suspended.
function getHighestPriorityPendingLanes(root){return getHighestPriorityLanes(root.pendingLanes);}function getLanesToRetrySynchronouslyOnError(root){var everythingButOffscreen=root.pendingLanes&~OffscreenLane;if(everythingButOffscreen!==NoLanes){return everythingButOffscreen;}if(everythingButOffscreen&OffscreenLane){return OffscreenLane;}return NoLanes;}function includesSyncLane(lanes){return (lanes&SyncLane)!==NoLanes;}function includesNonIdleWork(lanes){return (lanes&NonIdleLanes)!==NoLanes;}function includesOnlyRetries(lanes){return (lanes&RetryLanes)===lanes;}function includesOnlyNonUrgentLanes(lanes){var UrgentLanes=SyncLane|InputContinuousLane|DefaultLane;return (lanes&UrgentLanes)===NoLanes;}function includesOnlyTransitions(lanes){return (lanes&TransitionLanes)===lanes;}function includesBlockingLane(root,lanes){var SyncDefaultLanes=InputContinuousHydrationLane|InputContinuousLane|DefaultHydrationLane|DefaultLane;return (lanes&SyncDefaultLanes)!==NoLanes;}function includesExpiredLane(root,lanes){// This is a separate check from includesBlockingLane because a lane can
// expire after a render has already started.
return (lanes&root.expiredLanes)!==NoLanes;}function isTransitionLane(lane){return (lane&TransitionLanes)!==NoLanes;}function claimNextTransitionLane(){// Cycle through the lanes, assigning each new transition to the next lane.
// In most cases, this means every transition gets its own lane, until we
// run out of lanes and cycle back to the beginning.
var lane=nextTransitionLane;nextTransitionLane<<=1;if((nextTransitionLane&TransitionLanes)===NoLanes){nextTransitionLane=TransitionLane1;}return lane;}function claimNextRetryLane(){var lane=nextRetryLane;nextRetryLane<<=1;if((nextRetryLane&RetryLanes)===NoLanes){nextRetryLane=RetryLane1;}return lane;}function getHighestPriorityLane(lanes){return lanes&-lanes;}function pickArbitraryLane(lanes){// This wrapper function gets inlined. Only exists so to communicate that it
// doesn't matter which bit is selected; you can pick any bit without
// affecting the algorithms where its used. Here I'm using
// getHighestPriorityLane because it requires the fewest operations.
return getHighestPriorityLane(lanes);}function pickArbitraryLaneIndex(lanes){return 31-clz32(lanes);}function laneToIndex(lane){return pickArbitraryLaneIndex(lane);}function includesSomeLane(a,b){return (a&b)!==NoLanes;}function isSubsetOfLanes(set,subset){return (set&subset)===subset;}function mergeLanes(a,b){return a|b;}function removeLanes(set,subset){return set&~subset;}function intersectLanes(a,b){return a&b;}// Seems redundant, but it changes the type from a single lane (used for
// updates) to a group of lanes (used for flushing work).
function laneToLanes(lane){return lane;}function higherPriorityLane(a,b){// This works because the bit ranges decrease in priority as you go left.
return a!==NoLane&&a<b?a:b;}function createLaneMap(initial){// Intentionally pushing one by one.
// https://v8.dev/blog/elements-kinds#avoid-creating-holes
var laneMap=[];for(var i=0;i<TotalLanes;i++){laneMap.push(initial);}return laneMap;}function markRootUpdated(root,updateLane,eventTime){root.pendingLanes|=updateLane;// If there are any suspended transitions, it's possible this new update
// could unblock them. Clear the suspended lanes so that we can try rendering
// them again.
//
// TODO: We really only need to unsuspend only lanes that are in the
// `subtreeLanes` of the updated fiber, or the update lanes of the return
// path. This would exclude suspended updates in an unrelated sibling tree,
// since there's no way for this update to unblock it.
//
// We don't do this if the incoming update is idle, because we never process
// idle updates until after all the regular updates have finished; there's no
// way it could unblock a transition.
if(updateLane!==IdleLane){root.suspendedLanes=NoLanes;root.pingedLanes=NoLanes;}var eventTimes=root.eventTimes;var index=laneToIndex(updateLane);// We can always overwrite an existing timestamp because we prefer the most
// recent event, and we assume time is monotonically increasing.
eventTimes[index]=eventTime;}function markRootSuspended(root,suspendedLanes){root.suspendedLanes|=suspendedLanes;root.pingedLanes&=~suspendedLanes;// The suspended lanes are no longer CPU-bound. Clear their expiration times.
var expirationTimes=root.expirationTimes;var lanes=suspendedLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;expirationTimes[index]=NoTimestamp;lanes&=~lane;}}function markRootPinged(root,pingedLanes,eventTime){root.pingedLanes|=root.suspendedLanes&pingedLanes;}function markRootFinished(root,remainingLanes){var noLongerPendingLanes=root.pendingLanes&~remainingLanes;root.pendingLanes=remainingLanes;// Let's try everything again
root.suspendedLanes=NoLanes;root.pingedLanes=NoLanes;root.expiredLanes&=remainingLanes;root.mutableReadLanes&=remainingLanes;root.entangledLanes&=remainingLanes;var entanglements=root.entanglements;var eventTimes=root.eventTimes;var expirationTimes=root.expirationTimes;// Clear the lanes that no longer have pending work
var lanes=noLongerPendingLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;entanglements[index]=NoLanes;eventTimes[index]=NoTimestamp;expirationTimes[index]=NoTimestamp;lanes&=~lane;}}function markRootEntangled(root,entangledLanes){// In addition to entangling each of the given lanes with each other, we also
// have to consider _transitive_ entanglements. For each lane that is already
// entangled with *any* of the given lanes, that lane is now transitively
// entangled with *all* the given lanes.
//
// Translated: If C is entangled with A, then entangling A with B also
// entangles C with B.
//
// If this is hard to grasp, it might help to intentionally break this
// function and look at the tests that fail in ReactTransition-test.js. Try
// commenting out one of the conditions below.
var rootEntangledLanes=root.entangledLanes|=entangledLanes;var entanglements=root.entanglements;var lanes=rootEntangledLanes;while(lanes){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;if(// Is this one of the newly entangled lanes?
lane&entangledLanes|// Is this lane transitively entangled with the newly entangled lanes?
entanglements[index]&entangledLanes){entanglements[index]|=entangledLanes;}lanes&=~lane;}}function getBumpedLaneForHydration(root,renderLanes){var renderLane=getHighestPriorityLane(renderLanes);var lane;switch(renderLane){case InputContinuousLane:lane=InputContinuousHydrationLane;break;case DefaultLane:lane=DefaultHydrationLane;break;case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:lane=TransitionHydrationLane;break;case IdleLane:lane=IdleHydrationLane;break;default:// Everything else is already either a hydration lane, or shouldn't
// be retried at a hydration lane.
lane=NoLane;break;}// Check if the lane we chose is suspended. If so, that indicates that we
// already attempted and failed to hydrate at that level. Also check if we're
// already rendering that lane, which is rare but could happen.
if((lane&(root.suspendedLanes|renderLanes))!==NoLane){// Give up trying to hydrate and fall back to client render.
return NoLane;}return lane;}function addFiberToLanesMap(root,fiber,lanes){if(!isDevToolsPresent){return;}var pendingUpdatersLaneMap=root.pendingUpdatersLaneMap;while(lanes>0){var index=laneToIndex(lanes);var lane=1<<index;var updaters=pendingUpdatersLaneMap[index];updaters.add(fiber);lanes&=~lane;}}function movePendingFibersToMemoized(root,lanes){if(!isDevToolsPresent){return;}var pendingUpdatersLaneMap=root.pendingUpdatersLaneMap;var memoizedUpdaters=root.memoizedUpdaters;while(lanes>0){var index=laneToIndex(lanes);var lane=1<<index;var updaters=pendingUpdatersLaneMap[index];if(updaters.size>0){updaters.forEach(function(fiber){var alternate=fiber.alternate;if(alternate===null||!memoizedUpdaters.has(alternate)){memoizedUpdaters.add(fiber);}});updaters.clear();}lanes&=~lane;}}function getTransitionsForLanes(root,lanes){{return null;}}var DiscreteEventPriority=SyncLane;var ContinuousEventPriority=InputContinuousLane;var DefaultEventPriority=DefaultLane;var IdleEventPriority=IdleLane;var currentUpdatePriority=NoLane;function getCurrentUpdatePriority(){return currentUpdatePriority;}function setCurrentUpdatePriority(newPriority){currentUpdatePriority=newPriority;}function runWithPriority(priority,fn){var previousPriority=currentUpdatePriority;try{currentUpdatePriority=priority;return fn();}finally{currentUpdatePriority=previousPriority;}}function higherEventPriority(a,b){return a!==0&&a<b?a:b;}function lowerEventPriority(a,b){return a===0||a>b?a:b;}function isHigherEventPriority(a,b){return a!==0&&a<b;}function lanesToEventPriority(lanes){var lane=getHighestPriorityLane(lanes);if(!isHigherEventPriority(DiscreteEventPriority,lane)){return DiscreteEventPriority;}if(!isHigherEventPriority(ContinuousEventPriority,lane)){return ContinuousEventPriority;}if(includesNonIdleWork(lane)){return DefaultEventPriority;}return IdleEventPriority;}// This is imported by the event replaying implementation in React DOM. It's
// in a separate file to break a circular dependency between the renderer and
// the reconciler.
function isRootDehydrated(root){var currentState=root.current.memoizedState;return currentState.isDehydrated;}var _attemptSynchronousHydration;function setAttemptSynchronousHydration(fn){_attemptSynchronousHydration=fn;}function attemptSynchronousHydration(fiber){_attemptSynchronousHydration(fiber);}var attemptContinuousHydration;function setAttemptContinuousHydration(fn){attemptContinuousHydration=fn;}var attemptHydrationAtCurrentPriority;function setAttemptHydrationAtCurrentPriority(fn){attemptHydrationAtCurrentPriority=fn;}var getCurrentUpdatePriority$1;function setGetCurrentUpdatePriority(fn){getCurrentUpdatePriority$1=fn;}var attemptHydrationAtPriority;function setAttemptHydrationAtPriority(fn){attemptHydrationAtPriority=fn;}// TODO: Upgrade this definition once we're on a newer version of Flow that
// has this definition built-in.
var hasScheduledReplayAttempt=false;// The queue of discrete events to be replayed.
var queuedDiscreteEvents=[];// Indicates if any continuous event targets are non-null for early bailout.
// if the last target was dehydrated.
var queuedFocus=null;var queuedDrag=null;var queuedMouse=null;// For pointer events there can be one latest event per pointerId.
var queuedPointers=new Map();var queuedPointerCaptures=new Map();// We could consider replaying selectionchange and touchmoves too.
var queuedExplicitHydrationTargets=[];var discreteReplayableEvents=['mousedown','mouseup','touchcancel','touchend','touchstart','auxclick','dblclick','pointercancel','pointerdown','pointerup','dragend','dragstart','drop','compositionend','compositionstart','keydown','keypress','keyup','input','textInput',// Intentionally camelCase
'copy','cut','paste','click','change','contextmenu','reset','submit'];function isDiscreteEventThatRequiresHydration(eventType){return discreteReplayableEvents.indexOf(eventType)>-1;}function createQueuedReplayableEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){return {blockedOn:blockedOn,domEventName:domEventName,eventSystemFlags:eventSystemFlags,nativeEvent:nativeEvent,targetContainers:[targetContainer]};}function clearIfContinuousEvent(domEventName,nativeEvent){switch(domEventName){case'focusin':case'focusout':queuedFocus=null;break;case'dragenter':case'dragleave':queuedDrag=null;break;case'mouseover':case'mouseout':queuedMouse=null;break;case'pointerover':case'pointerout':{var pointerId=nativeEvent.pointerId;queuedPointers.delete(pointerId);break;}case'gotpointercapture':case'lostpointercapture':{var _pointerId=nativeEvent.pointerId;queuedPointerCaptures.delete(_pointerId);break;}}}function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent,blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){if(existingQueuedEvent===null||existingQueuedEvent.nativeEvent!==nativeEvent){var queuedEvent=createQueuedReplayableEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent);if(blockedOn!==null){var _fiber2=getInstanceFromNode(blockedOn);if(_fiber2!==null){// Attempt to increase the priority of this target.
attemptContinuousHydration(_fiber2);}}return queuedEvent;}// If we have already queued this exact event, then it's because
// the different event systems have different DOM event listeners.
// We can accumulate the flags, and the targetContainers, and
// store a single event to be replayed.
existingQueuedEvent.eventSystemFlags|=eventSystemFlags;var targetContainers=existingQueuedEvent.targetContainers;if(targetContainer!==null&&targetContainers.indexOf(targetContainer)===-1){targetContainers.push(targetContainer);}return existingQueuedEvent;}function queueIfContinuousEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){// These set relatedTarget to null because the replayed event will be treated as if we
// moved from outside the window (no target) onto the target once it hydrates.
// Instead of mutating we could clone the event.
switch(domEventName){case'focusin':{var focusEvent=nativeEvent;queuedFocus=accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus,blockedOn,domEventName,eventSystemFlags,targetContainer,focusEvent);return true;}case'dragenter':{var dragEvent=nativeEvent;queuedDrag=accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag,blockedOn,domEventName,eventSystemFlags,targetContainer,dragEvent);return true;}case'mouseover':{var mouseEvent=nativeEvent;queuedMouse=accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse,blockedOn,domEventName,eventSystemFlags,targetContainer,mouseEvent);return true;}case'pointerover':{var pointerEvent=nativeEvent;var pointerId=pointerEvent.pointerId;queuedPointers.set(pointerId,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId)||null,blockedOn,domEventName,eventSystemFlags,targetContainer,pointerEvent));return true;}case'gotpointercapture':{var _pointerEvent=nativeEvent;var _pointerId2=_pointerEvent.pointerId;queuedPointerCaptures.set(_pointerId2,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2)||null,blockedOn,domEventName,eventSystemFlags,targetContainer,_pointerEvent));return true;}}return false;}// Check if this target is unblocked. Returns true if it's unblocked.
function attemptExplicitHydrationTarget(queuedTarget){// TODO: This function shares a lot of logic with findInstanceBlockingEvent.
// Try to unify them. It's a bit tricky since it would require two return
// values.
var targetInst=getClosestInstanceFromNode(queuedTarget.target);if(targetInst!==null){var nearestMounted=getNearestMountedFiber(targetInst);if(nearestMounted!==null){var tag=nearestMounted.tag;if(tag===SuspenseComponent){var instance=getSuspenseInstanceFromFiber(nearestMounted);if(instance!==null){// We're blocked on hydrating this boundary.
// Increase its priority.
queuedTarget.blockedOn=instance;attemptHydrationAtPriority(queuedTarget.priority,function(){attemptHydrationAtCurrentPriority(nearestMounted);});return;}}else if(tag===HostRoot){var root=nearestMounted.stateNode;if(isRootDehydrated(root)){queuedTarget.blockedOn=getContainerFromFiber(nearestMounted);// We don't currently have a way to increase the priority of
// a root other than sync.
return;}}}}queuedTarget.blockedOn=null;}function queueExplicitHydrationTarget(target){// TODO: This will read the priority if it's dispatched by the React
// event system but not native events. Should read window.event.type, like
// we do for updates (getCurrentEventPriority).
var updatePriority=getCurrentUpdatePriority$1();var queuedTarget={blockedOn:null,target:target,priority:updatePriority};var i=0;for(;i<queuedExplicitHydrationTargets.length;i++){// Stop once we hit the first target with lower priority than
if(!isHigherEventPriority(updatePriority,queuedExplicitHydrationTargets[i].priority)){break;}}queuedExplicitHydrationTargets.splice(i,0,queuedTarget);if(i===0){attemptExplicitHydrationTarget(queuedTarget);}}function attemptReplayContinuousQueuedEvent(queuedEvent){if(queuedEvent.blockedOn!==null){return false;}var targetContainers=queuedEvent.targetContainers;while(targetContainers.length>0){var targetContainer=targetContainers[0];var nextBlockedOn=findInstanceBlockingEvent(queuedEvent.domEventName,queuedEvent.eventSystemFlags,targetContainer,queuedEvent.nativeEvent);if(nextBlockedOn===null){{var nativeEvent=queuedEvent.nativeEvent;var nativeEventClone=new nativeEvent.constructor(nativeEvent.type,nativeEvent);setReplayingEvent(nativeEventClone);nativeEvent.target.dispatchEvent(nativeEventClone);resetReplayingEvent();}}else {// We're still blocked. Try again later.
var _fiber3=getInstanceFromNode(nextBlockedOn);if(_fiber3!==null){attemptContinuousHydration(_fiber3);}queuedEvent.blockedOn=nextBlockedOn;return false;}// This target container was successfully dispatched. Try the next.
targetContainers.shift();}return true;}function attemptReplayContinuousQueuedEventInMap(queuedEvent,key,map){if(attemptReplayContinuousQueuedEvent(queuedEvent)){map.delete(key);}}function replayUnblockedEvents(){hasScheduledReplayAttempt=false;if(queuedFocus!==null&&attemptReplayContinuousQueuedEvent(queuedFocus)){queuedFocus=null;}if(queuedDrag!==null&&attemptReplayContinuousQueuedEvent(queuedDrag)){queuedDrag=null;}if(queuedMouse!==null&&attemptReplayContinuousQueuedEvent(queuedMouse)){queuedMouse=null;}queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);}function scheduleCallbackIfUnblocked(queuedEvent,unblocked){if(queuedEvent.blockedOn===unblocked){queuedEvent.blockedOn=null;if(!hasScheduledReplayAttempt){hasScheduledReplayAttempt=true;// Schedule a callback to attempt replaying as many events as are
// now unblocked. This first might not actually be unblocked yet.
// We could check it early to avoid scheduling an unnecessary callback.
Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority,replayUnblockedEvents);}}}function retryIfBlockedOn(unblocked){// Mark anything that was blocked on this as no longer blocked
// and eligible for a replay.
if(queuedDiscreteEvents.length>0){scheduleCallbackIfUnblocked(queuedDiscreteEvents[0],unblocked);// This is a exponential search for each boundary that commits. I think it's
// worth it because we expect very few discrete events to queue up and once
// we are actually fully unblocked it will be fast to replay them.
for(var i=1;i<queuedDiscreteEvents.length;i++){var queuedEvent=queuedDiscreteEvents[i];if(queuedEvent.blockedOn===unblocked){queuedEvent.blockedOn=null;}}}if(queuedFocus!==null){scheduleCallbackIfUnblocked(queuedFocus,unblocked);}if(queuedDrag!==null){scheduleCallbackIfUnblocked(queuedDrag,unblocked);}if(queuedMouse!==null){scheduleCallbackIfUnblocked(queuedMouse,unblocked);}var unblock=function(queuedEvent){return scheduleCallbackIfUnblocked(queuedEvent,unblocked);};queuedPointers.forEach(unblock);queuedPointerCaptures.forEach(unblock);for(var _i=0;_i<queuedExplicitHydrationTargets.length;_i++){var queuedTarget=queuedExplicitHydrationTargets[_i];if(queuedTarget.blockedOn===unblocked){queuedTarget.blockedOn=null;}}while(queuedExplicitHydrationTargets.length>0){var nextExplicitTarget=queuedExplicitHydrationTargets[0];if(nextExplicitTarget.blockedOn!==null){// We're still blocked.
break;}else {attemptExplicitHydrationTarget(nextExplicitTarget);if(nextExplicitTarget.blockedOn===null){// We're unblocked.
queuedExplicitHydrationTargets.shift();}}}}var ReactCurrentBatchConfig=ReactSharedInternals.ReactCurrentBatchConfig;// TODO: can we stop exporting these?
var _enabled=true;// This is exported in FB builds for use by legacy FB layer infra.
// We'd like to remove this but it's not clear if this is safe.
function setEnabled(enabled){_enabled=!!enabled;}function isEnabled(){return _enabled;}function createEventListenerWrapperWithPriority(targetContainer,domEventName,eventSystemFlags){var eventPriority=getEventPriority(domEventName);var listenerWrapper;switch(eventPriority){case DiscreteEventPriority:listenerWrapper=dispatchDiscreteEvent;break;case ContinuousEventPriority:listenerWrapper=dispatchContinuousEvent;break;case DefaultEventPriority:default:listenerWrapper=dispatchEvent;break;}return listenerWrapper.bind(null,domEventName,eventSystemFlags,targetContainer);}function dispatchDiscreteEvent(domEventName,eventSystemFlags,container,nativeEvent){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig.transition;ReactCurrentBatchConfig.transition=null;try{setCurrentUpdatePriority(DiscreteEventPriority);dispatchEvent(domEventName,eventSystemFlags,container,nativeEvent);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig.transition=prevTransition;}}function dispatchContinuousEvent(domEventName,eventSystemFlags,container,nativeEvent){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig.transition;ReactCurrentBatchConfig.transition=null;try{setCurrentUpdatePriority(ContinuousEventPriority);dispatchEvent(domEventName,eventSystemFlags,container,nativeEvent);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig.transition=prevTransition;}}function dispatchEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent){if(!_enabled){return;}{dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName,eventSystemFlags,targetContainer,nativeEvent);}}function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName,eventSystemFlags,targetContainer,nativeEvent){var blockedOn=findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent);if(blockedOn===null){dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,return_targetInst,targetContainer);clearIfContinuousEvent(domEventName,nativeEvent);return;}if(queueIfContinuousEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent)){nativeEvent.stopPropagation();return;}// We need to clear only if we didn't queue because
// queueing is accumulative.
clearIfContinuousEvent(domEventName,nativeEvent);if(eventSystemFlags&IS_CAPTURE_PHASE&&isDiscreteEventThatRequiresHydration(domEventName)){while(blockedOn!==null){var fiber=getInstanceFromNode(blockedOn);if(fiber!==null){attemptSynchronousHydration(fiber);}var nextBlockedOn=findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent);if(nextBlockedOn===null){dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,return_targetInst,targetContainer);}if(nextBlockedOn===blockedOn){break;}blockedOn=nextBlockedOn;}if(blockedOn!==null){nativeEvent.stopPropagation();}return;}// This is not replayable so we'll invoke it but without a target,
// in case the event system needs to trace it.
dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,null,targetContainer);}var return_targetInst=null;// Returns a SuspenseInstance or Container if it's blocked.
// The return_targetInst field above is conceptually part of the return value.
function findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent){// TODO: Warn if _enabled is false.
return_targetInst=null;var nativeEventTarget=getEventTarget(nativeEvent);var targetInst=getClosestInstanceFromNode(nativeEventTarget);if(targetInst!==null){var nearestMounted=getNearestMountedFiber(targetInst);if(nearestMounted===null){// This tree has been unmounted already. Dispatch without a target.
targetInst=null;}else {var tag=nearestMounted.tag;if(tag===SuspenseComponent){var instance=getSuspenseInstanceFromFiber(nearestMounted);if(instance!==null){// Queue the event to be replayed later. Abort dispatching since we
// don't want this event dispatched twice through the event system.
// TODO: If this is the first discrete event in the queue. Schedule an increased
// priority for this boundary.
return instance;}// This shouldn't happen, something went wrong but to avoid blocking
// the whole system, dispatch the event without a target.
// TODO: Warn.
targetInst=null;}else if(tag===HostRoot){var root=nearestMounted.stateNode;if(isRootDehydrated(root)){// If this happens during a replay something went wrong and it might block
// the whole system.
return getContainerFromFiber(nearestMounted);}targetInst=null;}else if(nearestMounted!==targetInst){// If we get an event (ex: img onload) before committing that
// component's mount, ignore it for now (that is, treat it as if it was an
// event on a non-React tree). We might also consider queueing events and
// dispatching them after the mount.
targetInst=null;}}}return_targetInst=targetInst;// We're not blocked on anything.
return null;}function getEventPriority(domEventName){switch(domEventName){// Used by SimpleEventPlugin:
case'cancel':case'click':case'close':case'contextmenu':case'copy':case'cut':case'auxclick':case'dblclick':case'dragend':case'dragstart':case'drop':case'focusin':case'focusout':case'input':case'invalid':case'keydown':case'keypress':case'keyup':case'mousedown':case'mouseup':case'paste':case'pause':case'play':case'pointercancel':case'pointerdown':case'pointerup':case'ratechange':case'reset':case'resize':case'seeked':case'submit':case'touchcancel':case'touchend':case'touchstart':case'volumechange':// Used by polyfills:
// eslint-disable-next-line no-fallthrough
case'change':case'selectionchange':case'textInput':case'compositionstart':case'compositionend':case'compositionupdate':// Only enableCreateEventHandleAPI:
// eslint-disable-next-line no-fallthrough
case'beforeblur':case'afterblur':// Not used by React but could be by user code:
// eslint-disable-next-line no-fallthrough
case'beforeinput':case'blur':case'fullscreenchange':case'focus':case'hashchange':case'popstate':case'select':case'selectstart':return DiscreteEventPriority;case'drag':case'dragenter':case'dragexit':case'dragleave':case'dragover':case'mousemove':case'mouseout':case'mouseover':case'pointermove':case'pointerout':case'pointerover':case'scroll':case'toggle':case'touchmove':case'wheel':// Not used by React but could be by user code:
// eslint-disable-next-line no-fallthrough
case'mouseenter':case'mouseleave':case'pointerenter':case'pointerleave':return ContinuousEventPriority;case'message':{// We might be in the Scheduler callback.
// Eventually this mechanism will be replaced by a check
// of the current priority on the native scheduler.
var schedulerPriority=getCurrentPriorityLevel();switch(schedulerPriority){case ImmediatePriority:return DiscreteEventPriority;case UserBlockingPriority:return ContinuousEventPriority;case NormalPriority:case LowPriority:// TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.
return DefaultEventPriority;case IdlePriority:return IdleEventPriority;default:return DefaultEventPriority;}}default:return DefaultEventPriority;}}function addEventBubbleListener(target,eventType,listener){target.addEventListener(eventType,listener,false);return listener;}function addEventCaptureListener(target,eventType,listener){target.addEventListener(eventType,listener,true);return listener;}function addEventCaptureListenerWithPassiveFlag(target,eventType,listener,passive){target.addEventListener(eventType,listener,{capture:true,passive:passive});return listener;}function addEventBubbleListenerWithPassiveFlag(target,eventType,listener,passive){target.addEventListener(eventType,listener,{passive:passive});return listener;}/**
 * These variables store information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */var root=null;var startText=null;var fallbackText=null;function initialize(nativeEventTarget){root=nativeEventTarget;startText=getText();return true;}function reset(){root=null;startText=null;fallbackText=null;}function getData(){if(fallbackText){return fallbackText;}var start;var startValue=startText;var startLength=startValue.length;var end;var endValue=getText();var endLength=endValue.length;for(start=0;start<startLength;start++){if(startValue[start]!==endValue[start]){break;}}var minEnd=startLength-start;for(end=1;end<=minEnd;end++){if(startValue[startLength-end]!==endValue[endLength-end]){break;}}var sliceTail=end>1?1-end:undefined;fallbackText=endValue.slice(start,sliceTail);return fallbackText;}function getText(){if('value'in root){return root.value;}return root.textContent;}/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */function getEventCharCode(nativeEvent){var charCode;var keyCode=nativeEvent.keyCode;if('charCode'in nativeEvent){charCode=nativeEvent.charCode;// FF does not set `charCode` for the Enter-key, check against `keyCode`.
if(charCode===0&&keyCode===13){charCode=13;}}else {// IE8 does not implement `charCode`, but `keyCode` has the correct value.
charCode=keyCode;}// IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)
// report Enter as charCode 10 when ctrl is pressed.
if(charCode===10){charCode=13;}// Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
// Must not discard the (non-)printable Enter-key.
if(charCode>=32||charCode===13){return charCode;}return 0;}function functionThatReturnsTrue(){return true;}function functionThatReturnsFalse(){return false;}// This is intentionally a factory so that we have different returned constructors.
// If we had a single constructor, it would be megamorphic and engines would deopt.
function createSyntheticEvent(Interface){/**
   * Synthetic events are dispatched by event plugins, typically in response to a
   * top-level event delegation handler.
   *
   * These systems should generally use pooling to reduce the frequency of garbage
   * collection. The system should check `isPersistent` to determine whether the
   * event should be released into the pool after being dispatched. Users that
   * need a persisted event should invoke `persist`.
   *
   * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
   * normalizing browser quirks. Subclasses do not necessarily have to implement a
   * DOM interface; custom application-specific events can also subclass this.
   */function SyntheticBaseEvent(reactName,reactEventType,targetInst,nativeEvent,nativeEventTarget){this._reactName=reactName;this._targetInst=targetInst;this.type=reactEventType;this.nativeEvent=nativeEvent;this.target=nativeEventTarget;this.currentTarget=null;for(var _propName in Interface){if(!Interface.hasOwnProperty(_propName)){continue;}var normalize=Interface[_propName];if(normalize){this[_propName]=normalize(nativeEvent);}else {this[_propName]=nativeEvent[_propName];}}var defaultPrevented=nativeEvent.defaultPrevented!=null?nativeEvent.defaultPrevented:nativeEvent.returnValue===false;if(defaultPrevented){this.isDefaultPrevented=functionThatReturnsTrue;}else {this.isDefaultPrevented=functionThatReturnsFalse;}this.isPropagationStopped=functionThatReturnsFalse;return this;}assign(SyntheticBaseEvent.prototype,{preventDefault:function(){this.defaultPrevented=true;var event=this.nativeEvent;if(!event){return;}if(event.preventDefault){event.preventDefault();// $FlowFixMe - flow is not aware of `unknown` in IE
}else if(typeof event.returnValue!=='unknown'){event.returnValue=false;}this.isDefaultPrevented=functionThatReturnsTrue;},stopPropagation:function(){var event=this.nativeEvent;if(!event){return;}if(event.stopPropagation){event.stopPropagation();// $FlowFixMe - flow is not aware of `unknown` in IE
}else if(typeof event.cancelBubble!=='unknown'){// The ChangeEventPlugin registers a "propertychange" event for
// IE. This event does not support bubbling or cancelling, and
// any references to cancelBubble throw "Member not found".  A
// typeof check of "unknown" circumvents this issue (and is also
// IE specific).
event.cancelBubble=true;}this.isPropagationStopped=functionThatReturnsTrue;},/**
     * We release all dispatched `SyntheticEvent`s after each event loop, adding
     * them back into the pool. This allows a way to hold onto a reference that
     * won't be added back into the pool.
     */persist:function(){// Modern event system doesn't use pooling.
},/**
     * Checks if this event should be released back into the pool.
     *
     * @return {boolean} True if this should not be released, false otherwise.
     */isPersistent:functionThatReturnsTrue});return SyntheticBaseEvent;}/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var EventInterface={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(event){return event.timeStamp||Date.now();},defaultPrevented:0,isTrusted:0};var SyntheticEvent=createSyntheticEvent(EventInterface);var UIEventInterface=assign({},EventInterface,{view:0,detail:0});var SyntheticUIEvent=createSyntheticEvent(UIEventInterface);var lastMovementX;var lastMovementY;var lastMouseEvent;function updateMouseMovementPolyfillState(event){if(event!==lastMouseEvent){if(lastMouseEvent&&event.type==='mousemove'){lastMovementX=event.screenX-lastMouseEvent.screenX;lastMovementY=event.screenY-lastMouseEvent.screenY;}else {lastMovementX=0;lastMovementY=0;}lastMouseEvent=event;}}/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var MouseEventInterface=assign({},UIEventInterface,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:getEventModifierState,button:0,buttons:0,relatedTarget:function(event){if(event.relatedTarget===undefined)return event.fromElement===event.srcElement?event.toElement:event.fromElement;return event.relatedTarget;},movementX:function(event){if('movementX'in event){return event.movementX;}updateMouseMovementPolyfillState(event);return lastMovementX;},movementY:function(event){if('movementY'in event){return event.movementY;}// Don't need to call updateMouseMovementPolyfillState() here
// because it's guaranteed to have already run when movementX
// was copied.
return lastMovementY;}});var SyntheticMouseEvent=createSyntheticEvent(MouseEventInterface);/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var DragEventInterface=assign({},MouseEventInterface,{dataTransfer:0});var SyntheticDragEvent=createSyntheticEvent(DragEventInterface);/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var FocusEventInterface=assign({},UIEventInterface,{relatedTarget:0});var SyntheticFocusEvent=createSyntheticEvent(FocusEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */var AnimationEventInterface=assign({},EventInterface,{animationName:0,elapsedTime:0,pseudoElement:0});var SyntheticAnimationEvent=createSyntheticEvent(AnimationEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */var ClipboardEventInterface=assign({},EventInterface,{clipboardData:function(event){return 'clipboardData'in event?event.clipboardData:window.clipboardData;}});var SyntheticClipboardEvent=createSyntheticEvent(ClipboardEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */var CompositionEventInterface=assign({},EventInterface,{data:0});var SyntheticCompositionEvent=createSyntheticEvent(CompositionEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */ // Happens to share the same list for now.
var SyntheticInputEvent=SyntheticCompositionEvent;/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */var normalizeKey={Esc:'Escape',Spacebar:' ',Left:'ArrowLeft',Up:'ArrowUp',Right:'ArrowRight',Down:'ArrowDown',Del:'Delete',Win:'OS',Menu:'ContextMenu',Apps:'ContextMenu',Scroll:'ScrollLock',MozPrintableKey:'Unidentified'};/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */var translateToKey={'8':'Backspace','9':'Tab','12':'Clear','13':'Enter','16':'Shift','17':'Control','18':'Alt','19':'Pause','20':'CapsLock','27':'Escape','32':' ','33':'PageUp','34':'PageDown','35':'End','36':'Home','37':'ArrowLeft','38':'ArrowUp','39':'ArrowRight','40':'ArrowDown','45':'Insert','46':'Delete','112':'F1','113':'F2','114':'F3','115':'F4','116':'F5','117':'F6','118':'F7','119':'F8','120':'F9','121':'F10','122':'F11','123':'F12','144':'NumLock','145':'ScrollLock','224':'Meta'};/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */function getEventKey(nativeEvent){if(nativeEvent.key){// Normalize inconsistent values reported by browsers due to
// implementations of a working draft specification.
// FireFox implements `key` but returns `MozPrintableKey` for all
// printable characters (normalized to `Unidentified`), ignore it.
var key=normalizeKey[nativeEvent.key]||nativeEvent.key;if(key!=='Unidentified'){return key;}}// Browser does not implement `key`, polyfill as much of it as we can.
if(nativeEvent.type==='keypress'){var charCode=getEventCharCode(nativeEvent);// The enter-key is technically both printable and non-printable and can
// thus be captured by `keypress`, no other non-printable key should.
return charCode===13?'Enter':String.fromCharCode(charCode);}if(nativeEvent.type==='keydown'||nativeEvent.type==='keyup'){// While user keyboard layout determines the actual meaning of each
// `keyCode` value, almost all function keys have a universal value.
return translateToKey[nativeEvent.keyCode]||'Unidentified';}return '';}/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */var modifierKeyToProp={Alt:'altKey',Control:'ctrlKey',Meta:'metaKey',Shift:'shiftKey'};// Older browsers (Safari <= 10, iOS Safari <= 10.2) do not support
// getModifierState. If getModifierState is not supported, we map it to a set of
// modifier keys exposed by the event. In this case, Lock-keys are not supported.
function modifierStateGetter(keyArg){var syntheticEvent=this;var nativeEvent=syntheticEvent.nativeEvent;if(nativeEvent.getModifierState){return nativeEvent.getModifierState(keyArg);}var keyProp=modifierKeyToProp[keyArg];return keyProp?!!nativeEvent[keyProp]:false;}function getEventModifierState(nativeEvent){return modifierStateGetter;}/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var KeyboardEventInterface=assign({},UIEventInterface,{key:getEventKey,code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:getEventModifierState,// Legacy Interface
charCode:function(event){// `charCode` is the result of a KeyPress event and represents the value of
// the actual printable character.
// KeyPress is deprecated, but its replacement is not yet final and not
// implemented in any major browser. Only KeyPress has charCode.
if(event.type==='keypress'){return getEventCharCode(event);}return 0;},keyCode:function(event){// `keyCode` is the result of a KeyDown/Up event and represents the value of
// physical keyboard key.
// The actual meaning of the value depends on the users' keyboard layout
// which cannot be detected. Assuming that it is a US keyboard layout
// provides a surprisingly accurate mapping for US and European users.
// Due to this, it is left to the user to implement at this time.
if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;},which:function(event){// `which` is an alias for either `keyCode` or `charCode` depending on the
// type of the event.
if(event.type==='keypress'){return getEventCharCode(event);}if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;}});var SyntheticKeyboardEvent=createSyntheticEvent(KeyboardEventInterface);/**
 * @interface PointerEvent
 * @see http://www.w3.org/TR/pointerevents/
 */var PointerEventInterface=assign({},MouseEventInterface,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0});var SyntheticPointerEvent=createSyntheticEvent(PointerEventInterface);/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */var TouchEventInterface=assign({},UIEventInterface,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:getEventModifierState});var SyntheticTouchEvent=createSyntheticEvent(TouchEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */var TransitionEventInterface=assign({},EventInterface,{propertyName:0,elapsedTime:0,pseudoElement:0});var SyntheticTransitionEvent=createSyntheticEvent(TransitionEventInterface);/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var WheelEventInterface=assign({},MouseEventInterface,{deltaX:function(event){return 'deltaX'in event?event.deltaX:// Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
'wheelDeltaX'in event?-event.wheelDeltaX:0;},deltaY:function(event){return 'deltaY'in event?event.deltaY:// Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
'wheelDeltaY'in event?-event.wheelDeltaY:// Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
'wheelDelta'in event?-event.wheelDelta:0;},deltaZ:0,// Browsers without "deltaMode" is reporting in raw wheel delta where one
// notch on the scroll is always +/- 120, roughly equivalent to pixels.
// A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
// ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
deltaMode:0});var SyntheticWheelEvent=createSyntheticEvent(WheelEventInterface);var END_KEYCODES=[9,13,27,32];// Tab, Return, Esc, Space
var START_KEYCODE=229;var canUseCompositionEvent=canUseDOM&&'CompositionEvent'in window;var documentMode=null;if(canUseDOM&&'documentMode'in document){documentMode=document.documentMode;}// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent=canUseDOM&&'TextEvent'in window&&!documentMode;// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData=canUseDOM&&(!canUseCompositionEvent||documentMode&&documentMode>8&&documentMode<=11);var SPACEBAR_CODE=32;var SPACEBAR_CHAR=String.fromCharCode(SPACEBAR_CODE);function registerEvents(){registerTwoPhaseEvent('onBeforeInput',['compositionend','keypress','textInput','paste']);registerTwoPhaseEvent('onCompositionEnd',['compositionend','focusout','keydown','keypress','keyup','mousedown']);registerTwoPhaseEvent('onCompositionStart',['compositionstart','focusout','keydown','keypress','keyup','mousedown']);registerTwoPhaseEvent('onCompositionUpdate',['compositionupdate','focusout','keydown','keypress','keyup','mousedown']);}// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress=false;/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */function isKeypressCommand(nativeEvent){return (nativeEvent.ctrlKey||nativeEvent.altKey||nativeEvent.metaKey)&&// ctrlKey && altKey is equivalent to AltGr, and is not a command.
!(nativeEvent.ctrlKey&&nativeEvent.altKey);}/**
 * Translate native top level events into event types.
 */function getCompositionEventType(domEventName){switch(domEventName){case'compositionstart':return 'onCompositionStart';case'compositionend':return 'onCompositionEnd';case'compositionupdate':return 'onCompositionUpdate';}}/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 */function isFallbackCompositionStart(domEventName,nativeEvent){return domEventName==='keydown'&&nativeEvent.keyCode===START_KEYCODE;}/**
 * Does our fallback mode think that this event is the end of composition?
 */function isFallbackCompositionEnd(domEventName,nativeEvent){switch(domEventName){case'keyup':// Command keys insert or clear IME input.
return END_KEYCODES.indexOf(nativeEvent.keyCode)!==-1;case'keydown':// Expect IME keyCode on each keydown. If we get any other
// code we must have exited earlier.
return nativeEvent.keyCode!==START_KEYCODE;case'keypress':case'mousedown':case'focusout':// Events are not possible without cancelling IME.
return true;default:return false;}}/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */function getDataFromCustomEvent(nativeEvent){var detail=nativeEvent.detail;if(typeof detail==='object'&&'data'in detail){return detail.data;}return null;}/**
 * Check if a composition event was triggered by Korean IME.
 * Our fallback mode does not work well with IE's Korean IME,
 * so just use native composition events when Korean IME is used.
 * Although CompositionEvent.locale property is deprecated,
 * it is available in IE, where our fallback mode is enabled.
 *
 * @param {object} nativeEvent
 * @return {boolean}
 */function isUsingKoreanIME(nativeEvent){return nativeEvent.locale==='ko';}// Track the current IME composition status, if any.
var isComposing=false;/**
 * @return {?object} A SyntheticCompositionEvent.
 */function extractCompositionEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget){var eventType;var fallbackData;if(canUseCompositionEvent){eventType=getCompositionEventType(domEventName);}else if(!isComposing){if(isFallbackCompositionStart(domEventName,nativeEvent)){eventType='onCompositionStart';}}else if(isFallbackCompositionEnd(domEventName,nativeEvent)){eventType='onCompositionEnd';}if(!eventType){return null;}if(useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)){// The current composition is stored statically and must not be
// overwritten while composition continues.
if(!isComposing&&eventType==='onCompositionStart'){isComposing=initialize(nativeEventTarget);}else if(eventType==='onCompositionEnd'){if(isComposing){fallbackData=getData();}}}var listeners=accumulateTwoPhaseListeners(targetInst,eventType);if(listeners.length>0){var event=new SyntheticCompositionEvent(eventType,domEventName,null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});if(fallbackData){// Inject data generated from fallback path into the synthetic event.
// This matches the property of native CompositionEventInterface.
event.data=fallbackData;}else {var customData=getDataFromCustomEvent(nativeEvent);if(customData!==null){event.data=customData;}}}}function getNativeBeforeInputChars(domEventName,nativeEvent){switch(domEventName){case'compositionend':return getDataFromCustomEvent(nativeEvent);case'keypress':/**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */var which=nativeEvent.which;if(which!==SPACEBAR_CODE){return null;}hasSpaceKeypress=true;return SPACEBAR_CHAR;case'textInput':// Record the characters to be added to the DOM.
var chars=nativeEvent.data;// If it's a spacebar character, assume that we have already handled
// it at the keypress level and bail immediately. Android Chrome
// doesn't give us keycodes, so we need to ignore it.
if(chars===SPACEBAR_CHAR&&hasSpaceKeypress){return null;}return chars;default:// For other native event types, do nothing.
return null;}}/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 */function getFallbackBeforeInputChars(domEventName,nativeEvent){// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if(isComposing){if(domEventName==='compositionend'||!canUseCompositionEvent&&isFallbackCompositionEnd(domEventName,nativeEvent)){var chars=getData();reset();isComposing=false;return chars;}return null;}switch(domEventName){case'paste':// If a paste event occurs after a keypress, throw out the input
// chars. Paste events should not lead to BeforeInput events.
return null;case'keypress':/**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */if(!isKeypressCommand(nativeEvent)){// IE fires the `keypress` event when a user types an emoji via
// Touch keyboard of Windows.  In such a case, the `char` property
// holds an emoji character like `\uD83D\uDE0A`.  Because its length
// is 2, the property `which` does not represent an emoji correctly.
// In such a case, we directly return the `char` property instead of
// using `which`.
if(nativeEvent.char&&nativeEvent.char.length>1){return nativeEvent.char;}else if(nativeEvent.which){return String.fromCharCode(nativeEvent.which);}}return null;case'compositionend':return useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)?null:nativeEvent.data;default:return null;}}/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */function extractBeforeInputEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget){var chars;if(canUseTextInputEvent){chars=getNativeBeforeInputChars(domEventName,nativeEvent);}else {chars=getFallbackBeforeInputChars(domEventName,nativeEvent);}// If no characters are being inserted, no BeforeInput event should
// be fired.
if(!chars){return null;}var listeners=accumulateTwoPhaseListeners(targetInst,'onBeforeInput');if(listeners.length>0){var event=new SyntheticInputEvent('onBeforeInput','beforeinput',null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});event.data=chars;}}/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */function extractEvents(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){extractCompositionEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractBeforeInputEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);}/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */var supportedInputTypes={color:true,date:true,datetime:true,'datetime-local':true,email:true,month:true,number:true,password:true,range:true,search:true,tel:true,text:true,time:true,url:true,week:true};function isTextInputElement(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();if(nodeName==='input'){return !!supportedInputTypes[elem.type];}if(nodeName==='textarea'){return true;}return false;}/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */function isEventSupported(eventNameSuffix){if(!canUseDOM){return false;}var eventName='on'+eventNameSuffix;var isSupported=(eventName in document);if(!isSupported){var element=document.createElement('div');element.setAttribute(eventName,'return;');isSupported=typeof element[eventName]==='function';}return isSupported;}function registerEvents$1(){registerTwoPhaseEvent('onChange',['change','click','focusin','focusout','input','keydown','keyup','selectionchange']);}function createAndAccumulateChangeEvent(dispatchQueue,inst,nativeEvent,target){// Flag this event loop as needing state restore.
enqueueStateRestore(target);var listeners=accumulateTwoPhaseListeners(inst,'onChange');if(listeners.length>0){var event=new SyntheticEvent('onChange','change',null,nativeEvent,target);dispatchQueue.push({event:event,listeners:listeners});}}/**
 * For IE shims
 */var activeElement=null;var activeElementInst=null;/**
 * SECTION: handle `change` event
 */function shouldUseChangeEvent(elem){var nodeName=elem.nodeName&&elem.nodeName.toLowerCase();return nodeName==='select'||nodeName==='input'&&elem.type==='file';}function manualDispatchChangeEvent(nativeEvent){var dispatchQueue=[];createAndAccumulateChangeEvent(dispatchQueue,activeElementInst,nativeEvent,getEventTarget(nativeEvent));// If change and propertychange bubbled, we'd just bind to it like all the
// other events and have it go through ReactBrowserEventEmitter. Since it
// doesn't, we manually listen for the events and so we have to enqueue and
// process the abstract event manually.
//
// Batching is necessary here in order to ensure that all event handlers run
// before the next rerender (including event handlers attached to ancestor
// elements instead of directly on the input). Without this, controlled
// components don't work properly in conjunction with event bubbling because
// the component is rerendered and the value reverted before all the event
// handlers can run. See https://github.com/facebook/react/issues/708.
batchedUpdates(runEventInBatch,dispatchQueue);}function runEventInBatch(dispatchQueue){processDispatchQueue(dispatchQueue,0);}function getInstIfValueChanged(targetInst){var targetNode=getNodeFromInstance(targetInst);if(updateValueIfChanged(targetNode)){return targetInst;}}function getTargetInstForChangeEvent(domEventName,targetInst){if(domEventName==='change'){return targetInst;}}/**
 * SECTION: handle `input` event
 */var isInputEventSupported=false;if(canUseDOM){// IE9 claims to support the input event but fails to trigger it when
// deleting text, so we ignore its input events.
isInputEventSupported=isEventSupported('input')&&(!document.documentMode||document.documentMode>9);}/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */function startWatchingForValueChange(target,targetInst){activeElement=target;activeElementInst=targetInst;activeElement.attachEvent('onpropertychange',handlePropertyChange);}/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */function stopWatchingForValueChange(){if(!activeElement){return;}activeElement.detachEvent('onpropertychange',handlePropertyChange);activeElement=null;activeElementInst=null;}/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */function handlePropertyChange(nativeEvent){if(nativeEvent.propertyName!=='value'){return;}if(getInstIfValueChanged(activeElementInst)){manualDispatchChangeEvent(nativeEvent);}}function handleEventsForInputEventPolyfill(domEventName,target,targetInst){if(domEventName==='focusin'){// In IE9, propertychange fires for most input events but is buggy and
// doesn't fire when text is deleted, but conveniently, selectionchange
// appears to fire in all of the remaining cases so we catch those and
// forward the event if the value has changed
// In either case, we don't want to call the event handler if the value
// is changed from JS so we redefine a setter for `.value` that updates
// our activeElementValue variable, allowing us to ignore those changes
//
// stopWatching() should be a noop here but we call it just in case we
// missed a blur event somehow.
stopWatchingForValueChange();startWatchingForValueChange(target,targetInst);}else if(domEventName==='focusout'){stopWatchingForValueChange();}}// For IE8 and IE9.
function getTargetInstForInputEventPolyfill(domEventName,targetInst){if(domEventName==='selectionchange'||domEventName==='keyup'||domEventName==='keydown'){// On the selectionchange event, the target is just document which isn't
// helpful for us so just check activeElement instead.
//
// 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
// propertychange on the first input event after setting `value` from a
// script and fires only keydown, keypress, keyup. Catching keyup usually
// gets it and catching keydown lets us fire an event for the first
// keystroke if user does a key repeat (it'll be a little delayed: right
// before the second keystroke). Other input methods (e.g., paste) seem to
// fire selectionchange normally.
return getInstIfValueChanged(activeElementInst);}}/**
 * SECTION: handle `click` event
 */function shouldUseClickEvent(elem){// Use the `click` event to detect changes to checkbox and radio inputs.
// This approach works across all browsers, whereas `change` does not fire
// until `blur` in IE8.
var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(elem.type==='checkbox'||elem.type==='radio');}function getTargetInstForClickEvent(domEventName,targetInst){if(domEventName==='click'){return getInstIfValueChanged(targetInst);}}function getTargetInstForInputOrChangeEvent(domEventName,targetInst){if(domEventName==='input'||domEventName==='change'){return getInstIfValueChanged(targetInst);}}function handleControlledInputBlur(node){var state=node._wrapperState;if(!state||!state.controlled||node.type!=='number'){return;}{// If controlled, assign the value attribute to the current value on blur
setDefaultValue(node,'number',node.value);}}/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */function extractEvents$1(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var targetNode=targetInst?getNodeFromInstance(targetInst):window;var getTargetInstFunc,handleEventFunc;if(shouldUseChangeEvent(targetNode)){getTargetInstFunc=getTargetInstForChangeEvent;}else if(isTextInputElement(targetNode)){if(isInputEventSupported){getTargetInstFunc=getTargetInstForInputOrChangeEvent;}else {getTargetInstFunc=getTargetInstForInputEventPolyfill;handleEventFunc=handleEventsForInputEventPolyfill;}}else if(shouldUseClickEvent(targetNode)){getTargetInstFunc=getTargetInstForClickEvent;}if(getTargetInstFunc){var inst=getTargetInstFunc(domEventName,targetInst);if(inst){createAndAccumulateChangeEvent(dispatchQueue,inst,nativeEvent,nativeEventTarget);return;}}if(handleEventFunc){handleEventFunc(domEventName,targetNode,targetInst);}// When blurring, set the value attribute for number inputs
if(domEventName==='focusout'){handleControlledInputBlur(targetNode);}}function registerEvents$2(){registerDirectEvent('onMouseEnter',['mouseout','mouseover']);registerDirectEvent('onMouseLeave',['mouseout','mouseover']);registerDirectEvent('onPointerEnter',['pointerout','pointerover']);registerDirectEvent('onPointerLeave',['pointerout','pointerover']);}/**
 * For almost every interaction we care about, there will be both a top-level
 * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
 * we do not extract duplicate events. However, moving the mouse into the
 * browser from outside will not fire a `mouseout` event. In this case, we use
 * the `mouseover` top-level event.
 */function extractEvents$2(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var isOverEvent=domEventName==='mouseover'||domEventName==='pointerover';var isOutEvent=domEventName==='mouseout'||domEventName==='pointerout';if(isOverEvent&&!isReplayingEvent(nativeEvent)){// If this is an over event with a target, we might have already dispatched
// the event in the out event of the other target. If this is replayed,
// then it's because we couldn't dispatch against this target previously
// so we have to do it now instead.
var related=nativeEvent.relatedTarget||nativeEvent.fromElement;if(related){// If the related node is managed by React, we can assume that we have
// already dispatched the corresponding events during its mouseout.
if(getClosestInstanceFromNode(related)||isContainerMarkedAsRoot(related)){return;}}}if(!isOutEvent&&!isOverEvent){// Must not be a mouse or pointer in or out - ignoring.
return;}var win;// TODO: why is this nullable in the types but we read from it?
if(nativeEventTarget.window===nativeEventTarget){// `nativeEventTarget` is probably a window object.
win=nativeEventTarget;}else {// TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
var doc=nativeEventTarget.ownerDocument;if(doc){win=doc.defaultView||doc.parentWindow;}else {win=window;}}var from;var to;if(isOutEvent){var _related=nativeEvent.relatedTarget||nativeEvent.toElement;from=targetInst;to=_related?getClosestInstanceFromNode(_related):null;if(to!==null){var nearestMounted=getNearestMountedFiber(to);if(to!==nearestMounted||to.tag!==HostComponent&&to.tag!==HostText){to=null;}}}else {// Moving to a node from outside the window.
from=null;to=targetInst;}if(from===to){// Nothing pertains to our managed components.
return;}var SyntheticEventCtor=SyntheticMouseEvent;var leaveEventType='onMouseLeave';var enterEventType='onMouseEnter';var eventTypePrefix='mouse';if(domEventName==='pointerout'||domEventName==='pointerover'){SyntheticEventCtor=SyntheticPointerEvent;leaveEventType='onPointerLeave';enterEventType='onPointerEnter';eventTypePrefix='pointer';}var fromNode=from==null?win:getNodeFromInstance(from);var toNode=to==null?win:getNodeFromInstance(to);var leave=new SyntheticEventCtor(leaveEventType,eventTypePrefix+'leave',from,nativeEvent,nativeEventTarget);leave.target=fromNode;leave.relatedTarget=toNode;var enter=null;// We should only process this nativeEvent if we are processing
// the first ancestor. Next time, we will ignore the event.
var nativeTargetInst=getClosestInstanceFromNode(nativeEventTarget);if(nativeTargetInst===targetInst){var enterEvent=new SyntheticEventCtor(enterEventType,eventTypePrefix+'enter',to,nativeEvent,nativeEventTarget);enterEvent.target=toNode;enterEvent.relatedTarget=fromNode;enter=enterEvent;}accumulateEnterLeaveTwoPhaseListeners(dispatchQueue,leave,enter,from,to);}/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */function is(x,y){return x===y&&(x!==0||1/x===1/y)||x!==x&&y!==y// eslint-disable-line no-self-compare
;}var objectIs=typeof Object.is==='function'?Object.is:is;/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */function shallowEqual(objA,objB){if(objectIs(objA,objB)){return true;}if(typeof objA!=='object'||objA===null||typeof objB!=='object'||objB===null){return false;}var keysA=Object.keys(objA);var keysB=Object.keys(objB);if(keysA.length!==keysB.length){return false;}// Test for A's keys different from B.
for(var i=0;i<keysA.length;i++){var currentKey=keysA[i];if(!hasOwnProperty.call(objB,currentKey)||!objectIs(objA[currentKey],objB[currentKey])){return false;}}return true;}/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */function getLeafNode(node){while(node&&node.firstChild){node=node.firstChild;}return node;}/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */function getSiblingNode(node){while(node){if(node.nextSibling){return node.nextSibling;}node=node.parentNode;}}/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */function getNodeForCharacterOffset(root,offset){var node=getLeafNode(root);var nodeStart=0;var nodeEnd=0;while(node){if(node.nodeType===TEXT_NODE){nodeEnd=nodeStart+node.textContent.length;if(nodeStart<=offset&&nodeEnd>=offset){return {node:node,offset:offset-nodeStart};}nodeStart=nodeEnd;}node=getLeafNode(getSiblingNode(node));}}/**
 * @param {DOMElement} outerNode
 * @return {?object}
 */function getOffsets(outerNode){var ownerDocument=outerNode.ownerDocument;var win=ownerDocument&&ownerDocument.defaultView||window;var selection=win.getSelection&&win.getSelection();if(!selection||selection.rangeCount===0){return null;}var anchorNode=selection.anchorNode,anchorOffset=selection.anchorOffset,focusNode=selection.focusNode,focusOffset=selection.focusOffset;// In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
// up/down buttons on an <input type="number">. Anonymous divs do not seem to
// expose properties, triggering a "Permission denied error" if any of its
// properties are accessed. The only seemingly possible way to avoid erroring
// is to access a property that typically works for non-anonymous divs and
// catch any error that may otherwise arise. See
// https://bugzilla.mozilla.org/show_bug.cgi?id=208427
try{/* eslint-disable no-unused-expressions */anchorNode.nodeType;focusNode.nodeType;/* eslint-enable no-unused-expressions */}catch(e){return null;}return getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset);}/**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */function getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset){var length=0;var start=-1;var end=-1;var indexWithinAnchor=0;var indexWithinFocus=0;var node=outerNode;var parentNode=null;outer:while(true){var next=null;while(true){if(node===anchorNode&&(anchorOffset===0||node.nodeType===TEXT_NODE)){start=length+anchorOffset;}if(node===focusNode&&(focusOffset===0||node.nodeType===TEXT_NODE)){end=length+focusOffset;}if(node.nodeType===TEXT_NODE){length+=node.nodeValue.length;}if((next=node.firstChild)===null){break;}// Moving from `node` to its first child `next`.
parentNode=node;node=next;}while(true){if(node===outerNode){// If `outerNode` has children, this is always the second time visiting
// it. If it has no children, this is still the first loop, and the only
// valid selection is anchorNode and focusNode both equal to this node
// and both offsets 0, in which case we will have handled above.
break outer;}if(parentNode===anchorNode&&++indexWithinAnchor===anchorOffset){start=length;}if(parentNode===focusNode&&++indexWithinFocus===focusOffset){end=length;}if((next=node.nextSibling)!==null){break;}node=parentNode;parentNode=node.parentNode;}// Moving from `node` to its next sibling `next`.
node=next;}if(start===-1||end===-1){// This should never happen. (Would happen if the anchor/focus nodes aren't
// actually inside the passed-in node.)
return null;}return {start:start,end:end};}/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */function setOffsets(node,offsets){var doc=node.ownerDocument||document;var win=doc&&doc.defaultView||window;// Edge fails with "Object expected" in some scenarios.
// (For instance: TinyMCE editor used in a list component that supports pasting to add more,
// fails when pasting 100+ items)
if(!win.getSelection){return;}var selection=win.getSelection();var length=node.textContent.length;var start=Math.min(offsets.start,length);var end=offsets.end===undefined?start:Math.min(offsets.end,length);// IE 11 uses modern selection, but doesn't support the extend method.
// Flip backward selections, so we can set with a single range.
if(!selection.extend&&start>end){var temp=end;end=start;start=temp;}var startMarker=getNodeForCharacterOffset(node,start);var endMarker=getNodeForCharacterOffset(node,end);if(startMarker&&endMarker){if(selection.rangeCount===1&&selection.anchorNode===startMarker.node&&selection.anchorOffset===startMarker.offset&&selection.focusNode===endMarker.node&&selection.focusOffset===endMarker.offset){return;}var range=doc.createRange();range.setStart(startMarker.node,startMarker.offset);selection.removeAllRanges();if(start>end){selection.addRange(range);selection.extend(endMarker.node,endMarker.offset);}else {range.setEnd(endMarker.node,endMarker.offset);selection.addRange(range);}}}function isTextNode(node){return node&&node.nodeType===TEXT_NODE;}function containsNode(outerNode,innerNode){if(!outerNode||!innerNode){return false;}else if(outerNode===innerNode){return true;}else if(isTextNode(outerNode)){return false;}else if(isTextNode(innerNode)){return containsNode(outerNode,innerNode.parentNode);}else if('contains'in outerNode){return outerNode.contains(innerNode);}else if(outerNode.compareDocumentPosition){return !!(outerNode.compareDocumentPosition(innerNode)&16);}else {return false;}}function isInDocument(node){return node&&node.ownerDocument&&containsNode(node.ownerDocument.documentElement,node);}function isSameOriginFrame(iframe){try{// Accessing the contentDocument of a HTMLIframeElement can cause the browser
// to throw, e.g. if it has a cross-origin src attribute.
// Safari will show an error in the console when the access results in "Blocked a frame with origin". e.g:
// iframe.contentDocument.defaultView;
// A safety way is to access one of the cross origin properties: Window or Location
// Which might result in "SecurityError" DOM Exception and it is compatible to Safari.
// https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl
return typeof iframe.contentWindow.location.href==='string';}catch(err){return false;}}function getActiveElementDeep(){var win=window;var element=getActiveElement();while(element instanceof win.HTMLIFrameElement){if(isSameOriginFrame(element)){win=element.contentWindow;}else {return element;}element=getActiveElement(win.document);}return element;}/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */ /**
 * @hasSelectionCapabilities: we get the element types that support selection
 * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`
 * and `selectionEnd` rows.
 */function hasSelectionCapabilities(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();return nodeName&&(nodeName==='input'&&(elem.type==='text'||elem.type==='search'||elem.type==='tel'||elem.type==='url'||elem.type==='password')||nodeName==='textarea'||elem.contentEditable==='true');}function getSelectionInformation(){var focusedElem=getActiveElementDeep();return {focusedElem:focusedElem,selectionRange:hasSelectionCapabilities(focusedElem)?getSelection(focusedElem):null};}/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */function restoreSelection(priorSelectionInformation){var curFocusedElem=getActiveElementDeep();var priorFocusedElem=priorSelectionInformation.focusedElem;var priorSelectionRange=priorSelectionInformation.selectionRange;if(curFocusedElem!==priorFocusedElem&&isInDocument(priorFocusedElem)){if(priorSelectionRange!==null&&hasSelectionCapabilities(priorFocusedElem)){setSelection(priorFocusedElem,priorSelectionRange);}// Focusing a node can change the scroll position, which is undesirable
var ancestors=[];var ancestor=priorFocusedElem;while(ancestor=ancestor.parentNode){if(ancestor.nodeType===ELEMENT_NODE){ancestors.push({element:ancestor,left:ancestor.scrollLeft,top:ancestor.scrollTop});}}if(typeof priorFocusedElem.focus==='function'){priorFocusedElem.focus();}for(var i=0;i<ancestors.length;i++){var info=ancestors[i];info.element.scrollLeft=info.left;info.element.scrollTop=info.top;}}}/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */function getSelection(input){var selection;if('selectionStart'in input){// Modern browser with input or textarea.
selection={start:input.selectionStart,end:input.selectionEnd};}else {// Content editable or old IE textarea.
selection=getOffsets(input);}return selection||{start:0,end:0};}/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */function setSelection(input,offsets){var start=offsets.start;var end=offsets.end;if(end===undefined){end=start;}if('selectionStart'in input){input.selectionStart=start;input.selectionEnd=Math.min(end,input.value.length);}else {setOffsets(input,offsets);}}var skipSelectionChangeEvent=canUseDOM&&'documentMode'in document&&document.documentMode<=11;function registerEvents$3(){registerTwoPhaseEvent('onSelect',['focusout','contextmenu','dragend','focusin','keydown','keyup','mousedown','mouseup','selectionchange']);}var activeElement$1=null;var activeElementInst$1=null;var lastSelection=null;var mouseDown=false;/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 */function getSelection$1(node){if('selectionStart'in node&&hasSelectionCapabilities(node)){return {start:node.selectionStart,end:node.selectionEnd};}else {var win=node.ownerDocument&&node.ownerDocument.defaultView||window;var selection=win.getSelection();return {anchorNode:selection.anchorNode,anchorOffset:selection.anchorOffset,focusNode:selection.focusNode,focusOffset:selection.focusOffset};}}/**
 * Get document associated with the event target.
 */function getEventTargetDocument(eventTarget){return eventTarget.window===eventTarget?eventTarget.document:eventTarget.nodeType===DOCUMENT_NODE?eventTarget:eventTarget.ownerDocument;}/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @param {object} nativeEventTarget
 * @return {?SyntheticEvent}
 */function constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget){// Ensure we have the right element, and that the user is not dragging a
// selection (this matches native `select` event behavior). In HTML5, select
// fires only on input and textarea thus if there's no focused element we
// won't dispatch.
var doc=getEventTargetDocument(nativeEventTarget);if(mouseDown||activeElement$1==null||activeElement$1!==getActiveElement(doc)){return;}// Only fire when selection has actually changed.
var currentSelection=getSelection$1(activeElement$1);if(!lastSelection||!shallowEqual(lastSelection,currentSelection)){lastSelection=currentSelection;var listeners=accumulateTwoPhaseListeners(activeElementInst$1,'onSelect');if(listeners.length>0){var event=new SyntheticEvent('onSelect','select',null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});event.target=activeElement$1;}}}/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */function extractEvents$3(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var targetNode=targetInst?getNodeFromInstance(targetInst):window;switch(domEventName){// Track the input node that has focus.
case'focusin':if(isTextInputElement(targetNode)||targetNode.contentEditable==='true'){activeElement$1=targetNode;activeElementInst$1=targetInst;lastSelection=null;}break;case'focusout':activeElement$1=null;activeElementInst$1=null;lastSelection=null;break;// Don't fire the event while the user is dragging. This matches the
// semantics of the native select event.
case'mousedown':mouseDown=true;break;case'contextmenu':case'mouseup':case'dragend':mouseDown=false;constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget);break;// Chrome and IE fire non-standard event when selection is changed (and
// sometimes when it hasn't). IE's event fires out of order with respect
// to key and input events on deletion, so we discard it.
//
// Firefox doesn't support selectionchange, so check selection status
// after each key entry. The selection changes after keydown and before
// keyup, but we check on keydown as well in the case of holding down a
// key, when multiple keydown events are fired but only one keyup is.
// This is also our approach for IE handling, for the reason above.
case'selectionchange':if(skipSelectionChangeEvent){break;}// falls through
case'keydown':case'keyup':constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget);}}/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */function makePrefixMap(styleProp,eventName){var prefixes={};prefixes[styleProp.toLowerCase()]=eventName.toLowerCase();prefixes['Webkit'+styleProp]='webkit'+eventName;prefixes['Moz'+styleProp]='moz'+eventName;return prefixes;}/**
 * A list of event names to a configurable list of vendor prefixes.
 */var vendorPrefixes={animationend:makePrefixMap('Animation','AnimationEnd'),animationiteration:makePrefixMap('Animation','AnimationIteration'),animationstart:makePrefixMap('Animation','AnimationStart'),transitionend:makePrefixMap('Transition','TransitionEnd')};/**
 * Event names that have already been detected and prefixed (if applicable).
 */var prefixedEventNames={};/**
 * Element to check for prefixes on.
 */var style={};/**
 * Bootstrap if a DOM exists.
 */if(canUseDOM){style=document.createElement('div').style;// On some platforms, in particular some releases of Android 4.x,
// the un-prefixed "animation" and "transition" properties are defined on the
// style object but the events that fire will still be prefixed, so we need
// to check if the un-prefixed events are usable, and if not remove them from the map.
if(!('AnimationEvent'in window)){delete vendorPrefixes.animationend.animation;delete vendorPrefixes.animationiteration.animation;delete vendorPrefixes.animationstart.animation;}// Same as above
if(!('TransitionEvent'in window)){delete vendorPrefixes.transitionend.transition;}}/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */function getVendorPrefixedEventName(eventName){if(prefixedEventNames[eventName]){return prefixedEventNames[eventName];}else if(!vendorPrefixes[eventName]){return eventName;}var prefixMap=vendorPrefixes[eventName];for(var styleProp in prefixMap){if(prefixMap.hasOwnProperty(styleProp)&&styleProp in style){return prefixedEventNames[eventName]=prefixMap[styleProp];}}return eventName;}var ANIMATION_END=getVendorPrefixedEventName('animationend');var ANIMATION_ITERATION=getVendorPrefixedEventName('animationiteration');var ANIMATION_START=getVendorPrefixedEventName('animationstart');var TRANSITION_END=getVendorPrefixedEventName('transitionend');var topLevelEventsToReactNames=new Map();// NOTE: Capitalization is important in this list!
//
// E.g. it needs "pointerDown", not "pointerdown".
// This is because we derive both React name ("onPointerDown")
// and DOM name ("pointerdown") from the same list.
//
// Exceptions that don't match this convention are listed separately.
//
// prettier-ignore
var simpleEventPluginEvents=['abort','auxClick','cancel','canPlay','canPlayThrough','click','close','contextMenu','copy','cut','drag','dragEnd','dragEnter','dragExit','dragLeave','dragOver','dragStart','drop','durationChange','emptied','encrypted','ended','error','gotPointerCapture','input','invalid','keyDown','keyPress','keyUp','load','loadedData','loadedMetadata','loadStart','lostPointerCapture','mouseDown','mouseMove','mouseOut','mouseOver','mouseUp','paste','pause','play','playing','pointerCancel','pointerDown','pointerMove','pointerOut','pointerOver','pointerUp','progress','rateChange','reset','resize','seeked','seeking','stalled','submit','suspend','timeUpdate','touchCancel','touchEnd','touchStart','volumeChange','scroll','toggle','touchMove','waiting','wheel'];function registerSimpleEvent(domEventName,reactName){topLevelEventsToReactNames.set(domEventName,reactName);registerTwoPhaseEvent(reactName,[domEventName]);}function registerSimpleEvents(){for(var i=0;i<simpleEventPluginEvents.length;i++){var eventName=simpleEventPluginEvents[i];var domEventName=eventName.toLowerCase();var capitalizedEvent=eventName[0].toUpperCase()+eventName.slice(1);registerSimpleEvent(domEventName,'on'+capitalizedEvent);}// Special cases where event names don't match.
registerSimpleEvent(ANIMATION_END,'onAnimationEnd');registerSimpleEvent(ANIMATION_ITERATION,'onAnimationIteration');registerSimpleEvent(ANIMATION_START,'onAnimationStart');registerSimpleEvent('dblclick','onDoubleClick');registerSimpleEvent('focusin','onFocus');registerSimpleEvent('focusout','onBlur');registerSimpleEvent(TRANSITION_END,'onTransitionEnd');}function extractEvents$4(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var reactName=topLevelEventsToReactNames.get(domEventName);if(reactName===undefined){return;}var SyntheticEventCtor=SyntheticEvent;var reactEventType=domEventName;switch(domEventName){case'keypress':// Firefox creates a keypress event for function keys too. This removes
// the unwanted keypress events. Enter is however both printable and
// non-printable. One would expect Tab to be as well (but it isn't).
if(getEventCharCode(nativeEvent)===0){return;}/* falls through */case'keydown':case'keyup':SyntheticEventCtor=SyntheticKeyboardEvent;break;case'focusin':reactEventType='focus';SyntheticEventCtor=SyntheticFocusEvent;break;case'focusout':reactEventType='blur';SyntheticEventCtor=SyntheticFocusEvent;break;case'beforeblur':case'afterblur':SyntheticEventCtor=SyntheticFocusEvent;break;case'click':// Firefox creates a click event on right mouse clicks. This removes the
// unwanted click events.
if(nativeEvent.button===2){return;}/* falls through */case'auxclick':case'dblclick':case'mousedown':case'mousemove':case'mouseup':// TODO: Disabled elements should not respond to mouse events
/* falls through */case'mouseout':case'mouseover':case'contextmenu':SyntheticEventCtor=SyntheticMouseEvent;break;case'drag':case'dragend':case'dragenter':case'dragexit':case'dragleave':case'dragover':case'dragstart':case'drop':SyntheticEventCtor=SyntheticDragEvent;break;case'touchcancel':case'touchend':case'touchmove':case'touchstart':SyntheticEventCtor=SyntheticTouchEvent;break;case ANIMATION_END:case ANIMATION_ITERATION:case ANIMATION_START:SyntheticEventCtor=SyntheticAnimationEvent;break;case TRANSITION_END:SyntheticEventCtor=SyntheticTransitionEvent;break;case'scroll':SyntheticEventCtor=SyntheticUIEvent;break;case'wheel':SyntheticEventCtor=SyntheticWheelEvent;break;case'copy':case'cut':case'paste':SyntheticEventCtor=SyntheticClipboardEvent;break;case'gotpointercapture':case'lostpointercapture':case'pointercancel':case'pointerdown':case'pointermove':case'pointerout':case'pointerover':case'pointerup':SyntheticEventCtor=SyntheticPointerEvent;break;}var inCapturePhase=(eventSystemFlags&IS_CAPTURE_PHASE)!==0;{// Some events don't bubble in the browser.
// In the past, React has always bubbled them, but this can be surprising.
// We're going to try aligning closer to the browser behavior by not bubbling
// them in React either. We'll start by not bubbling onScroll, and then expand.
var accumulateTargetOnly=!inCapturePhase&&// TODO: ideally, we'd eventually add all events from
// nonDelegatedEvents list in DOMPluginEventSystem.
// Then we can remove this special list.
// This is a breaking change that can wait until React 18.
domEventName==='scroll';var _listeners=accumulateSinglePhaseListeners(targetInst,reactName,nativeEvent.type,inCapturePhase,accumulateTargetOnly);if(_listeners.length>0){// Intentionally create event lazily.
var _event=new SyntheticEventCtor(reactName,reactEventType,null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:_event,listeners:_listeners});}}}// TODO: remove top-level side effect.
registerSimpleEvents();registerEvents$2();registerEvents$1();registerEvents$3();registerEvents();function extractEvents$5(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){// TODO: we should remove the concept of a "SimpleEventPlugin".
// This is the basic functionality of the event system. All
// the other plugins are essentially polyfills. So the plugin
// should probably be inlined somewhere and have its logic
// be core the to event system. This would potentially allow
// us to ship builds of React without the polyfilled plugins below.
extractEvents$4(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags);var shouldProcessPolyfillPlugins=(eventSystemFlags&SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS)===0;// We don't process these events unless we are in the
// event's native "bubble" phase, which means that we're
// not in the capture phase. That's because we emulate
// the capture phase here still. This is a trade-off,
// because in an ideal world we would not emulate and use
// the phases properly, like we do with the SimpleEvent
// plugin. However, the plugins below either expect
// emulation (EnterLeave) or use state localized to that
// plugin (BeforeInput, Change, Select). The state in
// these modules complicates things, as you'll essentially
// get the case where the capture phase event might change
// state, only for the following bubble event to come in
// later and not trigger anything as the state now
// invalidates the heuristics of the event plugin. We
// could alter all these plugins to work in such ways, but
// that might cause other unknown side-effects that we
// can't foresee right now.
if(shouldProcessPolyfillPlugins){extractEvents$2(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents$1(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents$3(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);}}// List of events that need to be individually attached to media elements.
var mediaEventTypes=['abort','canplay','canplaythrough','durationchange','emptied','encrypted','ended','error','loadeddata','loadedmetadata','loadstart','pause','play','playing','progress','ratechange','resize','seeked','seeking','stalled','suspend','timeupdate','volumechange','waiting'];// We should not delegate these events to the container, but rather
// set them on the actual target element itself. This is primarily
// because these events do not consistently bubble in the DOM.
var nonDelegatedEvents=new Set(['cancel','close','invalid','load','scroll','toggle'].concat(mediaEventTypes));function executeDispatch(event,listener,currentTarget){var type=event.type||'unknown-event';event.currentTarget=currentTarget;invokeGuardedCallbackAndCatchFirstError(type,listener,undefined,event);event.currentTarget=null;}function processDispatchQueueItemsInOrder(event,dispatchListeners,inCapturePhase){var previousInstance;if(inCapturePhase){for(var i=dispatchListeners.length-1;i>=0;i--){var _dispatchListeners$i=dispatchListeners[i],instance=_dispatchListeners$i.instance,currentTarget=_dispatchListeners$i.currentTarget,listener=_dispatchListeners$i.listener;if(instance!==previousInstance&&event.isPropagationStopped()){return;}executeDispatch(event,listener,currentTarget);previousInstance=instance;}}else {for(var _i=0;_i<dispatchListeners.length;_i++){var _dispatchListeners$_i=dispatchListeners[_i],_instance=_dispatchListeners$_i.instance,_currentTarget=_dispatchListeners$_i.currentTarget,_listener=_dispatchListeners$_i.listener;if(_instance!==previousInstance&&event.isPropagationStopped()){return;}executeDispatch(event,_listener,_currentTarget);previousInstance=_instance;}}}function processDispatchQueue(dispatchQueue,eventSystemFlags){var inCapturePhase=(eventSystemFlags&IS_CAPTURE_PHASE)!==0;for(var i=0;i<dispatchQueue.length;i++){var _dispatchQueue$i=dispatchQueue[i],event=_dispatchQueue$i.event,listeners=_dispatchQueue$i.listeners;processDispatchQueueItemsInOrder(event,listeners,inCapturePhase);//  event system doesn't use pooling.
}// This would be a good time to rethrow if any of the event handlers threw.
rethrowCaughtError();}function dispatchEventsForPlugins(domEventName,eventSystemFlags,nativeEvent,targetInst,targetContainer){var nativeEventTarget=getEventTarget(nativeEvent);var dispatchQueue=[];extractEvents$5(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags);processDispatchQueue(dispatchQueue,eventSystemFlags);}function listenToNonDelegatedEvent(domEventName,targetElement){{if(!nonDelegatedEvents.has(domEventName)){error('Did not expect a listenToNonDelegatedEvent() call for "%s". '+'This is a bug in React. Please file an issue.',domEventName);}}var isCapturePhaseListener=false;var listenerSet=getEventListenerSet(targetElement);var listenerSetKey=getListenerSetKey(domEventName,isCapturePhaseListener);if(!listenerSet.has(listenerSetKey)){addTrappedEventListener(targetElement,domEventName,IS_NON_DELEGATED,isCapturePhaseListener);listenerSet.add(listenerSetKey);}}function listenToNativeEvent(domEventName,isCapturePhaseListener,target){{if(nonDelegatedEvents.has(domEventName)&&!isCapturePhaseListener){error('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. '+'This is a bug in React. Please file an issue.',domEventName);}}var eventSystemFlags=0;if(isCapturePhaseListener){eventSystemFlags|=IS_CAPTURE_PHASE;}addTrappedEventListener(target,domEventName,eventSystemFlags,isCapturePhaseListener);}// This is only used by createEventHandle when the
var listeningMarker='_reactListening'+Math.random().toString(36).slice(2);function listenToAllSupportedEvents(rootContainerElement){if(!rootContainerElement[listeningMarker]){rootContainerElement[listeningMarker]=true;allNativeEvents.forEach(function(domEventName){// We handle selectionchange separately because it
// doesn't bubble and needs to be on the document.
if(domEventName!=='selectionchange'){if(!nonDelegatedEvents.has(domEventName)){listenToNativeEvent(domEventName,false,rootContainerElement);}listenToNativeEvent(domEventName,true,rootContainerElement);}});var ownerDocument=rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;if(ownerDocument!==null){// The selectionchange event also needs deduplication
// but it is attached to the document.
if(!ownerDocument[listeningMarker]){ownerDocument[listeningMarker]=true;listenToNativeEvent('selectionchange',false,ownerDocument);}}}}function addTrappedEventListener(targetContainer,domEventName,eventSystemFlags,isCapturePhaseListener,isDeferredListenerForLegacyFBSupport){var listener=createEventListenerWrapperWithPriority(targetContainer,domEventName,eventSystemFlags);// If passive option is not supported, then the event will be
// active and not passive.
var isPassiveListener=undefined;if(passiveBrowserEventsSupported){// Browsers introduced an intervention, making these events
// passive by default on document. React doesn't bind them
// to document anymore, but changing this now would undo
// the performance wins from the change. So we emulate
// the existing behavior manually on the roots now.
// https://github.com/facebook/react/issues/19651
if(domEventName==='touchstart'||domEventName==='touchmove'||domEventName==='wheel'){isPassiveListener=true;}}targetContainer=targetContainer;if(isCapturePhaseListener){if(isPassiveListener!==undefined){addEventCaptureListenerWithPassiveFlag(targetContainer,domEventName,listener,isPassiveListener);}else {addEventCaptureListener(targetContainer,domEventName,listener);}}else {if(isPassiveListener!==undefined){addEventBubbleListenerWithPassiveFlag(targetContainer,domEventName,listener,isPassiveListener);}else {addEventBubbleListener(targetContainer,domEventName,listener);}}}function isMatchingRootContainer(grandContainer,targetContainer){return grandContainer===targetContainer||grandContainer.nodeType===COMMENT_NODE&&grandContainer.parentNode===targetContainer;}function dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,targetInst,targetContainer){var ancestorInst=targetInst;if((eventSystemFlags&IS_EVENT_HANDLE_NON_MANAGED_NODE)===0&&(eventSystemFlags&IS_NON_DELEGATED)===0){var targetContainerNode=targetContainer;// If we are using the legacy FB support flag, we
if(targetInst!==null){// The below logic attempts to work out if we need to change
// the target fiber to a different ancestor. We had similar logic
// in the legacy event system, except the big difference between
// systems is that the modern event system now has an event listener
// attached to each React Root and React Portal Root. Together,
// the DOM nodes representing these roots are the "rootContainer".
// To figure out which ancestor instance we should use, we traverse
// up the fiber tree from the target instance and attempt to find
// root boundaries that match that of our current "rootContainer".
// If we find that "rootContainer", we find the parent fiber
// sub-tree for that root and make that our ancestor instance.
var node=targetInst;mainLoop:while(true){if(node===null){return;}var nodeTag=node.tag;if(nodeTag===HostRoot||nodeTag===HostPortal){var container=node.stateNode.containerInfo;if(isMatchingRootContainer(container,targetContainerNode)){break;}if(nodeTag===HostPortal){// The target is a portal, but it's not the rootContainer we're looking for.
// Normally portals handle their own events all the way down to the root.
// So we should be able to stop now. However, we don't know if this portal
// was part of *our* root.
var grandNode=node.return;while(grandNode!==null){var grandTag=grandNode.tag;if(grandTag===HostRoot||grandTag===HostPortal){var grandContainer=grandNode.stateNode.containerInfo;if(isMatchingRootContainer(grandContainer,targetContainerNode)){// This is the rootContainer we're looking for and we found it as
// a parent of the Portal. That means we can ignore it because the
// Portal will bubble through to us.
return;}}grandNode=grandNode.return;}}// Now we need to find it's corresponding host fiber in the other
// tree. To do this we can use getClosestInstanceFromNode, but we
// need to validate that the fiber is a host instance, otherwise
// we need to traverse up through the DOM till we find the correct
// node that is from the other tree.
while(container!==null){var parentNode=getClosestInstanceFromNode(container);if(parentNode===null){return;}var parentTag=parentNode.tag;if(parentTag===HostComponent||parentTag===HostText){node=ancestorInst=parentNode;continue mainLoop;}container=container.parentNode;}}node=node.return;}}}batchedUpdates(function(){return dispatchEventsForPlugins(domEventName,eventSystemFlags,nativeEvent,ancestorInst);});}function createDispatchListener(instance,listener,currentTarget){return {instance:instance,listener:listener,currentTarget:currentTarget};}function accumulateSinglePhaseListeners(targetFiber,reactName,nativeEventType,inCapturePhase,accumulateTargetOnly,nativeEvent){var captureName=reactName!==null?reactName+'Capture':null;var reactEventName=inCapturePhase?captureName:reactName;var listeners=[];var instance=targetFiber;var lastHostComponent=null;// Accumulate all instances and listeners via the target -> root path.
while(instance!==null){var _instance2=instance,stateNode=_instance2.stateNode,tag=_instance2.tag;// Handle listeners that are on HostComponents (i.e. <div>)
if(tag===HostComponent&&stateNode!==null){lastHostComponent=stateNode;// createEventHandle listeners
if(reactEventName!==null){var listener=getListener(instance,reactEventName);if(listener!=null){listeners.push(createDispatchListener(instance,listener,lastHostComponent));}}}// If we are only accumulating events for the target, then we don't
// continue to propagate through the React fiber tree to find other
// listeners.
if(accumulateTargetOnly){break;}// If we are processing the onBeforeBlur event, then we need to take
instance=instance.return;}return listeners;}// We should only use this function for:
// - BeforeInputEventPlugin
// - ChangeEventPlugin
// - SelectEventPlugin
// This is because we only process these plugins
// in the bubble phase, so we need to accumulate two
// phase event listeners (via emulation).
function accumulateTwoPhaseListeners(targetFiber,reactName){var captureName=reactName+'Capture';var listeners=[];var instance=targetFiber;// Accumulate all instances and listeners via the target -> root path.
while(instance!==null){var _instance3=instance,stateNode=_instance3.stateNode,tag=_instance3.tag;// Handle listeners that are on HostComponents (i.e. <div>)
if(tag===HostComponent&&stateNode!==null){var currentTarget=stateNode;var captureListener=getListener(instance,captureName);if(captureListener!=null){listeners.unshift(createDispatchListener(instance,captureListener,currentTarget));}var bubbleListener=getListener(instance,reactName);if(bubbleListener!=null){listeners.push(createDispatchListener(instance,bubbleListener,currentTarget));}}instance=instance.return;}return listeners;}function getParent(inst){if(inst===null){return null;}do{inst=inst.return;// TODO: If this is a HostRoot we might want to bail out.
// That is depending on if we want nested subtrees (layers) to bubble
// events to their parent. We could also go through parentNode on the
// host node but that wouldn't work for React Native and doesn't let us
// do the portal feature.
}while(inst&&inst.tag!==HostComponent);if(inst){return inst;}return null;}/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */function getLowestCommonAncestor(instA,instB){var nodeA=instA;var nodeB=instB;var depthA=0;for(var tempA=nodeA;tempA;tempA=getParent(tempA)){depthA++;}var depthB=0;for(var tempB=nodeB;tempB;tempB=getParent(tempB)){depthB++;}// If A is deeper, crawl up.
while(depthA-depthB>0){nodeA=getParent(nodeA);depthA--;}// If B is deeper, crawl up.
while(depthB-depthA>0){nodeB=getParent(nodeB);depthB--;}// Walk in lockstep until we find a match.
var depth=depthA;while(depth--){if(nodeA===nodeB||nodeB!==null&&nodeA===nodeB.alternate){return nodeA;}nodeA=getParent(nodeA);nodeB=getParent(nodeB);}return null;}function accumulateEnterLeaveListenersForEvent(dispatchQueue,event,target,common,inCapturePhase){var registrationName=event._reactName;var listeners=[];var instance=target;while(instance!==null){if(instance===common){break;}var _instance4=instance,alternate=_instance4.alternate,stateNode=_instance4.stateNode,tag=_instance4.tag;if(alternate!==null&&alternate===common){break;}if(tag===HostComponent&&stateNode!==null){var currentTarget=stateNode;if(inCapturePhase){var captureListener=getListener(instance,registrationName);if(captureListener!=null){listeners.unshift(createDispatchListener(instance,captureListener,currentTarget));}}else if(!inCapturePhase){var bubbleListener=getListener(instance,registrationName);if(bubbleListener!=null){listeners.push(createDispatchListener(instance,bubbleListener,currentTarget));}}}instance=instance.return;}if(listeners.length!==0){dispatchQueue.push({event:event,listeners:listeners});}}// We should only use this function for:
// - EnterLeaveEventPlugin
// This is because we only process this plugin
// in the bubble phase, so we need to accumulate two
// phase event listeners.
function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue,leaveEvent,enterEvent,from,to){var common=from&&to?getLowestCommonAncestor(from,to):null;if(from!==null){accumulateEnterLeaveListenersForEvent(dispatchQueue,leaveEvent,from,common,false);}if(to!==null&&enterEvent!==null){accumulateEnterLeaveListenersForEvent(dispatchQueue,enterEvent,to,common,true);}}function getListenerSetKey(domEventName,capture){return domEventName+"__"+(capture?'capture':'bubble');}var didWarnInvalidHydration=false;var DANGEROUSLY_SET_INNER_HTML='dangerouslySetInnerHTML';var SUPPRESS_CONTENT_EDITABLE_WARNING='suppressContentEditableWarning';var SUPPRESS_HYDRATION_WARNING='suppressHydrationWarning';var AUTOFOCUS='autoFocus';var CHILDREN='children';var STYLE='style';var HTML$1='__html';var warnedUnknownTags;var validatePropertiesInDevelopment;var warnForPropDifference;var warnForExtraAttributes;var warnForInvalidEventListener;var canDiffStyleForHydrationWarning;var normalizeHTML;{warnedUnknownTags={// There are working polyfills for <dialog>. Let people use it.
dialog:true,// Electron ships a custom <webview> tag to display external web content in
// an isolated frame and process.
// This tag is not present in non Electron environments such as JSDom which
// is often used for testing purposes.
// @see https://electronjs.org/docs/api/webview-tag
webview:true};validatePropertiesInDevelopment=function(type,props){validateProperties(type,props);validateProperties$1(type,props);validateProperties$2(type,props,{registrationNameDependencies:registrationNameDependencies,possibleRegistrationNames:possibleRegistrationNames});};// IE 11 parses & normalizes the style attribute as opposed to other
// browsers. It adds spaces and sorts the properties in some
// non-alphabetical order. Handling that would require sorting CSS
// properties in the client & server versions or applying
// `expectedStyle` to a temporary DOM node to read its `style` attribute
// normalized. Since it only affects IE, we're skipping style warnings
// in that browser completely in favor of doing all that work.
// See https://github.com/facebook/react/issues/11807
canDiffStyleForHydrationWarning=canUseDOM&&!document.documentMode;warnForPropDifference=function(propName,serverValue,clientValue){if(didWarnInvalidHydration){return;}var normalizedClientValue=normalizeMarkupForTextOrAttribute(clientValue);var normalizedServerValue=normalizeMarkupForTextOrAttribute(serverValue);if(normalizedServerValue===normalizedClientValue){return;}didWarnInvalidHydration=true;error('Prop `%s` did not match. Server: %s Client: %s',propName,JSON.stringify(normalizedServerValue),JSON.stringify(normalizedClientValue));};warnForExtraAttributes=function(attributeNames){if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;var names=[];attributeNames.forEach(function(name){names.push(name);});error('Extra attributes from the server: %s',names);};warnForInvalidEventListener=function(registrationName,listener){if(listener===false){error('Expected `%s` listener to be a function, instead got `false`.\n\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',registrationName,registrationName,registrationName);}else {error('Expected `%s` listener to be a function, instead got a value of `%s` type.',registrationName,typeof listener);}};// Parse the HTML and read it back to normalize the HTML string so that it
// can be used for comparison.
normalizeHTML=function(parent,html){// We could have created a separate document here to avoid
// re-initializing custom elements if they exist. But this breaks
// how <noscript> is being handled. So we use the same document.
// See the discussion in https://github.com/facebook/react/pull/11157.
var testElement=parent.namespaceURI===HTML_NAMESPACE?parent.ownerDocument.createElement(parent.tagName):parent.ownerDocument.createElementNS(parent.namespaceURI,parent.tagName);testElement.innerHTML=html;return testElement.innerHTML;};}// HTML parsing normalizes CR and CRLF to LF.
// It also can turn \u0000 into \uFFFD inside attributes.
// https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
// If we have a mismatch, it might be caused by that.
// We will still patch up in this case but not fire the warning.
var NORMALIZE_NEWLINES_REGEX=/\r\n?/g;var NORMALIZE_NULL_AND_REPLACEMENT_REGEX=/\u0000|\uFFFD/g;function normalizeMarkupForTextOrAttribute(markup){{checkHtmlStringCoercion(markup);}var markupString=typeof markup==='string'?markup:''+markup;return markupString.replace(NORMALIZE_NEWLINES_REGEX,'\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX,'');}function checkForUnmatchedText(serverText,clientText,isConcurrentMode,shouldWarnDev){var normalizedClientText=normalizeMarkupForTextOrAttribute(clientText);var normalizedServerText=normalizeMarkupForTextOrAttribute(serverText);if(normalizedServerText===normalizedClientText){return;}if(shouldWarnDev){{if(!didWarnInvalidHydration){didWarnInvalidHydration=true;error('Text content did not match. Server: "%s" Client: "%s"',normalizedServerText,normalizedClientText);}}}if(isConcurrentMode&&enableClientRenderFallbackOnTextMismatch){// In concurrent roots, we throw when there's a text mismatch and revert to
// client rendering, up to the nearest Suspense boundary.
throw new Error('Text content does not match server-rendered HTML.');}}function getOwnerDocumentFromRootContainer(rootContainerElement){return rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;}function noop(){}function trapClickOnNonInteractiveElement(node){// Mobile Safari does not fire properly bubble click events on
// non-interactive elements, which means delegated click listeners do not
// fire. The workaround for this bug involves attaching an empty click
// listener on the target node.
// https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
// Just set it using the onclick property so that we don't have to manage any
// bookkeeping for it. Not sure if we need to clear it when the listener is
// removed.
// TODO: Only do this for the relevant Safaris maybe?
node.onclick=noop;}function setInitialDOMProperties(tag,domElement,rootContainerElement,nextProps,isCustomComponentTag){for(var propKey in nextProps){if(!nextProps.hasOwnProperty(propKey)){continue;}var nextProp=nextProps[propKey];if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be
// mutated. We have already warned for this in the past.
Object.freeze(nextProp);}}// Relies on `updateStylesByID` not mutating `styleUpdates`.
setValueForStyles(domElement,nextProp);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML$1]:undefined;if(nextHtml!=null){setInnerHTML(domElement,nextHtml);}}else if(propKey===CHILDREN){if(typeof nextProp==='string'){// Avoid setting initial textContent when the text is empty. In IE11 setting
// textContent on a <textarea> will cause the placeholder to not
// show within the <textarea> until it has been focused and blurred again.
// https://github.com/facebook/react/issues/6731#issuecomment-254874553
var canSetTextContent=tag!=='textarea'||nextProp!=='';if(canSetTextContent){setTextContent(domElement,nextProp);}}else if(typeof nextProp==='number'){setTextContent(domElement,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(propKey===AUTOFOCUS);else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}}else if(nextProp!=null){setValueForProperty(domElement,propKey,nextProp,isCustomComponentTag);}}}function updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag){// TODO: Handle wasCustomComponentTag
for(var i=0;i<updatePayload.length;i+=2){var propKey=updatePayload[i];var propValue=updatePayload[i+1];if(propKey===STYLE){setValueForStyles(domElement,propValue);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){setInnerHTML(domElement,propValue);}else if(propKey===CHILDREN){setTextContent(domElement,propValue);}else {setValueForProperty(domElement,propKey,propValue,isCustomComponentTag);}}}function createElement(type,props,rootContainerElement,parentNamespace){var isCustomComponentTag;// We create tags in the namespace of their parent container, except HTML
// tags get no namespace.
var ownerDocument=getOwnerDocumentFromRootContainer(rootContainerElement);var domElement;var namespaceURI=parentNamespace;if(namespaceURI===HTML_NAMESPACE){namespaceURI=getIntrinsicNamespace(type);}if(namespaceURI===HTML_NAMESPACE){{isCustomComponentTag=isCustomComponent(type,props);// Should this check be gated by parent namespace? Not sure we want to
// allow <SVG> or <mATH>.
if(!isCustomComponentTag&&type!==type.toLowerCase()){error('<%s /> is using incorrect casing. '+'Use PascalCase for React components, '+'or lowercase for HTML elements.',type);}}if(type==='script'){// Create the script via .innerHTML so its "parser-inserted" flag is
// set to true and it does not execute
var div=ownerDocument.createElement('div');div.innerHTML='<script><'+'/script>';// eslint-disable-line
// This is guaranteed to yield a script element.
var firstChild=div.firstChild;domElement=div.removeChild(firstChild);}else if(typeof props.is==='string'){// $FlowIssue `createElement` should be updated for Web Components
domElement=ownerDocument.createElement(type,{is:props.is});}else {// Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
// See discussion in https://github.com/facebook/react/pull/6896
// and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
domElement=ownerDocument.createElement(type);// Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple` and `size`
// attributes on `select`s needs to be added before `option`s are inserted.
// This prevents:
// - a bug where the `select` does not scroll to the correct option because singular
//  `select` elements automatically pick the first item #13222
// - a bug where the `select` set the first item as selected despite the `size` attribute #14239
// See https://github.com/facebook/react/issues/13222
// and https://github.com/facebook/react/issues/14239
if(type==='select'){var node=domElement;if(props.multiple){node.multiple=true;}else if(props.size){// Setting a size greater than 1 causes a select to behave like `multiple=true`, where
// it is possible that no option is selected.
//
// This is only necessary when a select in "single selection mode".
node.size=props.size;}}}}else {domElement=ownerDocument.createElementNS(namespaceURI,type);}{if(namespaceURI===HTML_NAMESPACE){if(!isCustomComponentTag&&Object.prototype.toString.call(domElement)==='[object HTMLUnknownElement]'&&!hasOwnProperty.call(warnedUnknownTags,type)){warnedUnknownTags[type]=true;error('The tag <%s> is unrecognized in this browser. '+'If you meant to render a React component, start its name with '+'an uppercase letter.',type);}}}return domElement;}function createTextNode(text,rootContainerElement){return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);}function setInitialProperties(domElement,tag,rawProps,rootContainerElement){var isCustomComponentTag=isCustomComponent(tag,rawProps);{validatePropertiesInDevelopment(tag,rawProps);}// TODO: Make sure that we check isMounted before firing any of these events.
var props;switch(tag){case'dialog':listenToNonDelegatedEvent('cancel',domElement);listenToNonDelegatedEvent('close',domElement);props=rawProps;break;case'iframe':case'object':case'embed':// We listen to this event in case to ensure emulated bubble
// listeners still fire for the load event.
listenToNonDelegatedEvent('load',domElement);props=rawProps;break;case'video':case'audio':// We listen to these events in case to ensure emulated bubble
// listeners still fire for all the media events.
for(var i=0;i<mediaEventTypes.length;i++){listenToNonDelegatedEvent(mediaEventTypes[i],domElement);}props=rawProps;break;case'source':// We listen to this event in case to ensure emulated bubble
// listeners still fire for the error event.
listenToNonDelegatedEvent('error',domElement);props=rawProps;break;case'img':case'image':case'link':// We listen to these events in case to ensure emulated bubble
// listeners still fire for error and load events.
listenToNonDelegatedEvent('error',domElement);listenToNonDelegatedEvent('load',domElement);props=rawProps;break;case'details':// We listen to this event in case to ensure emulated bubble
// listeners still fire for the toggle event.
listenToNonDelegatedEvent('toggle',domElement);props=rawProps;break;case'input':initWrapperState(domElement,rawProps);props=getHostProps(domElement,rawProps);// We listen to this event in case to ensure emulated bubble
// listeners still fire for the invalid event.
listenToNonDelegatedEvent('invalid',domElement);break;case'option':validateProps(domElement,rawProps);props=rawProps;break;case'select':initWrapperState$1(domElement,rawProps);props=getHostProps$1(domElement,rawProps);// We listen to this event in case to ensure emulated bubble
// listeners still fire for the invalid event.
listenToNonDelegatedEvent('invalid',domElement);break;case'textarea':initWrapperState$2(domElement,rawProps);props=getHostProps$2(domElement,rawProps);// We listen to this event in case to ensure emulated bubble
// listeners still fire for the invalid event.
listenToNonDelegatedEvent('invalid',domElement);break;default:props=rawProps;}assertValidProps(tag,props);setInitialDOMProperties(tag,domElement,rootContainerElement,props,isCustomComponentTag);switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper(domElement,rawProps,false);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper$3(domElement);break;case'option':postMountWrapper$1(domElement,rawProps);break;case'select':postMountWrapper$2(domElement,rawProps);break;default:if(typeof props.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}}// Calculate the diff between the two objects.
function diffProperties(domElement,tag,lastRawProps,nextRawProps,rootContainerElement){{validatePropertiesInDevelopment(tag,nextRawProps);}var updatePayload=null;var lastProps;var nextProps;switch(tag){case'input':lastProps=getHostProps(domElement,lastRawProps);nextProps=getHostProps(domElement,nextRawProps);updatePayload=[];break;case'select':lastProps=getHostProps$1(domElement,lastRawProps);nextProps=getHostProps$1(domElement,nextRawProps);updatePayload=[];break;case'textarea':lastProps=getHostProps$2(domElement,lastRawProps);nextProps=getHostProps$2(domElement,nextRawProps);updatePayload=[];break;default:lastProps=lastRawProps;nextProps=nextRawProps;if(typeof lastProps.onClick!=='function'&&typeof nextProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}assertValidProps(tag,nextProps);var propKey;var styleName;var styleUpdates=null;for(propKey in lastProps){if(nextProps.hasOwnProperty(propKey)||!lastProps.hasOwnProperty(propKey)||lastProps[propKey]==null){continue;}if(propKey===STYLE){var lastStyle=lastProps[propKey];for(styleName in lastStyle){if(lastStyle.hasOwnProperty(styleName)){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}}else if(propKey===DANGEROUSLY_SET_INNER_HTML||propKey===CHILDREN);else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(propKey===AUTOFOCUS);else if(registrationNameDependencies.hasOwnProperty(propKey)){// This is a special case. If any listener updates we need to ensure
// that the "current" fiber pointer gets updated so we need a commit
// to update this element.
if(!updatePayload){updatePayload=[];}}else {// For all other deleted properties we add it to the queue. We use
// the allowed property list in the commit phase instead.
(updatePayload=updatePayload||[]).push(propKey,null);}}for(propKey in nextProps){var nextProp=nextProps[propKey];var lastProp=lastProps!=null?lastProps[propKey]:undefined;if(!nextProps.hasOwnProperty(propKey)||nextProp===lastProp||nextProp==null&&lastProp==null){continue;}if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be
// mutated. We have already warned for this in the past.
Object.freeze(nextProp);}}if(lastProp){// Unset styles on `lastProp` but not on `nextProp`.
for(styleName in lastProp){if(lastProp.hasOwnProperty(styleName)&&(!nextProp||!nextProp.hasOwnProperty(styleName))){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}// Update styles that changed since `lastProp`.
for(styleName in nextProp){if(nextProp.hasOwnProperty(styleName)&&lastProp[styleName]!==nextProp[styleName]){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]=nextProp[styleName];}}}else {// Relies on `updateStylesByID` not mutating `styleUpdates`.
if(!styleUpdates){if(!updatePayload){updatePayload=[];}updatePayload.push(propKey,styleUpdates);}styleUpdates=nextProp;}}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML$1]:undefined;var lastHtml=lastProp?lastProp[HTML$1]:undefined;if(nextHtml!=null){if(lastHtml!==nextHtml){(updatePayload=updatePayload||[]).push(propKey,nextHtml);}}}else if(propKey===CHILDREN){if(typeof nextProp==='string'||typeof nextProp==='number'){(updatePayload=updatePayload||[]).push(propKey,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){// We eagerly listen to this even though we haven't committed yet.
if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}if(!updatePayload&&lastProp!==nextProp){// This is a special case. If any listener updates we need to ensure
// that the "current" props pointer gets updated so we need a commit
// to update this element.
updatePayload=[];}}else {// For any other property we always add it to the queue and then we
// filter it out using the allowed property list during the commit.
(updatePayload=updatePayload||[]).push(propKey,nextProp);}}if(styleUpdates){{validateShorthandPropertyCollisionInDev(styleUpdates,nextProps[STYLE]);}(updatePayload=updatePayload||[]).push(STYLE,styleUpdates);}return updatePayload;}// Apply the diff.
function updateProperties(domElement,updatePayload,tag,lastRawProps,nextRawProps){// Update checked *before* name.
// In the middle of an update, it is possible to have multiple checked.
// When a checked radio tries to change name, browser makes another radio's checked false.
if(tag==='input'&&nextRawProps.type==='radio'&&nextRawProps.name!=null){updateChecked(domElement,nextRawProps);}var wasCustomComponentTag=isCustomComponent(tag,lastRawProps);var isCustomComponentTag=isCustomComponent(tag,nextRawProps);// Apply the diff.
updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag);// TODO: Ensure that an update gets scheduled if any of the special props
// changed.
switch(tag){case'input':// Update the wrapper around inputs *after* updating props. This has to
// happen after `updateDOMProperties`. Otherwise HTML5 input validations
// raise warnings and prevent the new value from being assigned.
updateWrapper(domElement,nextRawProps);break;case'textarea':updateWrapper$1(domElement,nextRawProps);break;case'select':// <select> value update needs to occur after <option> children
// reconciliation
postUpdateWrapper(domElement,nextRawProps);break;}}function getPossibleStandardName(propName){{var lowerCasedName=propName.toLowerCase();if(!possibleStandardNames.hasOwnProperty(lowerCasedName)){return null;}return possibleStandardNames[lowerCasedName]||null;}}function diffHydratedProperties(domElement,tag,rawProps,parentNamespace,rootContainerElement,isConcurrentMode,shouldWarnDev){var isCustomComponentTag;var extraAttributeNames;{isCustomComponentTag=isCustomComponent(tag,rawProps);validatePropertiesInDevelopment(tag,rawProps);}// TODO: Make sure that we check isMounted before firing any of these events.
switch(tag){case'dialog':listenToNonDelegatedEvent('cancel',domElement);listenToNonDelegatedEvent('close',domElement);break;case'iframe':case'object':case'embed':// We listen to this event in case to ensure emulated bubble
// listeners still fire for the load event.
listenToNonDelegatedEvent('load',domElement);break;case'video':case'audio':// We listen to these events in case to ensure emulated bubble
// listeners still fire for all the media events.
for(var i=0;i<mediaEventTypes.length;i++){listenToNonDelegatedEvent(mediaEventTypes[i],domElement);}break;case'source':// We listen to this event in case to ensure emulated bubble
// listeners still fire for the error event.
listenToNonDelegatedEvent('error',domElement);break;case'img':case'image':case'link':// We listen to these events in case to ensure emulated bubble
// listeners still fire for error and load events.
listenToNonDelegatedEvent('error',domElement);listenToNonDelegatedEvent('load',domElement);break;case'details':// We listen to this event in case to ensure emulated bubble
// listeners still fire for the toggle event.
listenToNonDelegatedEvent('toggle',domElement);break;case'input':initWrapperState(domElement,rawProps);// We listen to this event in case to ensure emulated bubble
// listeners still fire for the invalid event.
listenToNonDelegatedEvent('invalid',domElement);break;case'option':validateProps(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);// We listen to this event in case to ensure emulated bubble
// listeners still fire for the invalid event.
listenToNonDelegatedEvent('invalid',domElement);break;case'textarea':initWrapperState$2(domElement,rawProps);// We listen to this event in case to ensure emulated bubble
// listeners still fire for the invalid event.
listenToNonDelegatedEvent('invalid',domElement);break;}assertValidProps(tag,rawProps);{extraAttributeNames=new Set();var attributes=domElement.attributes;for(var _i=0;_i<attributes.length;_i++){var name=attributes[_i].name.toLowerCase();switch(name){// Controlled attributes are not validated
// TODO: Only ignore them on controlled tags.
case'value':break;case'checked':break;case'selected':break;default:// Intentionally use the original name.
// See discussion in https://github.com/facebook/react/pull/10676.
extraAttributeNames.add(attributes[_i].name);}}}var updatePayload=null;for(var propKey in rawProps){if(!rawProps.hasOwnProperty(propKey)){continue;}var nextProp=rawProps[propKey];if(propKey===CHILDREN){// For text content children we compare against textContent. This
// might match additional HTML that is hidden when we read it using
// textContent. E.g. "foo" will match "f<span>oo</span>" but that still
// satisfies our requirement. Our requirement is not to produce perfect
// HTML and attributes. Ideally we should preserve structure but it's
// ok not to if the visible content is still enough to indicate what
// even listeners these nodes might be wired up to.
// TODO: Warn if there is more than a single textNode as a child.
// TODO: Should we use domElement.firstChild.nodeValue to compare?
if(typeof nextProp==='string'){if(domElement.textContent!==nextProp){if(rawProps[SUPPRESS_HYDRATION_WARNING]!==true){checkForUnmatchedText(domElement.textContent,nextProp,isConcurrentMode,shouldWarnDev);}updatePayload=[CHILDREN,nextProp];}}else if(typeof nextProp==='number'){if(domElement.textContent!==''+nextProp){if(rawProps[SUPPRESS_HYDRATION_WARNING]!==true){checkForUnmatchedText(domElement.textContent,nextProp,isConcurrentMode,shouldWarnDev);}updatePayload=[CHILDREN,''+nextProp];}}}else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}}else if(shouldWarnDev&&true&&// Convince Flow we've calculated it (it's DEV-only in this method.)
typeof isCustomComponentTag==='boolean'){// Validate that the properties correspond to their expected values.
var serverValue=void 0;var propertyInfo=isCustomComponentTag&&enableCustomElementPropertySupport?null:getPropertyInfo(propKey);if(rawProps[SUPPRESS_HYDRATION_WARNING]===true);else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING||// Controlled attributes are not validated
// TODO: Only ignore them on controlled tags.
propKey==='value'||propKey==='checked'||propKey==='selected');else if(propKey===DANGEROUSLY_SET_INNER_HTML){var serverHTML=domElement.innerHTML;var nextHtml=nextProp?nextProp[HTML$1]:undefined;if(nextHtml!=null){var expectedHTML=normalizeHTML(domElement,nextHtml);if(expectedHTML!==serverHTML){warnForPropDifference(propKey,serverHTML,expectedHTML);}}}else if(propKey===STYLE){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(propKey);if(canDiffStyleForHydrationWarning){var expectedStyle=createDangerousStringForStyles(nextProp);serverValue=domElement.getAttribute('style');if(expectedStyle!==serverValue){warnForPropDifference(propKey,serverValue,expectedStyle);}}}else if(isCustomComponentTag&&!enableCustomElementPropertySupport){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(propKey.toLowerCase());serverValue=getValueForAttribute(domElement,propKey,nextProp);if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}else if(!shouldIgnoreAttribute(propKey,propertyInfo,isCustomComponentTag)&&!shouldRemoveAttribute(propKey,nextProp,propertyInfo,isCustomComponentTag)){var isMismatchDueToBadCasing=false;if(propertyInfo!==null){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(propertyInfo.attributeName);serverValue=getValueForProperty(domElement,propKey,nextProp,propertyInfo);}else {var ownNamespace=parentNamespace;if(ownNamespace===HTML_NAMESPACE){ownNamespace=getIntrinsicNamespace(tag);}if(ownNamespace===HTML_NAMESPACE){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(propKey.toLowerCase());}else {var standardName=getPossibleStandardName(propKey);if(standardName!==null&&standardName!==propKey){// If an SVG prop is supplied with bad casing, it will
// be successfully parsed from HTML, but will produce a mismatch
// (and would be incorrectly rendered on the client).
// However, we already warn about bad casing elsewhere.
// So we'll skip the misleading extra mismatch warning in this case.
isMismatchDueToBadCasing=true;// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(standardName);}// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(propKey);}serverValue=getValueForAttribute(domElement,propKey,nextProp);}var dontWarnCustomElement=enableCustomElementPropertySupport;if(!dontWarnCustomElement&&nextProp!==serverValue&&!isMismatchDueToBadCasing){warnForPropDifference(propKey,serverValue,nextProp);}}}}{if(shouldWarnDev){if(// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.size>0&&rawProps[SUPPRESS_HYDRATION_WARNING]!==true){// $FlowFixMe - Should be inferred as not undefined.
warnForExtraAttributes(extraAttributeNames);}}}switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper(domElement,rawProps,true);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper$3(domElement);break;case'select':case'option':// For input and textarea we current always set the value property at
// post mount to force it to diverge from attributes. However, for
// option and select we don't quite do the same thing and select
// is not resilient to the DOM state changing so we don't do that here.
// TODO: Consider not doing this for input and textarea.
break;default:if(typeof rawProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}return updatePayload;}function diffHydratedText(textNode,text,isConcurrentMode){var isDifferent=textNode.nodeValue!==text;return isDifferent;}function warnForDeletedHydratableElement(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Did not expect server HTML to contain a <%s> in <%s>.',child.nodeName.toLowerCase(),parentNode.nodeName.toLowerCase());}}function warnForDeletedHydratableText(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Did not expect server HTML to contain the text node "%s" in <%s>.',child.nodeValue,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedElement(parentNode,tag,props){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Expected server HTML to contain a matching <%s> in <%s>.',tag,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedText(parentNode,text){{if(text===''){// We expect to insert empty text nodes since they're not represented in
// the HTML.
// TODO: Remove this special case if we can just avoid inserting empty
// text nodes.
return;}if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Expected server HTML to contain a matching text node for "%s" in <%s>.',text,parentNode.nodeName.toLowerCase());}}function restoreControlledState$3(domElement,tag,props){switch(tag){case'input':restoreControlledState(domElement,props);return;case'textarea':restoreControlledState$2(domElement,props);return;case'select':restoreControlledState$1(domElement,props);return;}}var validateDOMNesting=function(){};var updatedAncestorInfo=function(){};{// This validation code was written based on the HTML5 parsing spec:
// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
//
// Note: this does not catch all invalid nesting, nor does it try to (as it's
// not clear what practical benefit doing so provides); instead, we warn only
// for cases where the parser will give a parse tree differing from what React
// intended. For example, <b><div></div></b> is invalid but we don't warn
// because it still parses correctly; we do warn for other cases like nested
// <p> tags where the beginning of the second element implicitly closes the
// first, causing a confusing mess.
// https://html.spec.whatwg.org/multipage/syntax.html#special
var specialTags=['address','applet','area','article','aside','base','basefont','bgsound','blockquote','body','br','button','caption','center','col','colgroup','dd','details','dir','div','dl','dt','embed','fieldset','figcaption','figure','footer','form','frame','frameset','h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','iframe','img','input','isindex','li','link','listing','main','marquee','menu','menuitem','meta','nav','noembed','noframes','noscript','object','ol','p','param','plaintext','pre','script','section','select','source','style','summary','table','tbody','td','template','textarea','tfoot','th','thead','title','tr','track','ul','wbr','xmp'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
var inScopeTags=['applet','caption','html','table','td','th','marquee','object','template',// https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
// TODO: Distinguish by namespace here -- for <title>, including it here
// errs on the side of fewer warnings
'foreignObject','desc','title'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
var buttonScopeTags=inScopeTags.concat(['button']);// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
var impliedEndTags=['dd','dt','li','option','optgroup','p','rp','rt'];var emptyAncestorInfo={current:null,formTag:null,aTagInScope:null,buttonTagInScope:null,nobrTagInScope:null,pTagInButtonScope:null,listItemTagAutoclosing:null,dlItemTagAutoclosing:null};updatedAncestorInfo=function(oldInfo,tag){var ancestorInfo=assign({},oldInfo||emptyAncestorInfo);var info={tag:tag};if(inScopeTags.indexOf(tag)!==-1){ancestorInfo.aTagInScope=null;ancestorInfo.buttonTagInScope=null;ancestorInfo.nobrTagInScope=null;}if(buttonScopeTags.indexOf(tag)!==-1){ancestorInfo.pTagInButtonScope=null;}// See rules for 'li', 'dd', 'dt' start tags in
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
if(specialTags.indexOf(tag)!==-1&&tag!=='address'&&tag!=='div'&&tag!=='p'){ancestorInfo.listItemTagAutoclosing=null;ancestorInfo.dlItemTagAutoclosing=null;}ancestorInfo.current=info;if(tag==='form'){ancestorInfo.formTag=info;}if(tag==='a'){ancestorInfo.aTagInScope=info;}if(tag==='button'){ancestorInfo.buttonTagInScope=info;}if(tag==='nobr'){ancestorInfo.nobrTagInScope=info;}if(tag==='p'){ancestorInfo.pTagInButtonScope=info;}if(tag==='li'){ancestorInfo.listItemTagAutoclosing=info;}if(tag==='dd'||tag==='dt'){ancestorInfo.dlItemTagAutoclosing=info;}return ancestorInfo;};/**
   * Returns whether
   */var isTagValidWithParent=function(tag,parentTag){// First, let's check if we're in an unusual parsing mode...
switch(parentTag){// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
case'select':return tag==='option'||tag==='optgroup'||tag==='#text';case'optgroup':return tag==='option'||tag==='#text';// Strictly speaking, seeing an <option> doesn't mean we're in a <select>
// but
case'option':return tag==='#text';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
// No special behavior since these rules fall back to "in body" mode for
// all except special table nodes which cause bad parsing behavior anyway.
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
case'tr':return tag==='th'||tag==='td'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
case'tbody':case'thead':case'tfoot':return tag==='tr'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
case'colgroup':return tag==='col'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
case'table':return tag==='caption'||tag==='colgroup'||tag==='tbody'||tag==='tfoot'||tag==='thead'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
case'head':return tag==='base'||tag==='basefont'||tag==='bgsound'||tag==='link'||tag==='meta'||tag==='title'||tag==='noscript'||tag==='noframes'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
case'html':return tag==='head'||tag==='body'||tag==='frameset';case'frameset':return tag==='frame';case'#document':return tag==='html';}// Probably in the "in body" parsing mode, so we outlaw only tag combos
// where the parsing rules cause implicit opens or closes to be added.
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
switch(tag){case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return parentTag!=='h1'&&parentTag!=='h2'&&parentTag!=='h3'&&parentTag!=='h4'&&parentTag!=='h5'&&parentTag!=='h6';case'rp':case'rt':return impliedEndTags.indexOf(parentTag)===-1;case'body':case'caption':case'col':case'colgroup':case'frameset':case'frame':case'head':case'html':case'tbody':case'td':case'tfoot':case'th':case'thead':case'tr':// These tags are only valid with a few parents that have special child
// parsing rules -- if we're down here, then none of those matched and
// so we allow it only if we don't know what the parent is, as all other
// cases are invalid.
return parentTag==null;}return true;};/**
   * Returns whether
   */var findInvalidAncestorForTag=function(tag,ancestorInfo){switch(tag){case'address':case'article':case'aside':case'blockquote':case'center':case'details':case'dialog':case'dir':case'div':case'dl':case'fieldset':case'figcaption':case'figure':case'footer':case'header':case'hgroup':case'main':case'menu':case'nav':case'ol':case'p':case'section':case'summary':case'ul':case'pre':case'listing':case'table':case'hr':case'xmp':case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return ancestorInfo.pTagInButtonScope;case'form':return ancestorInfo.formTag||ancestorInfo.pTagInButtonScope;case'li':return ancestorInfo.listItemTagAutoclosing;case'dd':case'dt':return ancestorInfo.dlItemTagAutoclosing;case'button':return ancestorInfo.buttonTagInScope;case'a':// Spec says something about storing a list of markers, but it sounds
// equivalent to this check.
return ancestorInfo.aTagInScope;case'nobr':return ancestorInfo.nobrTagInScope;}return null;};var didWarn$1={};validateDOMNesting=function(childTag,childText,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;if(childText!=null){if(childTag!=null){error('validateDOMNesting: when childText is passed, childTag should be null');}childTag='#text';}var invalidParent=isTagValidWithParent(childTag,parentTag)?null:parentInfo;var invalidAncestor=invalidParent?null:findInvalidAncestorForTag(childTag,ancestorInfo);var invalidParentOrAncestor=invalidParent||invalidAncestor;if(!invalidParentOrAncestor){return;}var ancestorTag=invalidParentOrAncestor.tag;var warnKey=!!invalidParent+'|'+childTag+'|'+ancestorTag;if(didWarn$1[warnKey]){return;}didWarn$1[warnKey]=true;var tagDisplayName=childTag;var whitespaceInfo='';if(childTag==='#text'){if(/\S/.test(childText)){tagDisplayName='Text nodes';}else {tagDisplayName='Whitespace text nodes';whitespaceInfo=" Make sure you don't have any extra whitespace between tags on "+'each line of your source code.';}}else {tagDisplayName='<'+childTag+'>';}if(invalidParent){var info='';if(ancestorTag==='table'&&childTag==='tr'){info+=' Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by '+'the browser.';}error('validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s',tagDisplayName,ancestorTag,whitespaceInfo,info);}else {error('validateDOMNesting(...): %s cannot appear as a descendant of '+'<%s>.',tagDisplayName,ancestorTag);}};}var SUPPRESS_HYDRATION_WARNING$1='suppressHydrationWarning';var SUSPENSE_START_DATA='$';var SUSPENSE_END_DATA='/$';var SUSPENSE_PENDING_START_DATA='$?';var SUSPENSE_FALLBACK_START_DATA='$!';var STYLE$1='style';var eventsEnabled=null;var selectionInformation=null;function getRootHostContext(rootContainerInstance){var type;var namespace;var nodeType=rootContainerInstance.nodeType;switch(nodeType){case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:{type=nodeType===DOCUMENT_NODE?'#document':'#fragment';var root=rootContainerInstance.documentElement;namespace=root?root.namespaceURI:getChildNamespace(null,'');break;}default:{var container=nodeType===COMMENT_NODE?rootContainerInstance.parentNode:rootContainerInstance;var ownNamespace=container.namespaceURI||null;type=container.tagName;namespace=getChildNamespace(ownNamespace,type);break;}}{var validatedTag=type.toLowerCase();var ancestorInfo=updatedAncestorInfo(null,validatedTag);return {namespace:namespace,ancestorInfo:ancestorInfo};}}function getChildHostContext(parentHostContext,type,rootContainerInstance){{var parentHostContextDev=parentHostContext;var namespace=getChildNamespace(parentHostContextDev.namespace,type);var ancestorInfo=updatedAncestorInfo(parentHostContextDev.ancestorInfo,type);return {namespace:namespace,ancestorInfo:ancestorInfo};}}function getPublicInstance(instance){return instance;}function prepareForCommit(containerInfo){eventsEnabled=isEnabled();selectionInformation=getSelectionInformation();var activeInstance=null;setEnabled(false);return activeInstance;}function resetAfterCommit(containerInfo){restoreSelection(selectionInformation);setEnabled(eventsEnabled);eventsEnabled=null;selectionInformation=null;}function createInstance(type,props,rootContainerInstance,hostContext,internalInstanceHandle){var parentNamespace;{// TODO: take namespace into account when validating.
var hostContextDev=hostContext;validateDOMNesting(type,null,hostContextDev.ancestorInfo);if(typeof props.children==='string'||typeof props.children==='number'){var string=''+props.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}parentNamespace=hostContextDev.namespace;}var domElement=createElement(type,props,rootContainerInstance,parentNamespace);precacheFiberNode(internalInstanceHandle,domElement);updateFiberProps(domElement,props);return domElement;}function appendInitialChild(parentInstance,child){parentInstance.appendChild(child);}function finalizeInitialChildren(domElement,type,props,rootContainerInstance,hostContext){setInitialProperties(domElement,type,props,rootContainerInstance);switch(type){case'button':case'input':case'select':case'textarea':return !!props.autoFocus;case'img':return true;default:return false;}}function prepareUpdate(domElement,type,oldProps,newProps,rootContainerInstance,hostContext){{var hostContextDev=hostContext;if(typeof newProps.children!==typeof oldProps.children&&(typeof newProps.children==='string'||typeof newProps.children==='number')){var string=''+newProps.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}}return diffProperties(domElement,type,oldProps,newProps);}function shouldSetTextContent(type,props){return type==='textarea'||type==='noscript'||typeof props.children==='string'||typeof props.children==='number'||typeof props.dangerouslySetInnerHTML==='object'&&props.dangerouslySetInnerHTML!==null&&props.dangerouslySetInnerHTML.__html!=null;}function createTextInstance(text,rootContainerInstance,hostContext,internalInstanceHandle){{var hostContextDev=hostContext;validateDOMNesting(null,text,hostContextDev.ancestorInfo);}var textNode=createTextNode(text,rootContainerInstance);precacheFiberNode(internalInstanceHandle,textNode);return textNode;}function getCurrentEventPriority(){var currentEvent=window.event;if(currentEvent===undefined){return DefaultEventPriority;}return getEventPriority(currentEvent.type);}// if a component just imports ReactDOM (e.g. for findDOMNode).
// Some environments might not have setTimeout or clearTimeout.
var scheduleTimeout=typeof setTimeout==='function'?setTimeout:undefined;var cancelTimeout=typeof clearTimeout==='function'?clearTimeout:undefined;var noTimeout=-1;var localPromise=typeof Promise==='function'?Promise:undefined;// -------------------
var scheduleMicrotask=typeof queueMicrotask==='function'?queueMicrotask:typeof localPromise!=='undefined'?function(callback){return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);}:scheduleTimeout;// TODO: Determine the best fallback here.
function handleErrorInNextTick(error){setTimeout(function(){throw error;});}// -------------------
function commitMount(domElement,type,newProps,internalInstanceHandle){// Despite the naming that might imply otherwise, this method only
// fires if there is an `Update` effect scheduled during mounting.
// This happens if `finalizeInitialChildren` returns `true` (which it
// does to implement the `autoFocus` attribute on the client). But
// there are also other cases when this might happen (such as patching
// up text content during hydration mismatch). So we'll check this again.
switch(type){case'button':case'input':case'select':case'textarea':if(newProps.autoFocus){domElement.focus();}return;case'img':{if(newProps.src){domElement.src=newProps.src;}return;}}}function commitUpdate(domElement,updatePayload,type,oldProps,newProps,internalInstanceHandle){// Apply the diff to the DOM node.
updateProperties(domElement,updatePayload,type,oldProps,newProps);// Update the props handle so that we know which props are the ones with
// with current event handlers.
updateFiberProps(domElement,newProps);}function resetTextContent(domElement){setTextContent(domElement,'');}function commitTextUpdate(textInstance,oldText,newText){textInstance.nodeValue=newText;}function appendChild(parentInstance,child){parentInstance.appendChild(child);}function appendChildToContainer(container,child){var parentNode;if(container.nodeType===COMMENT_NODE){parentNode=container.parentNode;parentNode.insertBefore(child,container);}else {parentNode=container;parentNode.appendChild(child);}// This container might be used for a portal.
// If something inside a portal is clicked, that click should bubble
// through the React tree. However, on Mobile Safari the click would
// never bubble through the *DOM* tree unless an ancestor with onclick
// event exists. So we wouldn't see it and dispatch it.
// This is why we ensure that non React root containers have inline onclick
// defined.
// https://github.com/facebook/react/issues/11918
var reactRootContainer=container._reactRootContainer;if((reactRootContainer===null||reactRootContainer===undefined)&&parentNode.onclick===null){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(parentNode);}}function insertBefore(parentInstance,child,beforeChild){parentInstance.insertBefore(child,beforeChild);}function insertInContainerBefore(container,child,beforeChild){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,beforeChild);}else {container.insertBefore(child,beforeChild);}}function removeChild(parentInstance,child){parentInstance.removeChild(child);}function removeChildFromContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.removeChild(child);}else {container.removeChild(child);}}function clearSuspenseBoundary(parentInstance,suspenseInstance){var node=suspenseInstance;// Delete all nodes within this suspense boundary.
// There might be nested nodes so we need to keep track of how
// deep we are and only break out when we're back on top.
var depth=0;do{var nextNode=node.nextSibling;parentInstance.removeChild(node);if(nextNode&&nextNode.nodeType===COMMENT_NODE){var data=nextNode.data;if(data===SUSPENSE_END_DATA){if(depth===0){parentInstance.removeChild(nextNode);// Retry if any event replaying was blocked on this.
retryIfBlockedOn(suspenseInstance);return;}else {depth--;}}else if(data===SUSPENSE_START_DATA||data===SUSPENSE_PENDING_START_DATA||data===SUSPENSE_FALLBACK_START_DATA){depth++;}}node=nextNode;}while(node);// TODO: Warn, we didn't find the end comment boundary.
// Retry if any event replaying was blocked on this.
retryIfBlockedOn(suspenseInstance);}function clearSuspenseBoundaryFromContainer(container,suspenseInstance){if(container.nodeType===COMMENT_NODE){clearSuspenseBoundary(container.parentNode,suspenseInstance);}else if(container.nodeType===ELEMENT_NODE){clearSuspenseBoundary(container,suspenseInstance);}// Retry if any event replaying was blocked on this.
retryIfBlockedOn(container);}function hideInstance(instance){// TODO: Does this work for all element types? What about MathML? Should we
// pass host context to this method?
instance=instance;var style=instance.style;if(typeof style.setProperty==='function'){style.setProperty('display','none','important');}else {style.display='none';}}function hideTextInstance(textInstance){textInstance.nodeValue='';}function unhideInstance(instance,props){instance=instance;var styleProp=props[STYLE$1];var display=styleProp!==undefined&&styleProp!==null&&styleProp.hasOwnProperty('display')?styleProp.display:null;instance.style.display=dangerousStyleValue('display',display);}function unhideTextInstance(textInstance,text){textInstance.nodeValue=text;}function clearContainer(container){if(container.nodeType===ELEMENT_NODE){container.textContent='';}else if(container.nodeType===DOCUMENT_NODE){if(container.documentElement){container.removeChild(container.documentElement);}}}// -------------------
function canHydrateInstance(instance,type,props){if(instance.nodeType!==ELEMENT_NODE||type.toLowerCase()!==instance.nodeName.toLowerCase()){return null;}// This has now been refined to an element node.
return instance;}function canHydrateTextInstance(instance,text){if(text===''||instance.nodeType!==TEXT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.
return null;}// This has now been refined to a text node.
return instance;}function canHydrateSuspenseInstance(instance){if(instance.nodeType!==COMMENT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.
return null;}// This has now been refined to a suspense node.
return instance;}function isSuspenseInstancePending(instance){return instance.data===SUSPENSE_PENDING_START_DATA;}function isSuspenseInstanceFallback(instance){return instance.data===SUSPENSE_FALLBACK_START_DATA;}function getSuspenseInstanceFallbackErrorDetails(instance){var dataset=instance.nextSibling&&instance.nextSibling.dataset;var digest,message,stack;if(dataset){digest=dataset.dgst;{message=dataset.msg;stack=dataset.stck;}}{return {message:message,digest:digest,stack:stack};}// let value = {message: undefined, hash: undefined};
// const nextSibling = instance.nextSibling;
// if (nextSibling) {
//   const dataset = ((nextSibling: any): HTMLTemplateElement).dataset;
//   value.message = dataset.msg;
//   value.hash = dataset.hash;
//   if (true) {
//     value.stack = dataset.stack;
//   }
// }
// return value;
}function registerSuspenseInstanceRetry(instance,callback){instance._reactRetry=callback;}function getNextHydratable(node){// Skip non-hydratable nodes.
for(;node!=null;node=node.nextSibling){var nodeType=node.nodeType;if(nodeType===ELEMENT_NODE||nodeType===TEXT_NODE){break;}if(nodeType===COMMENT_NODE){var nodeData=node.data;if(nodeData===SUSPENSE_START_DATA||nodeData===SUSPENSE_FALLBACK_START_DATA||nodeData===SUSPENSE_PENDING_START_DATA){break;}if(nodeData===SUSPENSE_END_DATA){return null;}}}return node;}function getNextHydratableSibling(instance){return getNextHydratable(instance.nextSibling);}function getFirstHydratableChild(parentInstance){return getNextHydratable(parentInstance.firstChild);}function getFirstHydratableChildWithinContainer(parentContainer){return getNextHydratable(parentContainer.firstChild);}function getFirstHydratableChildWithinSuspenseInstance(parentInstance){return getNextHydratable(parentInstance.nextSibling);}function hydrateInstance(instance,type,props,rootContainerInstance,hostContext,internalInstanceHandle,shouldWarnDev){precacheFiberNode(internalInstanceHandle,instance);// TODO: Possibly defer this until the commit phase where all the events
// get attached.
updateFiberProps(instance,props);var parentNamespace;{var hostContextDev=hostContext;parentNamespace=hostContextDev.namespace;}// TODO: Temporary hack to check if we're in a concurrent root. We can delete
// when the legacy root API is removed.
var isConcurrentMode=(internalInstanceHandle.mode&ConcurrentMode)!==NoMode;return diffHydratedProperties(instance,type,props,parentNamespace,rootContainerInstance,isConcurrentMode,shouldWarnDev);}function hydrateTextInstance(textInstance,text,internalInstanceHandle,shouldWarnDev){precacheFiberNode(internalInstanceHandle,textInstance);// TODO: Temporary hack to check if we're in a concurrent root. We can delete
// when the legacy root API is removed.
(internalInstanceHandle.mode&ConcurrentMode)!==NoMode;return diffHydratedText(textInstance,text);}function hydrateSuspenseInstance(suspenseInstance,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,suspenseInstance);}function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance){var node=suspenseInstance.nextSibling;// Skip past all nodes within this suspense boundary.
// There might be nested nodes so we need to keep track of how
// deep we are and only break out when we're back on top.
var depth=0;while(node){if(node.nodeType===COMMENT_NODE){var data=node.data;if(data===SUSPENSE_END_DATA){if(depth===0){return getNextHydratableSibling(node);}else {depth--;}}else if(data===SUSPENSE_START_DATA||data===SUSPENSE_FALLBACK_START_DATA||data===SUSPENSE_PENDING_START_DATA){depth++;}}node=node.nextSibling;}// TODO: Warn, we didn't find the end comment boundary.
return null;}// Returns the SuspenseInstance if this node is a direct child of a
// SuspenseInstance. I.e. if its previous sibling is a Comment with
// SUSPENSE_x_START_DATA. Otherwise, null.
function getParentSuspenseInstance(targetInstance){var node=targetInstance.previousSibling;// Skip past all nodes within this suspense boundary.
// There might be nested nodes so we need to keep track of how
// deep we are and only break out when we're back on top.
var depth=0;while(node){if(node.nodeType===COMMENT_NODE){var data=node.data;if(data===SUSPENSE_START_DATA||data===SUSPENSE_FALLBACK_START_DATA||data===SUSPENSE_PENDING_START_DATA){if(depth===0){return node;}else {depth--;}}else if(data===SUSPENSE_END_DATA){depth++;}}node=node.previousSibling;}return null;}function commitHydratedContainer(container){// Retry if any event replaying was blocked on this.
retryIfBlockedOn(container);}function commitHydratedSuspenseInstance(suspenseInstance){// Retry if any event replaying was blocked on this.
retryIfBlockedOn(suspenseInstance);}function shouldDeleteUnhydratedTailInstances(parentType){return parentType!=='head'&&parentType!=='body';}function didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,text,isConcurrentMode){var shouldWarnDev=true;checkForUnmatchedText(textInstance.nodeValue,text,isConcurrentMode,shouldWarnDev);}function didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,text,isConcurrentMode){if(parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){var shouldWarnDev=true;checkForUnmatchedText(textInstance.nodeValue,text,isConcurrentMode,shouldWarnDev);}}function didNotHydrateInstanceWithinContainer(parentContainer,instance){{if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentContainer,instance);}else if(instance.nodeType===COMMENT_NODE);else {warnForDeletedHydratableText(parentContainer,instance);}}}function didNotHydrateInstanceWithinSuspenseInstance(parentInstance,instance){{// $FlowFixMe: Only Element or Document can be parent nodes.
var parentNode=parentInstance.parentNode;if(parentNode!==null){if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentNode,instance);}else if(instance.nodeType===COMMENT_NODE);else {warnForDeletedHydratableText(parentNode,instance);}}}}function didNotHydrateInstance(parentType,parentProps,parentInstance,instance,isConcurrentMode){{if(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentInstance,instance);}else if(instance.nodeType===COMMENT_NODE);else {warnForDeletedHydratableText(parentInstance,instance);}}}}function didNotFindHydratableInstanceWithinContainer(parentContainer,type,props){{warnForInsertedHydratedElement(parentContainer,type);}}function didNotFindHydratableTextInstanceWithinContainer(parentContainer,text){{warnForInsertedHydratedText(parentContainer,text);}}function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance,type,props){{// $FlowFixMe: Only Element or Document can be parent nodes.
var parentNode=parentInstance.parentNode;if(parentNode!==null)warnForInsertedHydratedElement(parentNode,type);}}function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance,text){{// $FlowFixMe: Only Element or Document can be parent nodes.
var parentNode=parentInstance.parentNode;if(parentNode!==null)warnForInsertedHydratedText(parentNode,text);}}function didNotFindHydratableInstance(parentType,parentProps,parentInstance,type,props,isConcurrentMode){{if(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){warnForInsertedHydratedElement(parentInstance,type);}}}function didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,text,isConcurrentMode){{if(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){warnForInsertedHydratedText(parentInstance,text);}}}function errorHydratingContainer(parentContainer){{// TODO: This gets logged by onRecoverableError, too, so we should be
// able to remove it.
error('An error occurred during hydration. The server HTML was replaced with client content in <%s>.',parentContainer.nodeName.toLowerCase());}}function preparePortalMount(portalInstance){listenToAllSupportedEvents(portalInstance);}var randomKey=Math.random().toString(36).slice(2);var internalInstanceKey='__reactFiber$'+randomKey;var internalPropsKey='__reactProps$'+randomKey;var internalContainerInstanceKey='__reactContainer$'+randomKey;var internalEventHandlersKey='__reactEvents$'+randomKey;var internalEventHandlerListenersKey='__reactListeners$'+randomKey;var internalEventHandlesSetKey='__reactHandles$'+randomKey;function detachDeletedInstance(node){// TODO: This function is only called on host components. I don't think all of
// these fields are relevant.
delete node[internalInstanceKey];delete node[internalPropsKey];delete node[internalEventHandlersKey];delete node[internalEventHandlerListenersKey];delete node[internalEventHandlesSetKey];}function precacheFiberNode(hostInst,node){node[internalInstanceKey]=hostInst;}function markContainerAsRoot(hostRoot,node){node[internalContainerInstanceKey]=hostRoot;}function unmarkContainerAsRoot(node){node[internalContainerInstanceKey]=null;}function isContainerMarkedAsRoot(node){return !!node[internalContainerInstanceKey];}// Given a DOM node, return the closest HostComponent or HostText fiber ancestor.
// If the target node is part of a hydrated or not yet rendered subtree, then
// this may also return a SuspenseComponent or HostRoot to indicate that.
// Conceptually the HostRoot fiber is a child of the Container node. So if you
// pass the Container node as the targetNode, you will not actually get the
// HostRoot back. To get to the HostRoot, you need to pass a child of it.
// The same thing applies to Suspense boundaries.
function getClosestInstanceFromNode(targetNode){var targetInst=targetNode[internalInstanceKey];if(targetInst){// Don't return HostRoot or SuspenseComponent here.
return targetInst;}// If the direct event target isn't a React owned DOM node, we need to look
// to see if one of its parents is a React owned DOM node.
var parentNode=targetNode.parentNode;while(parentNode){// We'll check if this is a container root that could include
// React nodes in the future. We need to check this first because
// if we're a child of a dehydrated container, we need to first
// find that inner container before moving on to finding the parent
// instance. Note that we don't check this field on  the targetNode
// itself because the fibers are conceptually between the container
// node and the first child. It isn't surrounding the container node.
// If it's not a container, we check if it's an instance.
targetInst=parentNode[internalContainerInstanceKey]||parentNode[internalInstanceKey];if(targetInst){// Since this wasn't the direct target of the event, we might have
// stepped past dehydrated DOM nodes to get here. However they could
// also have been non-React nodes. We need to answer which one.
// If we the instance doesn't have any children, then there can't be
// a nested suspense boundary within it. So we can use this as a fast
// bailout. Most of the time, when people add non-React children to
// the tree, it is using a ref to a child-less DOM node.
// Normally we'd only need to check one of the fibers because if it
// has ever gone from having children to deleting them or vice versa
// it would have deleted the dehydrated boundary nested inside already.
// However, since the HostRoot starts out with an alternate it might
// have one on the alternate so we need to check in case this was a
// root.
var alternate=targetInst.alternate;if(targetInst.child!==null||alternate!==null&&alternate.child!==null){// Next we need to figure out if the node that skipped past is
// nested within a dehydrated boundary and if so, which one.
var suspenseInstance=getParentSuspenseInstance(targetNode);while(suspenseInstance!==null){// We found a suspense instance. That means that we haven't
// hydrated it yet. Even though we leave the comments in the
// DOM after hydrating, and there are boundaries in the DOM
// that could already be hydrated, we wouldn't have found them
// through this pass since if the target is hydrated it would
// have had an internalInstanceKey on it.
// Let's get the fiber associated with the SuspenseComponent
// as the deepest instance.
var targetSuspenseInst=suspenseInstance[internalInstanceKey];if(targetSuspenseInst){return targetSuspenseInst;}// If we don't find a Fiber on the comment, it might be because
// we haven't gotten to hydrate it yet. There might still be a
// parent boundary that hasn't above this one so we need to find
// the outer most that is known.
suspenseInstance=getParentSuspenseInstance(suspenseInstance);// If we don't find one, then that should mean that the parent
// host component also hasn't hydrated yet. We can return it
// below since it will bail out on the isMounted check later.
}}return targetInst;}targetNode=parentNode;parentNode=targetNode.parentNode;}return null;}/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */function getInstanceFromNode(node){var inst=node[internalInstanceKey]||node[internalContainerInstanceKey];if(inst){if(inst.tag===HostComponent||inst.tag===HostText||inst.tag===SuspenseComponent||inst.tag===HostRoot){return inst;}else {return null;}}return null;}/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */function getNodeFromInstance(inst){if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber this, is just the state node right now. We assume it will be
// a host component or host text.
return inst.stateNode;}// Without this first invariant, passing a non-DOM-component triggers the next
// invariant for a missing parent, which is super confusing.
throw new Error('getNodeFromInstance: Invalid argument.');}function getFiberCurrentPropsFromNode(node){return node[internalPropsKey]||null;}function updateFiberProps(node,props){node[internalPropsKey]=props;}function getEventListenerSet(node){var elementListenerSet=node[internalEventHandlersKey];if(elementListenerSet===undefined){elementListenerSet=node[internalEventHandlersKey]=new Set();}return elementListenerSet;}var loggedTypeFailures={};var ReactDebugCurrentFrame$1=ReactSharedInternals.ReactDebugCurrentFrame;function setCurrentlyValidatingElement(element){{if(element){var owner=element._owner;var stack=describeUnknownElementTypeFrameInDEV(element.type,element._source,owner?owner.type:null);ReactDebugCurrentFrame$1.setExtraStackFrame(stack);}else {ReactDebugCurrentFrame$1.setExtraStackFrame(null);}}}function checkPropTypes(typeSpecs,values,location,componentName,element){{// $FlowFixMe This is okay but Flow doesn't know it.
var has=Function.call.bind(hasOwnProperty);for(var typeSpecName in typeSpecs){if(has(typeSpecs,typeSpecName)){var error$1=void 0;// Prop type validation may throw. In case they do, we don't want to
// fail the render phase where it didn't fail before. So we log it.
// After these have been cleaned up, we'll let them throw.
try{// This is intentionally an invariant that gets caught. It's the same
// behavior as without this statement except with a better message.
if(typeof typeSpecs[typeSpecName]!=='function'){// eslint-disable-next-line react-internal/prod-error-codes
var err=Error((componentName||'React class')+': '+location+' type `'+typeSpecName+'` is invalid; '+'it must be a function, usually from the `prop-types` package, but received `'+typeof typeSpecs[typeSpecName]+'`.'+'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');err.name='Invariant Violation';throw err;}error$1=typeSpecs[typeSpecName](values,typeSpecName,componentName,location,null,'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');}catch(ex){error$1=ex;}if(error$1&&!(error$1 instanceof Error)){setCurrentlyValidatingElement(element);error('%s: type specification of %s'+' `%s` is invalid; the type checker '+'function must return `null` or an `Error` but returned a %s. '+'You may have forgotten to pass an argument to the type checker '+'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and '+'shape all require an argument).',componentName||'React class',location,typeSpecName,typeof error$1);setCurrentlyValidatingElement(null);}if(error$1 instanceof Error&&!(error$1.message in loggedTypeFailures)){// Only monitor this failure once because there tends to be a lot of the
// same error.
loggedTypeFailures[error$1.message]=true;setCurrentlyValidatingElement(element);error('Failed %s type: %s',location,error$1.message);setCurrentlyValidatingElement(null);}}}}}var valueStack=[];var fiberStack;{fiberStack=[];}var index=-1;function createCursor(defaultValue){return {current:defaultValue};}function pop(cursor,fiber){if(index<0){{error('Unexpected pop.');}return;}{if(fiber!==fiberStack[index]){error('Unexpected Fiber popped.');}}cursor.current=valueStack[index];valueStack[index]=null;{fiberStack[index]=null;}index--;}function push(cursor,value,fiber){index++;valueStack[index]=cursor.current;{fiberStack[index]=fiber;}cursor.current=value;}var warnedAboutMissingGetChildContext;{warnedAboutMissingGetChildContext={};}var emptyContextObject={};{Object.freeze(emptyContextObject);}// A cursor to the current merged context object on the stack.
var contextStackCursor=createCursor(emptyContextObject);// A cursor to a boolean indicating whether the context has changed.
var didPerformWorkStackCursor=createCursor(false);// Keep track of the previous context object that was on the stack.
// We use this to get access to the parent context after we have already
// pushed the next context provider, and now need to merge their contexts.
var previousContext=emptyContextObject;function getUnmaskedContext(workInProgress,Component,didPushOwnContextIfProvider){{if(didPushOwnContextIfProvider&&isContextProvider(Component)){// If the fiber is a context provider itself, when we read its context
// we may have already pushed its own child context on the stack. A context
// provider should not "see" its own child context. Therefore we read the
// previous (parent) context instead for a context provider.
return previousContext;}return contextStackCursor.current;}}function cacheContext(workInProgress,unmaskedContext,maskedContext){{var instance=workInProgress.stateNode;instance.__reactInternalMemoizedUnmaskedChildContext=unmaskedContext;instance.__reactInternalMemoizedMaskedChildContext=maskedContext;}}function getMaskedContext(workInProgress,unmaskedContext){{var type=workInProgress.type;var contextTypes=type.contextTypes;if(!contextTypes){return emptyContextObject;}// Avoid recreating masked context unless unmasked context has changed.
// Failing to do this will result in unnecessary calls to componentWillReceiveProps.
// This may trigger infinite loops if componentWillReceiveProps calls setState.
var instance=workInProgress.stateNode;if(instance&&instance.__reactInternalMemoizedUnmaskedChildContext===unmaskedContext){return instance.__reactInternalMemoizedMaskedChildContext;}var context={};for(var key in contextTypes){context[key]=unmaskedContext[key];}{var name=getComponentNameFromFiber(workInProgress)||'Unknown';checkPropTypes(contextTypes,context,'context',name);}// Cache unmasked context so we can avoid recreating masked context unless necessary.
// Context is created before the class component is instantiated so check for instance.
if(instance){cacheContext(workInProgress,unmaskedContext,context);}return context;}}function hasContextChanged(){{return didPerformWorkStackCursor.current;}}function isContextProvider(type){{var childContextTypes=type.childContextTypes;return childContextTypes!==null&&childContextTypes!==undefined;}}function popContext(fiber){{pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}}function popTopLevelContextObject(fiber){{pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}}function pushTopLevelContextObject(fiber,context,didChange){{if(contextStackCursor.current!==emptyContextObject){throw new Error('Unexpected context found on stack. '+'This error is likely caused by a bug in React. Please file an issue.');}push(contextStackCursor,context,fiber);push(didPerformWorkStackCursor,didChange,fiber);}}function processChildContext(fiber,type,parentContext){{var instance=fiber.stateNode;var childContextTypes=type.childContextTypes;// TODO (bvaughn) Replace this behavior with an invariant() in the future.
// It has only been added in Fiber to match the (unintentional) behavior in Stack.
if(typeof instance.getChildContext!=='function'){{var componentName=getComponentNameFromFiber(fiber)||'Unknown';if(!warnedAboutMissingGetChildContext[componentName]){warnedAboutMissingGetChildContext[componentName]=true;error('%s.childContextTypes is specified but there is no getChildContext() method '+'on the instance. You can either define getChildContext() on %s or remove '+'childContextTypes from it.',componentName,componentName);}}return parentContext;}var childContext=instance.getChildContext();for(var contextKey in childContext){if(!(contextKey in childContextTypes)){throw new Error((getComponentNameFromFiber(fiber)||'Unknown')+".getChildContext(): key \""+contextKey+"\" is not defined in childContextTypes.");}}{var name=getComponentNameFromFiber(fiber)||'Unknown';checkPropTypes(childContextTypes,childContext,'child context',name);}return assign({},parentContext,childContext);}}function pushContextProvider(workInProgress){{var instance=workInProgress.stateNode;// We push the context as early as possible to ensure stack integrity.
// If the instance does not exist yet, we will push null at first,
// and replace it on the stack later when invalidating the context.
var memoizedMergedChildContext=instance&&instance.__reactInternalMemoizedMergedChildContext||emptyContextObject;// Remember the parent context so we can merge with it later.
// Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
previousContext=contextStackCursor.current;push(contextStackCursor,memoizedMergedChildContext,workInProgress);push(didPerformWorkStackCursor,didPerformWorkStackCursor.current,workInProgress);return true;}}function invalidateContextProvider(workInProgress,type,didChange){{var instance=workInProgress.stateNode;if(!instance){throw new Error('Expected to have an instance by this point. '+'This error is likely caused by a bug in React. Please file an issue.');}if(didChange){// Merge parent and own context.
// Skip this if we're not updating due to sCU.
// This avoids unnecessarily recomputing memoized values.
var mergedContext=processChildContext(workInProgress,type,previousContext);instance.__reactInternalMemoizedMergedChildContext=mergedContext;// Replace the old (or empty) context with the new one.
// It is important to unwind the context in the reverse order.
pop(didPerformWorkStackCursor,workInProgress);pop(contextStackCursor,workInProgress);// Now push the new context and mark that it has changed.
push(contextStackCursor,mergedContext,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}else {pop(didPerformWorkStackCursor,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}}}function findCurrentUnmaskedContext(fiber){{// Currently this is only used with renderSubtreeIntoContainer; not sure if it
// makes sense elsewhere
if(!isFiberMounted(fiber)||fiber.tag!==ClassComponent){throw new Error('Expected subtree parent to be a mounted class component. '+'This error is likely caused by a bug in React. Please file an issue.');}var node=fiber;do{switch(node.tag){case HostRoot:return node.stateNode.context;case ClassComponent:{var Component=node.type;if(isContextProvider(Component)){return node.stateNode.__reactInternalMemoizedMergedChildContext;}break;}}node=node.return;}while(node!==null);throw new Error('Found unexpected detached subtree parent. '+'This error is likely caused by a bug in React. Please file an issue.');}}var LegacyRoot=0;var ConcurrentRoot=1;var syncQueue=null;var includesLegacySyncCallbacks=false;var isFlushingSyncQueue=false;function scheduleSyncCallback(callback){// Push this callback into an internal queue. We'll flush these either in
// the next tick, or earlier if something calls `flushSyncCallbackQueue`.
if(syncQueue===null){syncQueue=[callback];}else {// Push onto existing queue. Don't need to schedule a callback because
// we already scheduled one when we created the queue.
syncQueue.push(callback);}}function scheduleLegacySyncCallback(callback){includesLegacySyncCallbacks=true;scheduleSyncCallback(callback);}function flushSyncCallbacksOnlyInLegacyMode(){// Only flushes the queue if there's a legacy sync callback scheduled.
// TODO: There's only a single type of callback: performSyncOnWorkOnRoot. So
// it might make more sense for the queue to be a list of roots instead of a
// list of generic callbacks. Then we can have two: one for legacy roots, one
// for concurrent roots. And this method would only flush the legacy ones.
if(includesLegacySyncCallbacks){flushSyncCallbacks();}}function flushSyncCallbacks(){if(!isFlushingSyncQueue&&syncQueue!==null){// Prevent re-entrance.
isFlushingSyncQueue=true;var i=0;var previousUpdatePriority=getCurrentUpdatePriority();try{var isSync=true;var queue=syncQueue;// TODO: Is this necessary anymore? The only user code that runs in this
// queue is in the render or commit phases.
setCurrentUpdatePriority(DiscreteEventPriority);for(;i<queue.length;i++){var callback=queue[i];do{callback=callback(isSync);}while(callback!==null);}syncQueue=null;includesLegacySyncCallbacks=false;}catch(error){// If something throws, leave the remaining callbacks on the queue.
if(syncQueue!==null){syncQueue=syncQueue.slice(i+1);}// Resume flushing in the next tick
scheduleCallback(ImmediatePriority,flushSyncCallbacks);throw error;}finally{setCurrentUpdatePriority(previousUpdatePriority);isFlushingSyncQueue=false;}}return null;}// TODO: Use the unified fiber stack module instead of this local one?
// Intentionally not using it yet to derisk the initial implementation, because
// the way we push/pop these values is a bit unusual. If there's a mistake, I'd
// rather the ids be wrong than crash the whole reconciler.
var forkStack=[];var forkStackIndex=0;var treeForkProvider=null;var treeForkCount=0;var idStack=[];var idStackIndex=0;var treeContextProvider=null;var treeContextId=1;var treeContextOverflow='';function isForkedChild(workInProgress){warnIfNotHydrating();return (workInProgress.flags&Forked)!==NoFlags;}function getForksAtLevel(workInProgress){warnIfNotHydrating();return treeForkCount;}function getTreeId(){var overflow=treeContextOverflow;var idWithLeadingBit=treeContextId;var id=idWithLeadingBit&~getLeadingBit(idWithLeadingBit);return id.toString(32)+overflow;}function pushTreeFork(workInProgress,totalChildren){// This is called right after we reconcile an array (or iterator) of child
// fibers, because that's the only place where we know how many children in
// the whole set without doing extra work later, or storing addtional
// information on the fiber.
//
// That's why this function is separate from pushTreeId — it's called during
// the render phase of the fork parent, not the child, which is where we push
// the other context values.
//
// In the Fizz implementation this is much simpler because the child is
// rendered in the same callstack as the parent.
//
// It might be better to just add a `forks` field to the Fiber type. It would
// make this module simpler.
warnIfNotHydrating();forkStack[forkStackIndex++]=treeForkCount;forkStack[forkStackIndex++]=treeForkProvider;treeForkProvider=workInProgress;treeForkCount=totalChildren;}function pushTreeId(workInProgress,totalChildren,index){warnIfNotHydrating();idStack[idStackIndex++]=treeContextId;idStack[idStackIndex++]=treeContextOverflow;idStack[idStackIndex++]=treeContextProvider;treeContextProvider=workInProgress;var baseIdWithLeadingBit=treeContextId;var baseOverflow=treeContextOverflow;// The leftmost 1 marks the end of the sequence, non-inclusive. It's not part
// of the id; we use it to account for leading 0s.
var baseLength=getBitLength(baseIdWithLeadingBit)-1;var baseId=baseIdWithLeadingBit&~(1<<baseLength);var slot=index+1;var length=getBitLength(totalChildren)+baseLength;// 30 is the max length we can store without overflowing, taking into
// consideration the leading 1 we use to mark the end of the sequence.
if(length>30){// We overflowed the bitwise-safe range. Fall back to slower algorithm.
// This branch assumes the length of the base id is greater than 5; it won't
// work for smaller ids, because you need 5 bits per character.
//
// We encode the id in multiple steps: first the base id, then the
// remaining digits.
//
// Each 5 bit sequence corresponds to a single base 32 character. So for
// example, if the current id is 23 bits long, we can convert 20 of those
// bits into a string of 4 characters, with 3 bits left over.
//
// First calculate how many bits in the base id represent a complete
// sequence of characters.
var numberOfOverflowBits=baseLength-baseLength%5;// Then create a bitmask that selects only those bits.
var newOverflowBits=(1<<numberOfOverflowBits)-1;// Select the bits, and convert them to a base 32 string.
var newOverflow=(baseId&newOverflowBits).toString(32);// Now we can remove those bits from the base id.
var restOfBaseId=baseId>>numberOfOverflowBits;var restOfBaseLength=baseLength-numberOfOverflowBits;// Finally, encode the rest of the bits using the normal algorithm. Because
// we made more room, this time it won't overflow.
var restOfLength=getBitLength(totalChildren)+restOfBaseLength;var restOfNewBits=slot<<restOfBaseLength;var id=restOfNewBits|restOfBaseId;var overflow=newOverflow+baseOverflow;treeContextId=1<<restOfLength|id;treeContextOverflow=overflow;}else {// Normal path
var newBits=slot<<baseLength;var _id=newBits|baseId;var _overflow=baseOverflow;treeContextId=1<<length|_id;treeContextOverflow=_overflow;}}function pushMaterializedTreeId(workInProgress){warnIfNotHydrating();// This component materialized an id. This will affect any ids that appear
// in its children.
var returnFiber=workInProgress.return;if(returnFiber!==null){var numberOfForks=1;var slotIndex=0;pushTreeFork(workInProgress,numberOfForks);pushTreeId(workInProgress,numberOfForks,slotIndex);}}function getBitLength(number){return 32-clz32(number);}function getLeadingBit(id){return 1<<getBitLength(id)-1;}function popTreeContext(workInProgress){// Restore the previous values.
// This is a bit more complicated than other context-like modules in Fiber
// because the same Fiber may appear on the stack multiple times and for
// different reasons. We have to keep popping until the work-in-progress is
// no longer at the top of the stack.
while(workInProgress===treeForkProvider){treeForkProvider=forkStack[--forkStackIndex];forkStack[forkStackIndex]=null;treeForkCount=forkStack[--forkStackIndex];forkStack[forkStackIndex]=null;}while(workInProgress===treeContextProvider){treeContextProvider=idStack[--idStackIndex];idStack[idStackIndex]=null;treeContextOverflow=idStack[--idStackIndex];idStack[idStackIndex]=null;treeContextId=idStack[--idStackIndex];idStack[idStackIndex]=null;}}function getSuspendedTreeContext(){warnIfNotHydrating();if(treeContextProvider!==null){return {id:treeContextId,overflow:treeContextOverflow};}else {return null;}}function restoreSuspendedTreeContext(workInProgress,suspendedContext){warnIfNotHydrating();idStack[idStackIndex++]=treeContextId;idStack[idStackIndex++]=treeContextOverflow;idStack[idStackIndex++]=treeContextProvider;treeContextId=suspendedContext.id;treeContextOverflow=suspendedContext.overflow;treeContextProvider=workInProgress;}function warnIfNotHydrating(){{if(!getIsHydrating()){error('Expected to be hydrating. This is a bug in React. Please file '+'an issue.');}}}// This may have been an insertion or a hydration.
var hydrationParentFiber=null;var nextHydratableInstance=null;var isHydrating=false;// This flag allows for warning supression when we expect there to be mismatches
// due to earlier mismatches or a suspended fiber.
var didSuspendOrErrorDEV=false;// Hydration errors that were thrown inside this boundary
var hydrationErrors=null;function warnIfHydrating(){{if(isHydrating){error('We should not be hydrating here. This is a bug in React. Please file a bug.');}}}function markDidThrowWhileHydratingDEV(){{didSuspendOrErrorDEV=true;}}function didSuspendOrErrorWhileHydratingDEV(){{return didSuspendOrErrorDEV;}}function enterHydrationState(fiber){var parentInstance=fiber.stateNode.containerInfo;nextHydratableInstance=getFirstHydratableChildWithinContainer(parentInstance);hydrationParentFiber=fiber;isHydrating=true;hydrationErrors=null;didSuspendOrErrorDEV=false;return true;}function reenterHydrationStateFromDehydratedSuspenseInstance(fiber,suspenseInstance,treeContext){nextHydratableInstance=getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);hydrationParentFiber=fiber;isHydrating=true;hydrationErrors=null;didSuspendOrErrorDEV=false;if(treeContext!==null){restoreSuspendedTreeContext(fiber,treeContext);}return true;}function warnUnhydratedInstance(returnFiber,instance){{switch(returnFiber.tag){case HostRoot:{didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo,instance);break;}case HostComponent:{var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotHydrateInstance(returnFiber.type,returnFiber.memoizedProps,returnFiber.stateNode,instance,// TODO: Delete this argument when we remove the legacy root API.
isConcurrentMode);break;}case SuspenseComponent:{var suspenseState=returnFiber.memoizedState;if(suspenseState.dehydrated!==null)didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated,instance);break;}}}}function deleteHydratableInstance(returnFiber,instance){warnUnhydratedInstance(returnFiber,instance);var childToDelete=createFiberFromHostInstanceForDeletion();childToDelete.stateNode=instance;childToDelete.return=returnFiber;var deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[childToDelete];returnFiber.flags|=ChildDeletion;}else {deletions.push(childToDelete);}}function warnNonhydratedInstance(returnFiber,fiber){{if(didSuspendOrErrorDEV){// Inside a boundary that already suspended. We're currently rendering the
// siblings of a suspended node. The mismatch may be due to the missing
// data, so it's probably a false positive.
return;}switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;switch(fiber.tag){case HostComponent:var type=fiber.type;fiber.pendingProps;didNotFindHydratableInstanceWithinContainer(parentContainer,type);break;case HostText:var text=fiber.pendingProps;didNotFindHydratableTextInstanceWithinContainer(parentContainer,text);break;}break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;switch(fiber.tag){case HostComponent:{var _type=fiber.type;var _props=fiber.pendingProps;var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotFindHydratableInstance(parentType,parentProps,parentInstance,_type,_props,// TODO: Delete this argument when we remove the legacy root API.
isConcurrentMode);break;}case HostText:{var _text=fiber.pendingProps;var _isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,_text,// TODO: Delete this argument when we remove the legacy root API.
_isConcurrentMode);break;}}break;}case SuspenseComponent:{var suspenseState=returnFiber.memoizedState;var _parentInstance=suspenseState.dehydrated;if(_parentInstance!==null)switch(fiber.tag){case HostComponent:var _type2=fiber.type;fiber.pendingProps;didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance,_type2);break;case HostText:var _text2=fiber.pendingProps;didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance,_text2);break;}break;}default:return;}}}function insertNonHydratedInstance(returnFiber,fiber){fiber.flags=fiber.flags&~Hydrating|Placement;warnNonhydratedInstance(returnFiber,fiber);}function tryHydrate(fiber,nextInstance){switch(fiber.tag){case HostComponent:{var type=fiber.type;fiber.pendingProps;var instance=canHydrateInstance(nextInstance,type);if(instance!==null){fiber.stateNode=instance;hydrationParentFiber=fiber;nextHydratableInstance=getFirstHydratableChild(instance);return true;}return false;}case HostText:{var text=fiber.pendingProps;var textInstance=canHydrateTextInstance(nextInstance,text);if(textInstance!==null){fiber.stateNode=textInstance;hydrationParentFiber=fiber;// Text Instances don't have children so there's nothing to hydrate.
nextHydratableInstance=null;return true;}return false;}case SuspenseComponent:{var suspenseInstance=canHydrateSuspenseInstance(nextInstance);if(suspenseInstance!==null){var suspenseState={dehydrated:suspenseInstance,treeContext:getSuspendedTreeContext(),retryLane:OffscreenLane};fiber.memoizedState=suspenseState;// Store the dehydrated fragment as a child fiber.
// This simplifies the code for getHostSibling and deleting nodes,
// since it doesn't have to consider all Suspense boundaries and
// check if they're dehydrated ones or not.
var dehydratedFragment=createFiberFromDehydratedFragment(suspenseInstance);dehydratedFragment.return=fiber;fiber.child=dehydratedFragment;hydrationParentFiber=fiber;// While a Suspense Instance does have children, we won't step into
// it during the first pass. Instead, we'll reenter it later.
nextHydratableInstance=null;return true;}return false;}default:return false;}}function shouldClientRenderOnMismatch(fiber){return (fiber.mode&ConcurrentMode)!==NoMode&&(fiber.flags&DidCapture)===NoFlags;}function throwOnHydrationMismatch(fiber){throw new Error('Hydration failed because the initial UI does not match what was '+'rendered on the server.');}function tryToClaimNextHydratableInstance(fiber){if(!isHydrating){return;}var nextInstance=nextHydratableInstance;if(!nextInstance){if(shouldClientRenderOnMismatch(fiber)){warnNonhydratedInstance(hydrationParentFiber,fiber);throwOnHydrationMismatch();}// Nothing to hydrate. Make it an insertion.
insertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}var firstAttemptedInstance=nextInstance;if(!tryHydrate(fiber,nextInstance)){if(shouldClientRenderOnMismatch(fiber)){warnNonhydratedInstance(hydrationParentFiber,fiber);throwOnHydrationMismatch();}// If we can't hydrate this instance let's try the next one.
// We use this as a heuristic. It's based on intuition and not data so it
// might be flawed or unnecessary.
nextInstance=getNextHydratableSibling(firstAttemptedInstance);var prevHydrationParentFiber=hydrationParentFiber;if(!nextInstance||!tryHydrate(fiber,nextInstance)){// Nothing to hydrate. Make it an insertion.
insertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}// We matched the next one, we'll now assume that the first one was
// superfluous and we'll delete it. Since we can't eagerly delete it
// we'll have to schedule a deletion. To do that, this node needs a dummy
// fiber associated with it.
deleteHydratableInstance(prevHydrationParentFiber,firstAttemptedInstance);}}function prepareToHydrateHostInstance(fiber,rootContainerInstance,hostContext){var instance=fiber.stateNode;var shouldWarnIfMismatchDev=!didSuspendOrErrorDEV;var updatePayload=hydrateInstance(instance,fiber.type,fiber.memoizedProps,rootContainerInstance,hostContext,fiber,shouldWarnIfMismatchDev);// TODO: Type this specific to this type of component.
fiber.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there
// is a new ref we mark this as an update.
if(updatePayload!==null){return true;}return false;}function prepareToHydrateHostTextInstance(fiber){var textInstance=fiber.stateNode;var textContent=fiber.memoizedProps;var shouldUpdate=hydrateTextInstance(textInstance,textContent,fiber);if(shouldUpdate){// We assume that prepareToHydrateHostTextInstance is called in a context where the
// hydration parent is the parent host component of this host text.
var returnFiber=hydrationParentFiber;if(returnFiber!==null){switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,textContent,// TODO: Delete this argument when we remove the legacy root API.
isConcurrentMode);break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;var _isConcurrentMode2=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,textContent,// TODO: Delete this argument when we remove the legacy root API.
_isConcurrentMode2);break;}}}}return shouldUpdate;}function prepareToHydrateHostSuspenseInstance(fiber){var suspenseState=fiber.memoizedState;var suspenseInstance=suspenseState!==null?suspenseState.dehydrated:null;if(!suspenseInstance){throw new Error('Expected to have a hydrated suspense instance. '+'This error is likely caused by a bug in React. Please file an issue.');}hydrateSuspenseInstance(suspenseInstance,fiber);}function skipPastDehydratedSuspenseInstance(fiber){var suspenseState=fiber.memoizedState;var suspenseInstance=suspenseState!==null?suspenseState.dehydrated:null;if(!suspenseInstance){throw new Error('Expected to have a hydrated suspense instance. '+'This error is likely caused by a bug in React. Please file an issue.');}return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);}function popToNextHostParent(fiber){var parent=fiber.return;while(parent!==null&&parent.tag!==HostComponent&&parent.tag!==HostRoot&&parent.tag!==SuspenseComponent){parent=parent.return;}hydrationParentFiber=parent;}function popHydrationState(fiber){if(fiber!==hydrationParentFiber){// We're deeper than the current hydration context, inside an inserted
// tree.
return false;}if(!isHydrating){// If we're not currently hydrating but we're in a hydration context, then
// we were an insertion and now need to pop up reenter hydration of our
// siblings.
popToNextHostParent(fiber);isHydrating=true;return false;}// If we have any remaining hydratable nodes, we need to delete them now.
// We only do this deeper than head and body since they tend to have random
// other nodes in them. We also ignore components with pure text content in
// side of them. We also don't delete anything inside the root container.
if(fiber.tag!==HostRoot&&(fiber.tag!==HostComponent||shouldDeleteUnhydratedTailInstances(fiber.type)&&!shouldSetTextContent(fiber.type,fiber.memoizedProps))){var nextInstance=nextHydratableInstance;if(nextInstance){if(shouldClientRenderOnMismatch(fiber)){warnIfUnhydratedTailNodes(fiber);throwOnHydrationMismatch();}else {while(nextInstance){deleteHydratableInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}}}popToNextHostParent(fiber);if(fiber.tag===SuspenseComponent){nextHydratableInstance=skipPastDehydratedSuspenseInstance(fiber);}else {nextHydratableInstance=hydrationParentFiber?getNextHydratableSibling(fiber.stateNode):null;}return true;}function hasUnhydratedTailNodes(){return isHydrating&&nextHydratableInstance!==null;}function warnIfUnhydratedTailNodes(fiber){var nextInstance=nextHydratableInstance;while(nextInstance){warnUnhydratedInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}function resetHydrationState(){hydrationParentFiber=null;nextHydratableInstance=null;isHydrating=false;didSuspendOrErrorDEV=false;}function upgradeHydrationErrorsToRecoverable(){if(hydrationErrors!==null){// Successfully completed a forced client render. The errors that occurred
// during the hydration attempt are now recovered. We will log them in
// commit phase, once the entire tree has finished.
queueRecoverableErrors(hydrationErrors);hydrationErrors=null;}}function getIsHydrating(){return isHydrating;}function queueHydrationError(error){if(hydrationErrors===null){hydrationErrors=[error];}else {hydrationErrors.push(error);}}var ReactCurrentBatchConfig$1=ReactSharedInternals.ReactCurrentBatchConfig;var NoTransition=null;function requestCurrentTransition(){return ReactCurrentBatchConfig$1.transition;}var ReactStrictModeWarnings={recordUnsafeLifecycleWarnings:function(fiber,instance){},flushPendingUnsafeLifecycleWarnings:function(){},recordLegacyContextWarning:function(fiber,instance){},flushLegacyContextWarning:function(){},discardPendingWarnings:function(){}};{var findStrictRoot=function(fiber){var maybeStrictRoot=null;var node=fiber;while(node!==null){if(node.mode&StrictLegacyMode){maybeStrictRoot=node;}node=node.return;}return maybeStrictRoot;};var setToSortedString=function(set){var array=[];set.forEach(function(value){array.push(value);});return array.sort().join(', ');};var pendingComponentWillMountWarnings=[];var pendingUNSAFE_ComponentWillMountWarnings=[];var pendingComponentWillReceivePropsWarnings=[];var pendingUNSAFE_ComponentWillReceivePropsWarnings=[];var pendingComponentWillUpdateWarnings=[];var pendingUNSAFE_ComponentWillUpdateWarnings=[];// Tracks components we have already warned about.
var didWarnAboutUnsafeLifecycles=new Set();ReactStrictModeWarnings.recordUnsafeLifecycleWarnings=function(fiber,instance){// Dedupe strategy: Warn once per component.
if(didWarnAboutUnsafeLifecycles.has(fiber.type)){return;}if(typeof instance.componentWillMount==='function'&&// Don't warn about react-lifecycles-compat polyfilled components.
instance.componentWillMount.__suppressDeprecationWarning!==true){pendingComponentWillMountWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillMount==='function'){pendingUNSAFE_ComponentWillMountWarnings.push(fiber);}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){pendingComponentWillReceivePropsWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillReceiveProps==='function'){pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){pendingComponentWillUpdateWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillUpdate==='function'){pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);}};ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings=function(){// We do an initial pass to gather component names
var componentWillMountUniqueNames=new Set();if(pendingComponentWillMountWarnings.length>0){pendingComponentWillMountWarnings.forEach(function(fiber){componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillMountWarnings=[];}var UNSAFE_componentWillMountUniqueNames=new Set();if(pendingUNSAFE_ComponentWillMountWarnings.length>0){pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber){UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillMountWarnings=[];}var componentWillReceivePropsUniqueNames=new Set();if(pendingComponentWillReceivePropsWarnings.length>0){pendingComponentWillReceivePropsWarnings.forEach(function(fiber){componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillReceivePropsWarnings=[];}var UNSAFE_componentWillReceivePropsUniqueNames=new Set();if(pendingUNSAFE_ComponentWillReceivePropsWarnings.length>0){pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber){UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillReceivePropsWarnings=[];}var componentWillUpdateUniqueNames=new Set();if(pendingComponentWillUpdateWarnings.length>0){pendingComponentWillUpdateWarnings.forEach(function(fiber){componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillUpdateWarnings=[];}var UNSAFE_componentWillUpdateUniqueNames=new Set();if(pendingUNSAFE_ComponentWillUpdateWarnings.length>0){pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber){UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillUpdateWarnings=[];}// Finally, we flush all the warnings
// UNSAFE_ ones before the deprecated ones, since they'll be 'louder'
if(UNSAFE_componentWillMountUniqueNames.size>0){var sortedNames=setToSortedString(UNSAFE_componentWillMountUniqueNames);error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n'+'* Move code with side effects to componentDidMount, and set initial state in the constructor.\n'+'\nPlease update the following components: %s',sortedNames);}if(UNSAFE_componentWillReceivePropsUniqueNames.size>0){var _sortedNames=setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended '+'and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n'+'* Move data fetching code or side effects to componentDidUpdate.\n'+"* If you're updating state whenever props change, "+'refactor your code to use memoization techniques or move it to '+'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n'+'\nPlease update the following components: %s',_sortedNames);}if(UNSAFE_componentWillUpdateUniqueNames.size>0){var _sortedNames2=setToSortedString(UNSAFE_componentWillUpdateUniqueNames);error('Using UNSAFE_componentWillUpdate in strict mode is not recommended '+'and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n'+'* Move data fetching code or side effects to componentDidUpdate.\n'+'\nPlease update the following components: %s',_sortedNames2);}if(componentWillMountUniqueNames.size>0){var _sortedNames3=setToSortedString(componentWillMountUniqueNames);warn('componentWillMount has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n'+'* Move code with side effects to componentDidMount, and set initial state in the constructor.\n'+'* Rename componentWillMount to UNSAFE_componentWillMount to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n'+'\nPlease update the following components: %s',_sortedNames3);}if(componentWillReceivePropsUniqueNames.size>0){var _sortedNames4=setToSortedString(componentWillReceivePropsUniqueNames);warn('componentWillReceiveProps has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n'+'* Move data fetching code or side effects to componentDidUpdate.\n'+"* If you're updating state whenever props change, refactor your "+'code to use memoization techniques or move it to '+'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n'+'* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n'+'\nPlease update the following components: %s',_sortedNames4);}if(componentWillUpdateUniqueNames.size>0){var _sortedNames5=setToSortedString(componentWillUpdateUniqueNames);warn('componentWillUpdate has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n'+'* Move data fetching code or side effects to componentDidUpdate.\n'+'* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n'+'\nPlease update the following components: %s',_sortedNames5);}};var pendingLegacyContextWarning=new Map();// Tracks components we have already warned about.
var didWarnAboutLegacyContext=new Set();ReactStrictModeWarnings.recordLegacyContextWarning=function(fiber,instance){var strictRoot=findStrictRoot(fiber);if(strictRoot===null){error('Expected to find a StrictMode component in a strict mode tree. '+'This error is likely caused by a bug in React. Please file an issue.');return;}// Dedup strategy: Warn once per component.
if(didWarnAboutLegacyContext.has(fiber.type)){return;}var warningsForRoot=pendingLegacyContextWarning.get(strictRoot);if(fiber.type.contextTypes!=null||fiber.type.childContextTypes!=null||instance!==null&&typeof instance.getChildContext==='function'){if(warningsForRoot===undefined){warningsForRoot=[];pendingLegacyContextWarning.set(strictRoot,warningsForRoot);}warningsForRoot.push(fiber);}};ReactStrictModeWarnings.flushLegacyContextWarning=function(){pendingLegacyContextWarning.forEach(function(fiberArray,strictRoot){if(fiberArray.length===0){return;}var firstFiber=fiberArray[0];var uniqueNames=new Set();fiberArray.forEach(function(fiber){uniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutLegacyContext.add(fiber.type);});var sortedNames=setToSortedString(uniqueNames);try{setCurrentFiber(firstFiber);error('Legacy context API has been detected within a strict-mode tree.'+'\n\nThe old API will be supported in all 16.x releases, but applications '+'using it should migrate to the new version.'+'\n\nPlease update the following components: %s'+'\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context',sortedNames);}finally{resetCurrentFiber();}});};ReactStrictModeWarnings.discardPendingWarnings=function(){pendingComponentWillMountWarnings=[];pendingUNSAFE_ComponentWillMountWarnings=[];pendingComponentWillReceivePropsWarnings=[];pendingUNSAFE_ComponentWillReceivePropsWarnings=[];pendingComponentWillUpdateWarnings=[];pendingUNSAFE_ComponentWillUpdateWarnings=[];pendingLegacyContextWarning=new Map();};}function resolveDefaultProps(Component,baseProps){if(Component&&Component.defaultProps){// Resolve default props. Taken from ReactElement
var props=assign({},baseProps);var defaultProps=Component.defaultProps;for(var propName in defaultProps){if(props[propName]===undefined){props[propName]=defaultProps[propName];}}return props;}return baseProps;}var valueCursor=createCursor(null);var rendererSigil;{// Use this to detect multiple renderers using the same context
rendererSigil={};}var currentlyRenderingFiber=null;var lastContextDependency=null;var lastFullyObservedContext=null;var isDisallowedContextReadInDEV=false;function resetContextDependencies(){// This is called right before React yields execution, to ensure `readContext`
// cannot be called outside the render phase.
currentlyRenderingFiber=null;lastContextDependency=null;lastFullyObservedContext=null;{isDisallowedContextReadInDEV=false;}}function enterDisallowedContextReadInDEV(){{isDisallowedContextReadInDEV=true;}}function exitDisallowedContextReadInDEV(){{isDisallowedContextReadInDEV=false;}}function pushProvider(providerFiber,context,nextValue){{push(valueCursor,context._currentValue,providerFiber);context._currentValue=nextValue;{if(context._currentRenderer!==undefined&&context._currentRenderer!==null&&context._currentRenderer!==rendererSigil){error('Detected multiple renderers concurrently rendering the '+'same context provider. This is currently unsupported.');}context._currentRenderer=rendererSigil;}}}function popProvider(context,providerFiber){var currentValue=valueCursor.current;pop(valueCursor,providerFiber);{{context._currentValue=currentValue;}}}function scheduleContextWorkOnParentPath(parent,renderLanes,propagationRoot){// Update the child lanes of all the ancestors, including the alternates.
var node=parent;while(node!==null){var alternate=node.alternate;if(!isSubsetOfLanes(node.childLanes,renderLanes)){node.childLanes=mergeLanes(node.childLanes,renderLanes);if(alternate!==null){alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes);}}else if(alternate!==null&&!isSubsetOfLanes(alternate.childLanes,renderLanes)){alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes);}if(node===propagationRoot){break;}node=node.return;}{if(node!==propagationRoot){error('Expected to find the propagation root when scheduling context work. '+'This error is likely caused by a bug in React. Please file an issue.');}}}function propagateContextChange(workInProgress,context,renderLanes){{propagateContextChange_eager(workInProgress,context,renderLanes);}}function propagateContextChange_eager(workInProgress,context,renderLanes){var fiber=workInProgress.child;if(fiber!==null){// Set the return pointer of the child to the work-in-progress fiber.
fiber.return=workInProgress;}while(fiber!==null){var nextFiber=void 0;// Visit this fiber.
var list=fiber.dependencies;if(list!==null){nextFiber=fiber.child;var dependency=list.firstContext;while(dependency!==null){// Check if the context matches.
if(dependency.context===context){// Match! Schedule an update on this fiber.
if(fiber.tag===ClassComponent){// Schedule a force update on the work-in-progress.
var lane=pickArbitraryLane(renderLanes);var update=createUpdate(NoTimestamp,lane);update.tag=ForceUpdate;// TODO: Because we don't have a work-in-progress, this will add the
// update to the current fiber, too, which means it will persist even if
// this render is thrown away. Since it's a race condition, not sure it's
// worth fixing.
// Inlined `enqueueUpdate` to remove interleaved update check
var updateQueue=fiber.updateQueue;if(updateQueue===null);else {var sharedQueue=updateQueue.shared;var pending=sharedQueue.pending;if(pending===null){// This is the first update. Create a circular list.
update.next=update;}else {update.next=pending.next;pending.next=update;}sharedQueue.pending=update;}}fiber.lanes=mergeLanes(fiber.lanes,renderLanes);var alternate=fiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,renderLanes);}scheduleContextWorkOnParentPath(fiber.return,renderLanes,workInProgress);// Mark the updated lanes on the list, too.
list.lanes=mergeLanes(list.lanes,renderLanes);// Since we already found a match, we can stop traversing the
// dependency list.
break;}dependency=dependency.next;}}else if(fiber.tag===ContextProvider){// Don't scan deeper if this is a matching provider
nextFiber=fiber.type===workInProgress.type?null:fiber.child;}else if(fiber.tag===DehydratedFragment){// If a dehydrated suspense boundary is in this subtree, we don't know
// if it will have any context consumers in it. The best we can do is
// mark it as having updates.
var parentSuspense=fiber.return;if(parentSuspense===null){throw new Error('We just came from a parent so we must have had a parent. This is a bug in React.');}parentSuspense.lanes=mergeLanes(parentSuspense.lanes,renderLanes);var _alternate=parentSuspense.alternate;if(_alternate!==null){_alternate.lanes=mergeLanes(_alternate.lanes,renderLanes);}// This is intentionally passing this fiber as the parent
// because we want to schedule this fiber as having work
// on its children. We'll use the childLanes on
// this fiber to indicate that a context has changed.
scheduleContextWorkOnParentPath(parentSuspense,renderLanes,workInProgress);nextFiber=fiber.sibling;}else {// Traverse down.
nextFiber=fiber.child;}if(nextFiber!==null){// Set the return pointer of the child to the work-in-progress fiber.
nextFiber.return=fiber;}else {// No child. Traverse to next sibling.
nextFiber=fiber;while(nextFiber!==null){if(nextFiber===workInProgress){// We're back to the root of this subtree. Exit.
nextFiber=null;break;}var sibling=nextFiber.sibling;if(sibling!==null){// Set the return pointer of the sibling to the work-in-progress fiber.
sibling.return=nextFiber.return;nextFiber=sibling;break;}// No more siblings. Traverse up.
nextFiber=nextFiber.return;}}fiber=nextFiber;}}function prepareToReadContext(workInProgress,renderLanes){currentlyRenderingFiber=workInProgress;lastContextDependency=null;lastFullyObservedContext=null;var dependencies=workInProgress.dependencies;if(dependencies!==null){{var firstContext=dependencies.firstContext;if(firstContext!==null){if(includesSomeLane(dependencies.lanes,renderLanes)){// Context list has a pending update. Mark that this fiber performed work.
markWorkInProgressReceivedUpdate();}// Reset the work-in-progress list
dependencies.firstContext=null;}}}}function readContext(context){{// This warning would fire if you read context inside a Hook like useMemo.
// Unlike the class check below, it's not enforced in production for perf.
if(isDisallowedContextReadInDEV){error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');}}var value=context._currentValue;if(lastFullyObservedContext===context);else {var contextItem={context:context,memoizedValue:value,next:null};if(lastContextDependency===null){if(currentlyRenderingFiber===null){throw new Error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');}// This is the first dependency for this component. Create a new list.
lastContextDependency=contextItem;currentlyRenderingFiber.dependencies={lanes:NoLanes,firstContext:contextItem};}else {// Append a new context item.
lastContextDependency=lastContextDependency.next=contextItem;}}return value;}// render. When this render exits, either because it finishes or because it is
// interrupted, the interleaved updates will be transferred onto the main part
// of the queue.
var concurrentQueues=null;function pushConcurrentUpdateQueue(queue){if(concurrentQueues===null){concurrentQueues=[queue];}else {concurrentQueues.push(queue);}}function finishQueueingConcurrentUpdates(){// Transfer the interleaved updates onto the main queue. Each queue has a
// `pending` field and an `interleaved` field. When they are not null, they
// point to the last node in a circular linked list. We need to append the
// interleaved list to the end of the pending list by joining them into a
// single, circular list.
if(concurrentQueues!==null){for(var i=0;i<concurrentQueues.length;i++){var queue=concurrentQueues[i];var lastInterleavedUpdate=queue.interleaved;if(lastInterleavedUpdate!==null){queue.interleaved=null;var firstInterleavedUpdate=lastInterleavedUpdate.next;var lastPendingUpdate=queue.pending;if(lastPendingUpdate!==null){var firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=firstInterleavedUpdate;lastInterleavedUpdate.next=firstPendingUpdate;}queue.pending=lastInterleavedUpdate;}}concurrentQueues=null;}}function enqueueConcurrentHookUpdate(fiber,queue,update,lane){var interleaved=queue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.
update.next=update;// At the end of the current render, this queue's interleaved updates will
// be transferred to the pending queue.
pushConcurrentUpdateQueue(queue);}else {update.next=interleaved.next;interleaved.next=update;}queue.interleaved=update;return markUpdateLaneFromFiberToRoot(fiber,lane);}function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber,queue,update,lane){var interleaved=queue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.
update.next=update;// At the end of the current render, this queue's interleaved updates will
// be transferred to the pending queue.
pushConcurrentUpdateQueue(queue);}else {update.next=interleaved.next;interleaved.next=update;}queue.interleaved=update;}function enqueueConcurrentClassUpdate(fiber,queue,update,lane){var interleaved=queue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.
update.next=update;// At the end of the current render, this queue's interleaved updates will
// be transferred to the pending queue.
pushConcurrentUpdateQueue(queue);}else {update.next=interleaved.next;interleaved.next=update;}queue.interleaved=update;return markUpdateLaneFromFiberToRoot(fiber,lane);}function enqueueConcurrentRenderForLane(fiber,lane){return markUpdateLaneFromFiberToRoot(fiber,lane);}// Calling this function outside this module should only be done for backwards
// compatibility and should always be accompanied by a warning.
var unsafe_markUpdateLaneFromFiberToRoot=markUpdateLaneFromFiberToRoot;function markUpdateLaneFromFiberToRoot(sourceFiber,lane){// Update the source fiber's lanes
sourceFiber.lanes=mergeLanes(sourceFiber.lanes,lane);var alternate=sourceFiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,lane);}{if(alternate===null&&(sourceFiber.flags&(Placement|Hydrating))!==NoFlags){warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);}}// Walk the parent path to the root and update the child lanes.
var node=sourceFiber;var parent=sourceFiber.return;while(parent!==null){parent.childLanes=mergeLanes(parent.childLanes,lane);alternate=parent.alternate;if(alternate!==null){alternate.childLanes=mergeLanes(alternate.childLanes,lane);}else {{if((parent.flags&(Placement|Hydrating))!==NoFlags){warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);}}}node=parent;parent=parent.return;}if(node.tag===HostRoot){var root=node.stateNode;return root;}else {return null;}}var UpdateState=0;var ReplaceState=1;var ForceUpdate=2;var CaptureUpdate=3;// Global state that is reset at the beginning of calling `processUpdateQueue`.
// It should only be read right after calling `processUpdateQueue`, via
// `checkHasForceUpdateAfterProcessing`.
var hasForceUpdate=false;var didWarnUpdateInsideUpdate;var currentlyProcessingQueue;{didWarnUpdateInsideUpdate=false;currentlyProcessingQueue=null;}function initializeUpdateQueue(fiber){var queue={baseState:fiber.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:NoLanes},effects:null};fiber.updateQueue=queue;}function cloneUpdateQueue(current,workInProgress){// Clone the update queue from current. Unless it's already a clone.
var queue=workInProgress.updateQueue;var currentQueue=current.updateQueue;if(queue===currentQueue){var clone={baseState:currentQueue.baseState,firstBaseUpdate:currentQueue.firstBaseUpdate,lastBaseUpdate:currentQueue.lastBaseUpdate,shared:currentQueue.shared,effects:currentQueue.effects};workInProgress.updateQueue=clone;}}function createUpdate(eventTime,lane){var update={eventTime:eventTime,lane:lane,tag:UpdateState,payload:null,callback:null,next:null};return update;}function enqueueUpdate(fiber,update,lane){var updateQueue=fiber.updateQueue;if(updateQueue===null){// Only occurs if the fiber has been unmounted.
return null;}var sharedQueue=updateQueue.shared;{if(currentlyProcessingQueue===sharedQueue&&!didWarnUpdateInsideUpdate){error('An update (setState, replaceState, or forceUpdate) was scheduled '+'from inside an update function. Update functions should be pure, '+'with zero side-effects. Consider using componentDidUpdate or a '+'callback.');didWarnUpdateInsideUpdate=true;}}if(isUnsafeClassRenderPhaseUpdate()){// This is an unsafe render phase update. Add directly to the update
// queue so we can process it immediately during the current render.
var pending=sharedQueue.pending;if(pending===null){// This is the first update. Create a circular list.
update.next=update;}else {update.next=pending.next;pending.next=update;}sharedQueue.pending=update;// Update the childLanes even though we're most likely already rendering
// this fiber. This is for backwards compatibility in the case where you
// update a different component during render phase than the one that is
// currently renderings (a pattern that is accompanied by a warning).
return unsafe_markUpdateLaneFromFiberToRoot(fiber,lane);}else {return enqueueConcurrentClassUpdate(fiber,sharedQueue,update,lane);}}function entangleTransitions(root,fiber,lane){var updateQueue=fiber.updateQueue;if(updateQueue===null){// Only occurs if the fiber has been unmounted.
return;}var sharedQueue=updateQueue.shared;if(isTransitionLane(lane)){var queueLanes=sharedQueue.lanes;// If any entangled lanes are no longer pending on the root, then they must
// have finished. We can remove them from the shared queue, which represents
// a superset of the actually pending lanes. In some cases we may entangle
// more than we need to, but that's OK. In fact it's worse if we *don't*
// entangle when we should.
queueLanes=intersectLanes(queueLanes,root.pendingLanes);// Entangle the new transition lane with the other transition lanes.
var newQueueLanes=mergeLanes(queueLanes,lane);sharedQueue.lanes=newQueueLanes;// Even if queue.lanes already include lane, we don't know for certain if
// the lane finished since the last time we entangled it. So we need to
// entangle it again, just to be sure.
markRootEntangled(root,newQueueLanes);}}function enqueueCapturedUpdate(workInProgress,capturedUpdate){// Captured updates are updates that are thrown by a child during the render
// phase. They should be discarded if the render is aborted. Therefore,
// we should only put them on the work-in-progress queue, not the current one.
var queue=workInProgress.updateQueue;// Check if the work-in-progress queue is a clone.
var current=workInProgress.alternate;if(current!==null){var currentQueue=current.updateQueue;if(queue===currentQueue){// The work-in-progress queue is the same as current. This happens when
// we bail out on a parent fiber that then captures an error thrown by
// a child. Since we want to append the update only to the work-in
// -progress queue, we need to clone the updates. We usually clone during
// processUpdateQueue, but that didn't happen in this case because we
// skipped over the parent when we bailed out.
var newFirst=null;var newLast=null;var firstBaseUpdate=queue.firstBaseUpdate;if(firstBaseUpdate!==null){// Loop through the updates and clone them.
var update=firstBaseUpdate;do{var clone={eventTime:update.eventTime,lane:update.lane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};if(newLast===null){newFirst=newLast=clone;}else {newLast.next=clone;newLast=clone;}update=update.next;}while(update!==null);// Append the captured update the end of the cloned list.
if(newLast===null){newFirst=newLast=capturedUpdate;}else {newLast.next=capturedUpdate;newLast=capturedUpdate;}}else {// There are no base updates.
newFirst=newLast=capturedUpdate;}queue={baseState:currentQueue.baseState,firstBaseUpdate:newFirst,lastBaseUpdate:newLast,shared:currentQueue.shared,effects:currentQueue.effects};workInProgress.updateQueue=queue;return;}}// Append the update to the end of the list.
var lastBaseUpdate=queue.lastBaseUpdate;if(lastBaseUpdate===null){queue.firstBaseUpdate=capturedUpdate;}else {lastBaseUpdate.next=capturedUpdate;}queue.lastBaseUpdate=capturedUpdate;}function getStateFromUpdate(workInProgress,queue,update,prevState,nextProps,instance){switch(update.tag){case ReplaceState:{var payload=update.payload;if(typeof payload==='function'){// Updater function
{enterDisallowedContextReadInDEV();}var nextState=payload.call(instance,prevState,nextProps);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{payload.call(instance,prevState,nextProps);}finally{setIsStrictModeForDevtools(false);}}exitDisallowedContextReadInDEV();}return nextState;}// State object
return payload;}case CaptureUpdate:{workInProgress.flags=workInProgress.flags&~ShouldCapture|DidCapture;}// Intentional fallthrough
case UpdateState:{var _payload=update.payload;var partialState;if(typeof _payload==='function'){// Updater function
{enterDisallowedContextReadInDEV();}partialState=_payload.call(instance,prevState,nextProps);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{_payload.call(instance,prevState,nextProps);}finally{setIsStrictModeForDevtools(false);}}exitDisallowedContextReadInDEV();}}else {// Partial state object
partialState=_payload;}if(partialState===null||partialState===undefined){// Null and undefined are treated as no-ops.
return prevState;}// Merge the partial state and the previous state.
return assign({},prevState,partialState);}case ForceUpdate:{hasForceUpdate=true;return prevState;}}return prevState;}function processUpdateQueue(workInProgress,props,instance,renderLanes){// This is always non-null on a ClassComponent or HostRoot
var queue=workInProgress.updateQueue;hasForceUpdate=false;{currentlyProcessingQueue=queue.shared;}var firstBaseUpdate=queue.firstBaseUpdate;var lastBaseUpdate=queue.lastBaseUpdate;// Check if there are pending updates. If so, transfer them to the base queue.
var pendingQueue=queue.shared.pending;if(pendingQueue!==null){queue.shared.pending=null;// The pending queue is circular. Disconnect the pointer between first
// and last so that it's non-circular.
var lastPendingUpdate=pendingQueue;var firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=null;// Append pending updates to base queue
if(lastBaseUpdate===null){firstBaseUpdate=firstPendingUpdate;}else {lastBaseUpdate.next=firstPendingUpdate;}lastBaseUpdate=lastPendingUpdate;// If there's a current queue, and it's different from the base queue, then
// we need to transfer the updates to that queue, too. Because the base
// queue is a singly-linked list with no cycles, we can append to both
// lists and take advantage of structural sharing.
// TODO: Pass `current` as argument
var current=workInProgress.alternate;if(current!==null){// This is always non-null on a ClassComponent or HostRoot
var currentQueue=current.updateQueue;var currentLastBaseUpdate=currentQueue.lastBaseUpdate;if(currentLastBaseUpdate!==lastBaseUpdate){if(currentLastBaseUpdate===null){currentQueue.firstBaseUpdate=firstPendingUpdate;}else {currentLastBaseUpdate.next=firstPendingUpdate;}currentQueue.lastBaseUpdate=lastPendingUpdate;}}}// These values may change as we process the queue.
if(firstBaseUpdate!==null){// Iterate through the list of updates to compute the result.
var newState=queue.baseState;// TODO: Don't need to accumulate this. Instead, we can remove renderLanes
// from the original lanes.
var newLanes=NoLanes;var newBaseState=null;var newFirstBaseUpdate=null;var newLastBaseUpdate=null;var update=firstBaseUpdate;do{var updateLane=update.lane;var updateEventTime=update.eventTime;if(!isSubsetOfLanes(renderLanes,updateLane)){// Priority is insufficient. Skip this update. If this is the first
// skipped update, the previous update/state is the new base
// update/state.
var clone={eventTime:updateEventTime,lane:updateLane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};if(newLastBaseUpdate===null){newFirstBaseUpdate=newLastBaseUpdate=clone;newBaseState=newState;}else {newLastBaseUpdate=newLastBaseUpdate.next=clone;}// Update the remaining priority in the queue.
newLanes=mergeLanes(newLanes,updateLane);}else {// This update does have sufficient priority.
if(newLastBaseUpdate!==null){var _clone={eventTime:updateEventTime,// This update is going to be committed so we never want uncommit
// it. Using NoLane works because 0 is a subset of all bitmasks, so
// this will never be skipped by the check above.
lane:NoLane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};newLastBaseUpdate=newLastBaseUpdate.next=_clone;}// Process this update.
newState=getStateFromUpdate(workInProgress,queue,update,newState,props,instance);var callback=update.callback;if(callback!==null&&// If the update was already committed, we should not queue its
// callback again.
update.lane!==NoLane){workInProgress.flags|=Callback;var effects=queue.effects;if(effects===null){queue.effects=[update];}else {effects.push(update);}}}update=update.next;if(update===null){pendingQueue=queue.shared.pending;if(pendingQueue===null){break;}else {// An update was scheduled from inside a reducer. Add the new
// pending updates to the end of the list and keep processing.
var _lastPendingUpdate=pendingQueue;// Intentionally unsound. Pending updates form a circular list, but we
// unravel them when transferring them to the base queue.
var _firstPendingUpdate=_lastPendingUpdate.next;_lastPendingUpdate.next=null;update=_firstPendingUpdate;queue.lastBaseUpdate=_lastPendingUpdate;queue.shared.pending=null;}}}while(true);if(newLastBaseUpdate===null){newBaseState=newState;}queue.baseState=newBaseState;queue.firstBaseUpdate=newFirstBaseUpdate;queue.lastBaseUpdate=newLastBaseUpdate;// Interleaved updates are stored on a separate queue. We aren't going to
// process them during this render, but we do need to track which lanes
// are remaining.
var lastInterleaved=queue.shared.interleaved;if(lastInterleaved!==null){var interleaved=lastInterleaved;do{newLanes=mergeLanes(newLanes,interleaved.lane);interleaved=interleaved.next;}while(interleaved!==lastInterleaved);}else if(firstBaseUpdate===null){// `queue.lanes` is used for entangling transitions. We can set it back to
// zero once the queue is empty.
queue.shared.lanes=NoLanes;}// Set the remaining expiration time to be whatever is remaining in the queue.
// This should be fine because the only two other things that contribute to
// expiration time are props and context. We're already in the middle of the
// begin phase by the time we start processing the queue, so we've already
// dealt with the props. Context in components that specify
// shouldComponentUpdate is tricky; but we'll have to account for
// that regardless.
markSkippedUpdateLanes(newLanes);workInProgress.lanes=newLanes;workInProgress.memoizedState=newState;}{currentlyProcessingQueue=null;}}function callCallback(callback,context){if(typeof callback!=='function'){throw new Error('Invalid argument passed as callback. Expected a function. Instead '+("received: "+callback));}callback.call(context);}function resetHasForceUpdateBeforeProcessing(){hasForceUpdate=false;}function checkHasForceUpdateAfterProcessing(){return hasForceUpdate;}function commitUpdateQueue(finishedWork,finishedQueue,instance){// Commit the effects
var effects=finishedQueue.effects;finishedQueue.effects=null;if(effects!==null){for(var i=0;i<effects.length;i++){var effect=effects[i];var callback=effect.callback;if(callback!==null){effect.callback=null;callCallback(callback,instance);}}}}var fakeInternalInstance={};// React.Component uses a shared frozen object by default.
// We'll use it to determine whether we need to initialize legacy refs.
var emptyRefsObject=new React.Component().refs;var didWarnAboutStateAssignmentForComponent;var didWarnAboutUninitializedState;var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;var didWarnAboutLegacyLifecyclesAndDerivedState;var didWarnAboutUndefinedDerivedState;var warnOnUndefinedDerivedState;var warnOnInvalidCallback;var didWarnAboutDirectlyAssigningPropsToState;var didWarnAboutContextTypeAndContextTypes;var didWarnAboutInvalidateContextType;{didWarnAboutStateAssignmentForComponent=new Set();didWarnAboutUninitializedState=new Set();didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate=new Set();didWarnAboutLegacyLifecyclesAndDerivedState=new Set();didWarnAboutDirectlyAssigningPropsToState=new Set();didWarnAboutUndefinedDerivedState=new Set();didWarnAboutContextTypeAndContextTypes=new Set();didWarnAboutInvalidateContextType=new Set();var didWarnOnInvalidCallback=new Set();warnOnInvalidCallback=function(callback,callerName){if(callback===null||typeof callback==='function'){return;}var key=callerName+'_'+callback;if(!didWarnOnInvalidCallback.has(key)){didWarnOnInvalidCallback.add(key);error('%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);}};warnOnUndefinedDerivedState=function(type,partialState){if(partialState===undefined){var componentName=getComponentNameFromType(type)||'Component';if(!didWarnAboutUndefinedDerivedState.has(componentName)){didWarnAboutUndefinedDerivedState.add(componentName);error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. '+'You have returned undefined.',componentName);}}};// This is so gross but it's at least non-critical and can be removed if
// it causes problems. This is meant to give a nicer error message for
// ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
// ...)) which otherwise throws a "_processChildContext is not a function"
// exception.
Object.defineProperty(fakeInternalInstance,'_processChildContext',{enumerable:false,value:function(){throw new Error('_processChildContext is not available in React 16+. This likely '+'means you have multiple copies of React and are attempting to nest '+'a React 15 tree inside a React 16 tree using '+"unstable_renderSubtreeIntoContainer, which isn't supported. Try "+'to make sure you have only one copy of React (and ideally, switch '+'to ReactDOM.createPortal).');}});Object.freeze(fakeInternalInstance);}function applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,nextProps){var prevState=workInProgress.memoizedState;var partialState=getDerivedStateFromProps(nextProps,prevState);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{// Invoke the function an extra time to help detect side-effects.
partialState=getDerivedStateFromProps(nextProps,prevState);}finally{setIsStrictModeForDevtools(false);}}warnOnUndefinedDerivedState(ctor,partialState);}// Merge the partial state and the previous state.
var memoizedState=partialState===null||partialState===undefined?prevState:assign({},prevState,partialState);workInProgress.memoizedState=memoizedState;// Once the update queue is empty, persist the derived state onto the
// base state.
if(workInProgress.lanes===NoLanes){// Queue is always non-null for classes
var updateQueue=workInProgress.updateQueue;updateQueue.baseState=memoizedState;}}var classComponentUpdater={isMounted:isMounted,enqueueSetState:function(inst,payload,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'setState');}update.callback=callback;}var root=enqueueUpdate(fiber,update,lane);if(root!==null){scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitions(root,fiber,lane);}{markStateUpdateScheduled(fiber,lane);}},enqueueReplaceState:function(inst,payload,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.tag=ReplaceState;update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'replaceState');}update.callback=callback;}var root=enqueueUpdate(fiber,update,lane);if(root!==null){scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitions(root,fiber,lane);}{markStateUpdateScheduled(fiber,lane);}},enqueueForceUpdate:function(inst,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.tag=ForceUpdate;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'forceUpdate');}update.callback=callback;}var root=enqueueUpdate(fiber,update,lane);if(root!==null){scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitions(root,fiber,lane);}{markForceUpdateScheduled(fiber,lane);}}};function checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext){var instance=workInProgress.stateNode;if(typeof instance.shouldComponentUpdate==='function'){var shouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextContext);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{// Invoke the function an extra time to help detect side-effects.
shouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextContext);}finally{setIsStrictModeForDevtools(false);}}if(shouldUpdate===undefined){error('%s.shouldComponentUpdate(): Returned undefined instead of a '+'boolean value. Make sure to return true or false.',getComponentNameFromType(ctor)||'Component');}}return shouldUpdate;}if(ctor.prototype&&ctor.prototype.isPureReactComponent){return !shallowEqual(oldProps,newProps)||!shallowEqual(oldState,newState);}return true;}function checkClassInstance(workInProgress,ctor,newProps){var instance=workInProgress.stateNode;{var name=getComponentNameFromType(ctor)||'Component';var renderPresent=instance.render;if(!renderPresent){if(ctor.prototype&&typeof ctor.prototype.render==='function'){error('%s(...): No `render` method found on the returned component '+'instance: did you accidentally return an object from the constructor?',name);}else {error('%s(...): No `render` method found on the returned component '+'instance: you may have forgotten to define `render`.',name);}}if(instance.getInitialState&&!instance.getInitialState.isReactClassApproved&&!instance.state){error('getInitialState was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Did you mean to define a state property instead?',name);}if(instance.getDefaultProps&&!instance.getDefaultProps.isReactClassApproved){error('getDefaultProps was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Use a static property to define defaultProps instead.',name);}if(instance.propTypes){error('propTypes was defined as an instance property on %s. Use a static '+'property to define propTypes instead.',name);}if(instance.contextType){error('contextType was defined as an instance property on %s. Use a static '+'property to define contextType instead.',name);}{if(instance.contextTypes){error('contextTypes was defined as an instance property on %s. Use a static '+'property to define contextTypes instead.',name);}if(ctor.contextType&&ctor.contextTypes&&!didWarnAboutContextTypeAndContextTypes.has(ctor)){didWarnAboutContextTypeAndContextTypes.add(ctor);error('%s declares both contextTypes and contextType static properties. '+'The legacy contextTypes property will be ignored.',name);}}if(typeof instance.componentShouldUpdate==='function'){error('%s has a method called '+'componentShouldUpdate(). Did you mean shouldComponentUpdate()? '+'The name is phrased as a question because the function is '+'expected to return a value.',name);}if(ctor.prototype&&ctor.prototype.isPureReactComponent&&typeof instance.shouldComponentUpdate!=='undefined'){error('%s has a method called shouldComponentUpdate(). '+'shouldComponentUpdate should not be used when extending React.PureComponent. '+'Please extend React.Component if shouldComponentUpdate is used.',getComponentNameFromType(ctor)||'A pure component');}if(typeof instance.componentDidUnmount==='function'){error('%s has a method called '+'componentDidUnmount(). But there is no such lifecycle method. '+'Did you mean componentWillUnmount()?',name);}if(typeof instance.componentDidReceiveProps==='function'){error('%s has a method called '+'componentDidReceiveProps(). But there is no such lifecycle method. '+'If you meant to update the state in response to changing props, '+'use componentWillReceiveProps(). If you meant to fetch data or '+'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',name);}if(typeof instance.componentWillRecieveProps==='function'){error('%s has a method called '+'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',name);}if(typeof instance.UNSAFE_componentWillRecieveProps==='function'){error('%s has a method called '+'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?',name);}var hasMutatedProps=instance.props!==newProps;if(instance.props!==undefined&&hasMutatedProps){error('%s(...): When calling super() in `%s`, make sure to pass '+"up the same props that your component's constructor was passed.",name,name);}if(instance.defaultProps){error('Setting defaultProps as an instance property on %s is not supported and will be ignored.'+' Instead, define defaultProps as a static property on %s.',name,name);}if(typeof instance.getSnapshotBeforeUpdate==='function'&&typeof instance.componentDidUpdate!=='function'&&!didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)){didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). '+'This component defines getSnapshotBeforeUpdate() only.',getComponentNameFromType(ctor));}if(typeof instance.getDerivedStateFromProps==='function'){error('%s: getDerivedStateFromProps() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name);}if(typeof instance.getDerivedStateFromError==='function'){error('%s: getDerivedStateFromError() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name);}if(typeof ctor.getSnapshotBeforeUpdate==='function'){error('%s: getSnapshotBeforeUpdate() is defined as a static method '+'and will be ignored. Instead, declare it as an instance method.',name);}var _state=instance.state;if(_state&&(typeof _state!=='object'||isArray(_state))){error('%s.state: must be set to an object or null',name);}if(typeof instance.getChildContext==='function'&&typeof ctor.childContextTypes!=='object'){error('%s.getChildContext(): childContextTypes must be defined in order to '+'use getChildContext().',name);}}}function adoptClassInstance(workInProgress,instance){instance.updater=classComponentUpdater;workInProgress.stateNode=instance;// The instance needs access to the fiber so that it can schedule updates
set(instance,workInProgress);{instance._reactInternalInstance=fakeInternalInstance;}}function constructClassInstance(workInProgress,ctor,props){var isLegacyContextConsumer=false;var unmaskedContext=emptyContextObject;var context=emptyContextObject;var contextType=ctor.contextType;{if('contextType'in ctor){var isValid=// Allow null for conditional declaration
contextType===null||contextType!==undefined&&contextType.$$typeof===REACT_CONTEXT_TYPE&&contextType._context===undefined;// Not a <Context.Consumer>
if(!isValid&&!didWarnAboutInvalidateContextType.has(ctor)){didWarnAboutInvalidateContextType.add(ctor);var addendum='';if(contextType===undefined){addendum=' However, it is set to undefined. '+'This can be caused by a typo or by mixing up named and default imports. '+'This can also happen due to a circular dependency, so '+'try moving the createContext() call to a separate file.';}else if(typeof contextType!=='object'){addendum=' However, it is set to a '+typeof contextType+'.';}else if(contextType.$$typeof===REACT_PROVIDER_TYPE){addendum=' Did you accidentally pass the Context.Provider instead?';}else if(contextType._context!==undefined){// <Context.Consumer>
addendum=' Did you accidentally pass the Context.Consumer instead?';}else {addendum=' However, it is set to an object with keys {'+Object.keys(contextType).join(', ')+'}.';}error('%s defines an invalid contextType. '+'contextType should point to the Context object returned by React.createContext().%s',getComponentNameFromType(ctor)||'Component',addendum);}}}if(typeof contextType==='object'&&contextType!==null){context=readContext(contextType);}else {unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);var contextTypes=ctor.contextTypes;isLegacyContextConsumer=contextTypes!==null&&contextTypes!==undefined;context=isLegacyContextConsumer?getMaskedContext(workInProgress,unmaskedContext):emptyContextObject;}var instance=new ctor(props,context);// Instantiate twice to help detect side-effects.
{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{instance=new ctor(props,context);// eslint-disable-line no-new
}finally{setIsStrictModeForDevtools(false);}}}var state=workInProgress.memoizedState=instance.state!==null&&instance.state!==undefined?instance.state:null;adoptClassInstance(workInProgress,instance);{if(typeof ctor.getDerivedStateFromProps==='function'&&state===null){var componentName=getComponentNameFromType(ctor)||'Component';if(!didWarnAboutUninitializedState.has(componentName)){didWarnAboutUninitializedState.add(componentName);error('`%s` uses `getDerivedStateFromProps` but its initial state is '+'%s. This is not recommended. Instead, define the initial state by '+'assigning an object to `this.state` in the constructor of `%s`. '+'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.',componentName,instance.state===null?'null':'undefined',componentName);}}// If new component APIs are defined, "unsafe" lifecycles won't be called.
// Warn about these lifecycles if they are present.
// Don't warn about react-lifecycles-compat polyfilled methods though.
if(typeof ctor.getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function'){var foundWillMountName=null;var foundWillReceivePropsName=null;var foundWillUpdateName=null;if(typeof instance.componentWillMount==='function'&&instance.componentWillMount.__suppressDeprecationWarning!==true){foundWillMountName='componentWillMount';}else if(typeof instance.UNSAFE_componentWillMount==='function'){foundWillMountName='UNSAFE_componentWillMount';}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){foundWillReceivePropsName='componentWillReceiveProps';}else if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){foundWillReceivePropsName='UNSAFE_componentWillReceiveProps';}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){foundWillUpdateName='componentWillUpdate';}else if(typeof instance.UNSAFE_componentWillUpdate==='function'){foundWillUpdateName='UNSAFE_componentWillUpdate';}if(foundWillMountName!==null||foundWillReceivePropsName!==null||foundWillUpdateName!==null){var _componentName=getComponentNameFromType(ctor)||'Component';var newApiName=typeof ctor.getDerivedStateFromProps==='function'?'getDerivedStateFromProps()':'getSnapshotBeforeUpdate()';if(!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)){didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);error('Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n'+'%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n'+'The above lifecycles should be removed. Learn more about this warning here:\n'+'https://reactjs.org/link/unsafe-component-lifecycles',_componentName,newApiName,foundWillMountName!==null?"\n  "+foundWillMountName:'',foundWillReceivePropsName!==null?"\n  "+foundWillReceivePropsName:'',foundWillUpdateName!==null?"\n  "+foundWillUpdateName:'');}}}}// Cache unmasked context so we can avoid recreating masked context unless necessary.
// ReactFiberContext usually updates this cache but can't for newly-created instances.
if(isLegacyContextConsumer){cacheContext(workInProgress,unmaskedContext,context);}return instance;}function callComponentWillMount(workInProgress,instance){var oldState=instance.state;if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}if(oldState!==instance.state){{error('%s.componentWillMount(): Assigning directly to this.state is '+"deprecated (except inside a component's "+'constructor). Use setState instead.',getComponentNameFromFiber(workInProgress)||'Component');}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}function callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext){var oldState=instance.state;if(typeof instance.componentWillReceiveProps==='function'){instance.componentWillReceiveProps(newProps,nextContext);}if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){instance.UNSAFE_componentWillReceiveProps(newProps,nextContext);}if(instance.state!==oldState){{var componentName=getComponentNameFromFiber(workInProgress)||'Component';if(!didWarnAboutStateAssignmentForComponent.has(componentName)){didWarnAboutStateAssignmentForComponent.add(componentName);error('%s.componentWillReceiveProps(): Assigning directly to '+"this.state is deprecated (except inside a component's "+'constructor). Use setState instead.',componentName);}}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}// Invokes the mount life-cycles on a previously never rendered instance.
function mountClassInstance(workInProgress,ctor,newProps,renderLanes){{checkClassInstance(workInProgress,ctor,newProps);}var instance=workInProgress.stateNode;instance.props=newProps;instance.state=workInProgress.memoizedState;instance.refs=emptyRefsObject;initializeUpdateQueue(workInProgress);var contextType=ctor.contextType;if(typeof contextType==='object'&&contextType!==null){instance.context=readContext(contextType);}else {var unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);instance.context=getMaskedContext(workInProgress,unmaskedContext);}{if(instance.state===newProps){var componentName=getComponentNameFromType(ctor)||'Component';if(!didWarnAboutDirectlyAssigningPropsToState.has(componentName)){didWarnAboutDirectlyAssigningPropsToState.add(componentName);error('%s: It is not recommended to assign props directly to state '+"because updates to props won't be reflected in state. "+'In most cases, it is better to use props directly.',componentName);}}if(workInProgress.mode&StrictLegacyMode){ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,instance);}{ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress,instance);}}instance.state=workInProgress.memoizedState;var getDerivedStateFromProps=ctor.getDerivedStateFromProps;if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);instance.state=workInProgress.memoizedState;}// In order to support react-lifecycles-compat polyfilled components,
// Unsafe lifecycles should not be invoked for components using the new APIs.
if(typeof ctor.getDerivedStateFromProps!=='function'&&typeof instance.getSnapshotBeforeUpdate!=='function'&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){callComponentWillMount(workInProgress,instance);// If we had additional state updates during this life-cycle, let's
// process them now.
processUpdateQueue(workInProgress,newProps,instance,renderLanes);instance.state=workInProgress.memoizedState;}if(typeof instance.componentDidMount==='function'){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}workInProgress.flags|=fiberFlags;}}function resumeMountClassInstance(workInProgress,ctor,newProps,renderLanes){var instance=workInProgress.stateNode;var oldProps=workInProgress.memoizedProps;instance.props=oldProps;var oldContext=instance.context;var contextType=ctor.contextType;var nextContext=emptyContextObject;if(typeof contextType==='object'&&contextType!==null){nextContext=readContext(contextType);}else {var nextLegacyUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);nextContext=getMaskedContext(workInProgress,nextLegacyUnmaskedContext);}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what
// ever the previously attempted to render - not the "current". However,
// during componentDidUpdate we pass the "current" props.
// In order to support react-lifecycles-compat polyfilled components,
// Unsafe lifecycles should not be invoked for components using the new APIs.
if(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(oldProps!==newProps||oldContext!==nextContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;processUpdateQueue(workInProgress,newProps,instance,renderLanes);newState=workInProgress.memoizedState;if(oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()){// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidMount==='function'){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}workInProgress.flags|=fiberFlags;}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext);if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,
// Unsafe lifecycles should not be invoked for components using the new APIs.
if(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}}if(typeof instance.componentDidMount==='function'){var _fiberFlags=Update;{_fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){_fiberFlags|=MountLayoutDev;}workInProgress.flags|=_fiberFlags;}}else {// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidMount==='function'){var _fiberFlags2=Update;{_fiberFlags2|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){_fiberFlags2|=MountLayoutDev;}workInProgress.flags|=_fiberFlags2;}// If shouldComponentUpdate returned false, we should still update the
// memoized state to indicate that this work can be reused.
workInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even
// if shouldComponentUpdate returns false.
instance.props=newProps;instance.state=newState;instance.context=nextContext;return shouldUpdate;}// Invokes the update life-cycles and returns false if it shouldn't rerender.
function updateClassInstance(current,workInProgress,ctor,newProps,renderLanes){var instance=workInProgress.stateNode;cloneUpdateQueue(current,workInProgress);var unresolvedOldProps=workInProgress.memoizedProps;var oldProps=workInProgress.type===workInProgress.elementType?unresolvedOldProps:resolveDefaultProps(workInProgress.type,unresolvedOldProps);instance.props=oldProps;var unresolvedNewProps=workInProgress.pendingProps;var oldContext=instance.context;var contextType=ctor.contextType;var nextContext=emptyContextObject;if(typeof contextType==='object'&&contextType!==null){nextContext=readContext(contextType);}else {var nextUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);nextContext=getMaskedContext(workInProgress,nextUnmaskedContext);}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what
// ever the previously attempted to render - not the "current". However,
// during componentDidUpdate we pass the "current" props.
// In order to support react-lifecycles-compat polyfilled components,
// Unsafe lifecycles should not be invoked for components using the new APIs.
if(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(unresolvedOldProps!==unresolvedNewProps||oldContext!==nextContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;processUpdateQueue(workInProgress,newProps,instance,renderLanes);newState=workInProgress.memoizedState;if(unresolvedOldProps===unresolvedNewProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()&&!enableLazyContextPropagation){// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Snapshot;}}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext)||// TODO: In some cases, we'll end up checking if context has changed twice,
// both before and after `shouldComponentUpdate` has been called. Not ideal,
// but I'm loath to refactor this function. This only happens for memoized
// components so it's not that common.
enableLazyContextPropagation;if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,
// Unsafe lifecycles should not be invoked for components using the new APIs.
if(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillUpdate==='function'||typeof instance.componentWillUpdate==='function')){if(typeof instance.componentWillUpdate==='function'){instance.componentWillUpdate(newProps,newState,nextContext);}if(typeof instance.UNSAFE_componentWillUpdate==='function'){instance.UNSAFE_componentWillUpdate(newProps,newState,nextContext);}}if(typeof instance.componentDidUpdate==='function'){workInProgress.flags|=Update;}if(typeof instance.getSnapshotBeforeUpdate==='function'){workInProgress.flags|=Snapshot;}}else {// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Snapshot;}}// If shouldComponentUpdate returned false, we should still update the
// memoized props/state to indicate that this work can be reused.
workInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even
// if shouldComponentUpdate returns false.
instance.props=newProps;instance.state=newState;instance.context=nextContext;return shouldUpdate;}var didWarnAboutMaps;var didWarnAboutGenerators;var didWarnAboutStringRefs;var ownerHasKeyUseWarning;var ownerHasFunctionTypeWarning;var warnForMissingKey=function(child,returnFiber){};{didWarnAboutMaps=false;didWarnAboutGenerators=false;didWarnAboutStringRefs={};/**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */ownerHasKeyUseWarning={};ownerHasFunctionTypeWarning={};warnForMissingKey=function(child,returnFiber){if(child===null||typeof child!=='object'){return;}if(!child._store||child._store.validated||child.key!=null){return;}if(typeof child._store!=='object'){throw new Error('React Component in warnForMissingKey should have a _store. '+'This error is likely caused by a bug in React. Please file an issue.');}child._store.validated=true;var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(ownerHasKeyUseWarning[componentName]){return;}ownerHasKeyUseWarning[componentName]=true;error('Each child in a list should have a unique '+'"key" prop. See https://reactjs.org/link/warning-keys for '+'more information.');};}function coerceRef(returnFiber,current,element){var mixedRef=element.ref;if(mixedRef!==null&&typeof mixedRef!=='function'&&typeof mixedRef!=='object'){{// TODO: Clean this up once we turn on the string ref warning for
// everyone, because the strict mode case will no longer be relevant
if((returnFiber.mode&StrictLegacyMode||warnAboutStringRefs)&&// We warn in ReactElement.js if owner and self are equal for string refs
// because these cannot be automatically converted to an arrow function
// using a codemod. Therefore, we don't have to warn about string refs again.
!(element._owner&&element._self&&element._owner.stateNode!==element._self)){var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(!didWarnAboutStringRefs[componentName]){{error('A string ref, "%s", has been found within a strict mode tree. '+'String refs are a source of potential bugs and should be avoided. '+'We recommend using useRef() or createRef() instead. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-string-ref',mixedRef);}didWarnAboutStringRefs[componentName]=true;}}}if(element._owner){var owner=element._owner;var inst;if(owner){var ownerFiber=owner;if(ownerFiber.tag!==ClassComponent){throw new Error('Function components cannot have string refs. '+'We recommend using useRef() instead. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-string-ref');}inst=ownerFiber.stateNode;}if(!inst){throw new Error("Missing owner for string ref "+mixedRef+". This error is likely caused by a "+'bug in React. Please file an issue.');}// Assigning this to a const so Flow knows it won't change in the closure
var resolvedInst=inst;{checkPropStringCoercion(mixedRef,'ref');}var stringRef=''+mixedRef;// Check if previous string ref matches new string ref
if(current!==null&&current.ref!==null&&typeof current.ref==='function'&&current.ref._stringRef===stringRef){return current.ref;}var ref=function(value){var refs=resolvedInst.refs;if(refs===emptyRefsObject){// This is a lazy pooled frozen object, so we need to initialize.
refs=resolvedInst.refs={};}if(value===null){delete refs[stringRef];}else {refs[stringRef]=value;}};ref._stringRef=stringRef;return ref;}else {if(typeof mixedRef!=='string'){throw new Error('Expected ref to be a function, a string, an object returned by React.createRef(), or null.');}if(!element._owner){throw new Error("Element ref was specified as a string ("+mixedRef+") but no owner was set. This could happen for one of"+' the following reasons:\n'+'1. You may be adding a ref to a function component\n'+"2. You may be adding a ref to a component that was not created inside a component's render method\n"+'3. You have multiple copies of React loaded\n'+'See https://reactjs.org/link/refs-must-have-owner for more information.');}}}return mixedRef;}function throwOnInvalidObjectType(returnFiber,newChild){var childString=Object.prototype.toString.call(newChild);throw new Error("Objects are not valid as a React child (found: "+(childString==='[object Object]'?'object with keys {'+Object.keys(newChild).join(', ')+'}':childString)+"). "+'If you meant to render a collection of children, use an array '+'instead.');}function warnOnFunctionType(returnFiber){{var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(ownerHasFunctionTypeWarning[componentName]){return;}ownerHasFunctionTypeWarning[componentName]=true;error('Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.');}}function resolveLazy(lazyType){var payload=lazyType._payload;var init=lazyType._init;return init(payload);}// This wrapper function exists because I expect to clone the code in each path
// to be able to optimize each path individually by branching early. This needs
// a compiler or we can do it manually. Helpers that don't need this branching
// live outside of this function.
function ChildReconciler(shouldTrackSideEffects){function deleteChild(returnFiber,childToDelete){if(!shouldTrackSideEffects){// Noop.
return;}var deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[childToDelete];returnFiber.flags|=ChildDeletion;}else {deletions.push(childToDelete);}}function deleteRemainingChildren(returnFiber,currentFirstChild){if(!shouldTrackSideEffects){// Noop.
return null;}// TODO: For the shouldClone case, this could be micro-optimized a bit by
// assuming that after the first child we've already added everything.
var childToDelete=currentFirstChild;while(childToDelete!==null){deleteChild(returnFiber,childToDelete);childToDelete=childToDelete.sibling;}return null;}function mapRemainingChildren(returnFiber,currentFirstChild){// Add the remaining children to a temporary map so that we can find them by
// keys quickly. Implicit (null) keys get added to this set with their index
// instead.
var existingChildren=new Map();var existingChild=currentFirstChild;while(existingChild!==null){if(existingChild.key!==null){existingChildren.set(existingChild.key,existingChild);}else {existingChildren.set(existingChild.index,existingChild);}existingChild=existingChild.sibling;}return existingChildren;}function useFiber(fiber,pendingProps){// We currently set sibling to null and index to 0 here because it is easy
// to forget to do before returning it. E.g. for the single child case.
var clone=createWorkInProgress(fiber,pendingProps);clone.index=0;clone.sibling=null;return clone;}function placeChild(newFiber,lastPlacedIndex,newIndex){newFiber.index=newIndex;if(!shouldTrackSideEffects){// During hydration, the useId algorithm needs to know which fibers are
// part of a list of children (arrays, iterators).
newFiber.flags|=Forked;return lastPlacedIndex;}var current=newFiber.alternate;if(current!==null){var oldIndex=current.index;if(oldIndex<lastPlacedIndex){// This is a move.
newFiber.flags|=Placement;return lastPlacedIndex;}else {// This item can stay in place.
return oldIndex;}}else {// This is an insertion.
newFiber.flags|=Placement;return lastPlacedIndex;}}function placeSingleChild(newFiber){// This is simpler for the single child case. We only need to do a
// placement for inserting new children.
if(shouldTrackSideEffects&&newFiber.alternate===null){newFiber.flags|=Placement;}return newFiber;}function updateTextNode(returnFiber,current,textContent,lanes){if(current===null||current.tag!==HostText){// Insert
var created=createFiberFromText(textContent,returnFiber.mode,lanes);created.return=returnFiber;return created;}else {// Update
var existing=useFiber(current,textContent);existing.return=returnFiber;return existing;}}function updateElement(returnFiber,current,element,lanes){var elementType=element.type;if(elementType===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,current,element.props.children,lanes,element.key);}if(current!==null){if(current.elementType===elementType||// Keep this check inline so it only runs on the false path:
isCompatibleFamilyForHotReloading(current,element)||// Lazy types should reconcile their resolved type.
// We need to do this after the Hot Reloading check above,
// because hot reloading has different semantics than prod because
// it doesn't resuspend. So we can't let the call below suspend.
typeof elementType==='object'&&elementType!==null&&elementType.$$typeof===REACT_LAZY_TYPE&&resolveLazy(elementType)===current.type){// Move based on index
var existing=useFiber(current,element.props);existing.ref=coerceRef(returnFiber,current,element);existing.return=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}}// Insert
var created=createFiberFromElement(element,returnFiber.mode,lanes);created.ref=coerceRef(returnFiber,current,element);created.return=returnFiber;return created;}function updatePortal(returnFiber,current,portal,lanes){if(current===null||current.tag!==HostPortal||current.stateNode.containerInfo!==portal.containerInfo||current.stateNode.implementation!==portal.implementation){// Insert
var created=createFiberFromPortal(portal,returnFiber.mode,lanes);created.return=returnFiber;return created;}else {// Update
var existing=useFiber(current,portal.children||[]);existing.return=returnFiber;return existing;}}function updateFragment(returnFiber,current,fragment,lanes,key){if(current===null||current.tag!==Fragment){// Insert
var created=createFiberFromFragment(fragment,returnFiber.mode,lanes,key);created.return=returnFiber;return created;}else {// Update
var existing=useFiber(current,fragment);existing.return=returnFiber;return existing;}}function createChild(returnFiber,newChild,lanes){if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a text
// node.
var created=createFiberFromText(''+newChild,returnFiber.mode,lanes);created.return=returnFiber;return created;}if(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _created=createFiberFromElement(newChild,returnFiber.mode,lanes);_created.ref=coerceRef(returnFiber,null,newChild);_created.return=returnFiber;return _created;}case REACT_PORTAL_TYPE:{var _created2=createFiberFromPortal(newChild,returnFiber.mode,lanes);_created2.return=returnFiber;return _created2;}case REACT_LAZY_TYPE:{var payload=newChild._payload;var init=newChild._init;return createChild(returnFiber,init(payload),lanes);}}if(isArray(newChild)||getIteratorFn(newChild)){var _created3=createFiberFromFragment(newChild,returnFiber.mode,lanes,null);_created3.return=returnFiber;return _created3;}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}function updateSlot(returnFiber,oldFiber,newChild,lanes){// Update the fiber if the keys match, otherwise return null.
var key=oldFiber!==null?oldFiber.key:null;if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a text
// node.
if(key!==null){return null;}return updateTextNode(returnFiber,oldFiber,''+newChild,lanes);}if(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.key===key){return updateElement(returnFiber,oldFiber,newChild,lanes);}else {return null;}}case REACT_PORTAL_TYPE:{if(newChild.key===key){return updatePortal(returnFiber,oldFiber,newChild,lanes);}else {return null;}}case REACT_LAZY_TYPE:{var payload=newChild._payload;var init=newChild._init;return updateSlot(returnFiber,oldFiber,init(payload),lanes);}}if(isArray(newChild)||getIteratorFn(newChild)){if(key!==null){return null;}return updateFragment(returnFiber,oldFiber,newChild,lanes,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}function updateFromMap(existingChildren,returnFiber,newIdx,newChild,lanes){if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys, so we neither have to check the old nor
// new node for the key. If both are text nodes, they match.
var matchedFiber=existingChildren.get(newIdx)||null;return updateTextNode(returnFiber,matchedFiber,''+newChild,lanes);}if(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _matchedFiber=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updateElement(returnFiber,_matchedFiber,newChild,lanes);}case REACT_PORTAL_TYPE:{var _matchedFiber2=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updatePortal(returnFiber,_matchedFiber2,newChild,lanes);}case REACT_LAZY_TYPE:var payload=newChild._payload;var init=newChild._init;return updateFromMap(existingChildren,returnFiber,newIdx,init(payload),lanes);}if(isArray(newChild)||getIteratorFn(newChild)){var _matchedFiber3=existingChildren.get(newIdx)||null;return updateFragment(returnFiber,_matchedFiber3,newChild,lanes,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}/**
   * Warns if there is a duplicate or missing key
   */function warnOnInvalidKey(child,knownKeys,returnFiber){{if(typeof child!=='object'||child===null){return knownKeys;}switch(child.$$typeof){case REACT_ELEMENT_TYPE:case REACT_PORTAL_TYPE:warnForMissingKey(child,returnFiber);var key=child.key;if(typeof key!=='string'){break;}if(knownKeys===null){knownKeys=new Set();knownKeys.add(key);break;}if(!knownKeys.has(key)){knownKeys.add(key);break;}error('Encountered two children with the same key, `%s`. '+'Keys should be unique so that components maintain their identity '+'across updates. Non-unique keys may cause children to be '+'duplicated and/or omitted — the behavior is unsupported and '+'could change in a future version.',key);break;case REACT_LAZY_TYPE:var payload=child._payload;var init=child._init;warnOnInvalidKey(init(payload),knownKeys,returnFiber);break;}}return knownKeys;}function reconcileChildrenArray(returnFiber,currentFirstChild,newChildren,lanes){// This algorithm can't optimize by searching from both ends since we
// don't have backpointers on fibers. I'm trying to see how far we can get
// with that model. If it ends up not being worth the tradeoffs, we can
// add it later.
// Even with a two ended optimization, we'd want to optimize for the case
// where there are few changes and brute force the comparison instead of
// going for the Map. It'd like to explore hitting that path first in
// forward-only mode and only go for the Map once we notice that we need
// lots of look ahead. This doesn't handle reversal as well as two ended
// search but that's unusual. Besides, for the two ended optimization to
// work on Iterables, we'd need to copy the whole set.
// In this first iteration, we'll just live with hitting the bad case
// (adding everything to a Map) in for every insert/move.
// If you change this code, also update reconcileChildrenIterator() which
// uses the same algorithm.
{// First, validate keys.
var knownKeys=null;for(var i=0;i<newChildren.length;i++){var child=newChildren[i];knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber);}}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;for(;oldFiber!==null&&newIdx<newChildren.length;newIdx++){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else {nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,newChildren[newIdx],lanes);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's
// unfortunate because it triggers the slow path all the time. We need
// a better way to communicate whether this was a miss or null,
// boolean, undefined, etc.
if(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we
// need to delete the existing child.
deleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=newFiber;}else {// TODO: Defer siblings if we're not at the right index for this slot.
// I.e. if we had null values before, then we want to defer this
// for each null value. However, we also don't want to call updateSlot
// with the previous one.
previousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(newIdx===newChildren.length){// We've reached the end of the new children. We can delete the rest.
deleteRemainingChildren(returnFiber,oldFiber);if(getIsHydrating()){var numberOfForks=newIdx;pushTreeFork(returnFiber,numberOfForks);}return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path
// since the rest will all be insertions.
for(;newIdx<newChildren.length;newIdx++){var _newFiber=createChild(returnFiber,newChildren[newIdx],lanes);if(_newFiber===null){continue;}lastPlacedIndex=placeChild(_newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=_newFiber;}else {previousNewFiber.sibling=_newFiber;}previousNewFiber=_newFiber;}if(getIsHydrating()){var _numberOfForks=newIdx;pushTreeFork(returnFiber,_numberOfForks);}return resultingFirstChild;}// Add all children to a key map for quick lookups.
var existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.
for(;newIdx<newChildren.length;newIdx++){var _newFiber2=updateFromMap(existingChildren,returnFiber,newIdx,newChildren[newIdx],lanes);if(_newFiber2!==null){if(shouldTrackSideEffects){if(_newFiber2.alternate!==null){// The new fiber is a work in progress, but if there exists a
// current, that means that we reused the fiber. We need to delete
// it from the child list so that we don't add it to the deletion
// list.
existingChildren.delete(_newFiber2.key===null?newIdx:_newFiber2.key);}}lastPlacedIndex=placeChild(_newFiber2,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber2;}else {previousNewFiber.sibling=_newFiber2;}previousNewFiber=_newFiber2;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need
// to add them to the deletion list.
existingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}if(getIsHydrating()){var _numberOfForks2=newIdx;pushTreeFork(returnFiber,_numberOfForks2);}return resultingFirstChild;}function reconcileChildrenIterator(returnFiber,currentFirstChild,newChildrenIterable,lanes){// This is the same implementation as reconcileChildrenArray(),
// but using the iterator instead.
var iteratorFn=getIteratorFn(newChildrenIterable);if(typeof iteratorFn!=='function'){throw new Error('An object is not an iterable. This error is likely caused by a bug in '+'React. Please file an issue.');}{// We don't support rendering Generators because it's a mutation.
// See https://github.com/facebook/react/issues/12995
if(typeof Symbol==='function'&&// $FlowFixMe Flow doesn't know about toStringTag
newChildrenIterable[Symbol.toStringTag]==='Generator'){if(!didWarnAboutGenerators){error('Using Generators as children is unsupported and will likely yield '+'unexpected results because enumerating a generator mutates it. '+'You may convert it to an array with `Array.from()` or the '+'`[...spread]` operator before rendering. Keep in mind '+'you might need to polyfill these features for older browsers.');}didWarnAboutGenerators=true;}// Warn about using Maps as children
if(newChildrenIterable.entries===iteratorFn){if(!didWarnAboutMaps){error('Using Maps as children is not supported. '+'Use an array of keyed ReactElements instead.');}didWarnAboutMaps=true;}// First, validate keys.
// We'll get a different iterator later for the main pass.
var _newChildren=iteratorFn.call(newChildrenIterable);if(_newChildren){var knownKeys=null;var _step=_newChildren.next();for(;!_step.done;_step=_newChildren.next()){var child=_step.value;knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber);}}}var newChildren=iteratorFn.call(newChildrenIterable);if(newChildren==null){throw new Error('An iterable object provided no iterator.');}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;var step=newChildren.next();for(;oldFiber!==null&&!step.done;newIdx++,step=newChildren.next()){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else {nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,step.value,lanes);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's
// unfortunate because it triggers the slow path all the time. We need
// a better way to communicate whether this was a miss or null,
// boolean, undefined, etc.
if(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we
// need to delete the existing child.
deleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=newFiber;}else {// TODO: Defer siblings if we're not at the right index for this slot.
// I.e. if we had null values before, then we want to defer this
// for each null value. However, we also don't want to call updateSlot
// with the previous one.
previousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(step.done){// We've reached the end of the new children. We can delete the rest.
deleteRemainingChildren(returnFiber,oldFiber);if(getIsHydrating()){var numberOfForks=newIdx;pushTreeFork(returnFiber,numberOfForks);}return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path
// since the rest will all be insertions.
for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber3=createChild(returnFiber,step.value,lanes);if(_newFiber3===null){continue;}lastPlacedIndex=placeChild(_newFiber3,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=_newFiber3;}else {previousNewFiber.sibling=_newFiber3;}previousNewFiber=_newFiber3;}if(getIsHydrating()){var _numberOfForks3=newIdx;pushTreeFork(returnFiber,_numberOfForks3);}return resultingFirstChild;}// Add all children to a key map for quick lookups.
var existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.
for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber4=updateFromMap(existingChildren,returnFiber,newIdx,step.value,lanes);if(_newFiber4!==null){if(shouldTrackSideEffects){if(_newFiber4.alternate!==null){// The new fiber is a work in progress, but if there exists a
// current, that means that we reused the fiber. We need to delete
// it from the child list so that we don't add it to the deletion
// list.
existingChildren.delete(_newFiber4.key===null?newIdx:_newFiber4.key);}}lastPlacedIndex=placeChild(_newFiber4,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber4;}else {previousNewFiber.sibling=_newFiber4;}previousNewFiber=_newFiber4;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need
// to add them to the deletion list.
existingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}if(getIsHydrating()){var _numberOfForks4=newIdx;pushTreeFork(returnFiber,_numberOfForks4);}return resultingFirstChild;}function reconcileSingleTextNode(returnFiber,currentFirstChild,textContent,lanes){// There's no need to check for keys on text nodes since we don't have a
// way to define them.
if(currentFirstChild!==null&&currentFirstChild.tag===HostText){// We already have an existing node so let's just update it and delete
// the rest.
deleteRemainingChildren(returnFiber,currentFirstChild.sibling);var existing=useFiber(currentFirstChild,textContent);existing.return=returnFiber;return existing;}// The existing first child is not a text node so we need to create one
// and delete the existing ones.
deleteRemainingChildren(returnFiber,currentFirstChild);var created=createFiberFromText(textContent,returnFiber.mode,lanes);created.return=returnFiber;return created;}function reconcileSingleElement(returnFiber,currentFirstChild,element,lanes){var key=element.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){var elementType=element.type;if(elementType===REACT_FRAGMENT_TYPE){if(child.tag===Fragment){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,element.props.children);existing.return=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}}else {if(child.elementType===elementType||// Keep this check inline so it only runs on the false path:
isCompatibleFamilyForHotReloading(child,element)||// Lazy types should reconcile their resolved type.
// We need to do this after the Hot Reloading check above,
// because hot reloading has different semantics than prod because
// it doesn't resuspend. So we can't let the call below suspend.
typeof elementType==='object'&&elementType!==null&&elementType.$$typeof===REACT_LAZY_TYPE&&resolveLazy(elementType)===child.type){deleteRemainingChildren(returnFiber,child.sibling);var _existing=useFiber(child,element.props);_existing.ref=coerceRef(returnFiber,child,element);_existing.return=returnFiber;{_existing._debugSource=element._source;_existing._debugOwner=element._owner;}return _existing;}}// Didn't match.
deleteRemainingChildren(returnFiber,child);break;}else {deleteChild(returnFiber,child);}child=child.sibling;}if(element.type===REACT_FRAGMENT_TYPE){var created=createFiberFromFragment(element.props.children,returnFiber.mode,lanes,element.key);created.return=returnFiber;return created;}else {var _created4=createFiberFromElement(element,returnFiber.mode,lanes);_created4.ref=coerceRef(returnFiber,currentFirstChild,element);_created4.return=returnFiber;return _created4;}}function reconcileSinglePortal(returnFiber,currentFirstChild,portal,lanes){var key=portal.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===HostPortal&&child.stateNode.containerInfo===portal.containerInfo&&child.stateNode.implementation===portal.implementation){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,portal.children||[]);existing.return=returnFiber;return existing;}else {deleteRemainingChildren(returnFiber,child);break;}}else {deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromPortal(portal,returnFiber.mode,lanes);created.return=returnFiber;return created;}// This API will tag the children with the side-effect of the reconciliation
// itself. They will be added to the side-effect list as we pass through the
// children and the parent.
function reconcileChildFibers(returnFiber,currentFirstChild,newChild,lanes){// This function is not recursive.
// If the top level item is an array, we treat it as a set of children,
// not as a fragment. Nested arrays on the other hand will be treated as
// fragment nodes. Recursion happens at the normal flow.
// Handle top level unkeyed fragments as if they were arrays.
// This leads to an ambiguity between <>{[...]}</> and <>...</>.
// We treat the ambiguous cases above the same.
var isUnkeyedTopLevelFragment=typeof newChild==='object'&&newChild!==null&&newChild.type===REACT_FRAGMENT_TYPE&&newChild.key===null;if(isUnkeyedTopLevelFragment){newChild=newChild.props.children;}// Handle object types
if(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return placeSingleChild(reconcileSingleElement(returnFiber,currentFirstChild,newChild,lanes));case REACT_PORTAL_TYPE:return placeSingleChild(reconcileSinglePortal(returnFiber,currentFirstChild,newChild,lanes));case REACT_LAZY_TYPE:var payload=newChild._payload;var init=newChild._init;// TODO: This function is supposed to be non-recursive.
return reconcileChildFibers(returnFiber,currentFirstChild,init(payload),lanes);}if(isArray(newChild)){return reconcileChildrenArray(returnFiber,currentFirstChild,newChild,lanes);}if(getIteratorFn(newChild)){return reconcileChildrenIterator(returnFiber,currentFirstChild,newChild,lanes);}throwOnInvalidObjectType(returnFiber,newChild);}if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){return placeSingleChild(reconcileSingleTextNode(returnFiber,currentFirstChild,''+newChild,lanes));}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}// Remaining cases are all treated as empty.
return deleteRemainingChildren(returnFiber,currentFirstChild);}return reconcileChildFibers;}var reconcileChildFibers=ChildReconciler(true);var mountChildFibers=ChildReconciler(false);function cloneChildFibers(current,workInProgress){if(current!==null&&workInProgress.child!==current.child){throw new Error('Resuming work not yet implemented.');}if(workInProgress.child===null){return;}var currentChild=workInProgress.child;var newChild=createWorkInProgress(currentChild,currentChild.pendingProps);workInProgress.child=newChild;newChild.return=workInProgress;while(currentChild.sibling!==null){currentChild=currentChild.sibling;newChild=newChild.sibling=createWorkInProgress(currentChild,currentChild.pendingProps);newChild.return=workInProgress;}newChild.sibling=null;}// Reset a workInProgress child set to prepare it for a second pass.
function resetChildFibers(workInProgress,lanes){var child=workInProgress.child;while(child!==null){resetWorkInProgress(child,lanes);child=child.sibling;}}var NO_CONTEXT={};var contextStackCursor$1=createCursor(NO_CONTEXT);var contextFiberStackCursor=createCursor(NO_CONTEXT);var rootInstanceStackCursor=createCursor(NO_CONTEXT);function requiredContext(c){if(c===NO_CONTEXT){throw new Error('Expected host context to exist. This error is likely caused by a bug '+'in React. Please file an issue.');}return c;}function getRootHostContainer(){var rootInstance=requiredContext(rootInstanceStackCursor.current);return rootInstance;}function pushHostContainer(fiber,nextRootInstance){// Push current root instance onto the stack;
// This allows us to reset root when portals are popped.
push(rootInstanceStackCursor,nextRootInstance,fiber);// Track the context and the Fiber that provided it.
// This enables us to pop only Fibers that provide unique contexts.
push(contextFiberStackCursor,fiber,fiber);// Finally, we need to push the host context to the stack.
// However, we can't just call getRootHostContext() and push it because
// we'd have a different number of entries on the stack depending on
// whether getRootHostContext() throws somewhere in renderer code or not.
// So we push an empty value first. This lets us safely unwind on errors.
push(contextStackCursor$1,NO_CONTEXT,fiber);var nextRootContext=getRootHostContext(nextRootInstance);// Now that we know this function doesn't throw, replace it.
pop(contextStackCursor$1,fiber);push(contextStackCursor$1,nextRootContext,fiber);}function popHostContainer(fiber){pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);pop(rootInstanceStackCursor,fiber);}function getHostContext(){var context=requiredContext(contextStackCursor$1.current);return context;}function pushHostContext(fiber){requiredContext(rootInstanceStackCursor.current);var context=requiredContext(contextStackCursor$1.current);var nextContext=getChildHostContext(context,fiber.type);// Don't push this Fiber's context unless it's unique.
if(context===nextContext){return;}// Track the context and the Fiber that provided it.
// This enables us to pop only Fibers that provide unique contexts.
push(contextFiberStackCursor,fiber,fiber);push(contextStackCursor$1,nextContext,fiber);}function popHostContext(fiber){// Do not pop unless this Fiber provided the current context.
// pushHostContext() only pushes Fibers that provide unique contexts.
if(contextFiberStackCursor.current!==fiber){return;}pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);}var DefaultSuspenseContext=0;// The Suspense Context is split into two parts. The lower bits is
// inherited deeply down the subtree. The upper bits only affect
// this immediate suspense boundary and gets reset each new
// boundary or suspense list.
var SubtreeSuspenseContextMask=1;// Subtree Flags:
// InvisibleParentSuspenseContext indicates that one of our parent Suspense
// boundaries is not currently showing visible main content.
// Either because it is already showing a fallback or is not mounted at all.
// We can use this to determine if it is desirable to trigger a fallback at
// the parent. If not, then we might need to trigger undesirable boundaries
// and/or suspend the commit to avoid hiding the parent content.
var InvisibleParentSuspenseContext=1;// Shallow Flags:
// ForceSuspenseFallback can be used by SuspenseList to force newly added
// items into their fallback state during one of the render passes.
var ForceSuspenseFallback=2;var suspenseStackCursor=createCursor(DefaultSuspenseContext);function hasSuspenseContext(parentContext,flag){return (parentContext&flag)!==0;}function setDefaultShallowSuspenseContext(parentContext){return parentContext&SubtreeSuspenseContextMask;}function setShallowSuspenseContext(parentContext,shallowContext){return parentContext&SubtreeSuspenseContextMask|shallowContext;}function addSubtreeSuspenseContext(parentContext,subtreeContext){return parentContext|subtreeContext;}function pushSuspenseContext(fiber,newContext){push(suspenseStackCursor,newContext,fiber);}function popSuspenseContext(fiber){pop(suspenseStackCursor,fiber);}function shouldCaptureSuspense(workInProgress,hasInvisibleParent){// If it was the primary children that just suspended, capture and render the
// fallback. Otherwise, don't capture and bubble to the next boundary.
var nextState=workInProgress.memoizedState;if(nextState!==null){if(nextState.dehydrated!==null){// A dehydrated boundary always captures.
return true;}return false;}workInProgress.memoizedProps;// Regular boundaries always capture.
{return true;}// If it's a boundary we should avoid, then we prefer to bubble up to the
}function findFirstSuspended(row){var node=row;while(node!==null){if(node.tag===SuspenseComponent){var state=node.memoizedState;if(state!==null){var dehydrated=state.dehydrated;if(dehydrated===null||isSuspenseInstancePending(dehydrated)||isSuspenseInstanceFallback(dehydrated)){return node;}}}else if(node.tag===SuspenseListComponent&&// revealOrder undefined can't be trusted because it don't
// keep track of whether it suspended or not.
node.memoizedProps.revealOrder!==undefined){var didSuspend=(node.flags&DidCapture)!==NoFlags;if(didSuspend){return node;}}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===row){return null;}while(node.sibling===null){if(node.return===null||node.return===row){return null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}return null;}var NoFlags$1=/*   */0;// Represents whether effect should fire.
var HasEffect=/* */1;// Represents the phase in which the effect (not the clean-up) fires.
var Insertion=/*  */2;var Layout=/*    */4;var Passive$1=/*   */8;// and should be reset before starting a new render.
// This tracks which mutable sources need to be reset after a render.
var workInProgressSources=[];function resetWorkInProgressVersions(){for(var i=0;i<workInProgressSources.length;i++){var mutableSource=workInProgressSources[i];{mutableSource._workInProgressVersionPrimary=null;}}workInProgressSources.length=0;}// This ensures that the version used for server rendering matches the one
// that is eventually read during hydration.
// If they don't match there's a potential tear and a full deopt render is required.
function registerMutableSourceForHydration(root,mutableSource){var getVersion=mutableSource._getVersion;var version=getVersion(mutableSource._source);// TODO Clear this data once all pending hydration work is finished.
// Retaining it forever may interfere with GC.
if(root.mutableSourceEagerHydrationData==null){root.mutableSourceEagerHydrationData=[mutableSource,version];}else {root.mutableSourceEagerHydrationData.push(mutableSource,version);}}var ReactCurrentDispatcher$1=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentBatchConfig$2=ReactSharedInternals.ReactCurrentBatchConfig;var didWarnAboutMismatchedHooksForComponent;var didWarnUncachedGetSnapshot;{didWarnAboutMismatchedHooksForComponent=new Set();}// These are set right before calling the component.
var renderLanes=NoLanes;// The work-in-progress fiber. I've named it differently to distinguish it from
// the work-in-progress hook.
var currentlyRenderingFiber$1=null;// Hooks are stored as a linked list on the fiber's memoizedState field. The
// current hook list is the list that belongs to the current fiber. The
// work-in-progress hook list is a new list that will be added to the
// work-in-progress fiber.
var currentHook=null;var workInProgressHook=null;// Whether an update was scheduled at any point during the render phase. This
// does not get reset if we do another render pass; only when we're completely
// finished evaluating this component. This is an optimization so we know
// whether we need to clear render phase updates after a throw.
var didScheduleRenderPhaseUpdate=false;// Where an update was scheduled only during the current render pass. This
// gets reset after each attempt.
// TODO: Maybe there's some way to consolidate this with
// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.
var didScheduleRenderPhaseUpdateDuringThisPass=false;// Counts the number of useId hooks in this component.
var localIdCounter=0;// Used for ids that are generated completely client-side (i.e. not during
// hydration). This counter is global, so client ids are not stable across
// render attempts.
var globalClientIdCounter=0;var RE_RENDER_LIMIT=25;// In DEV, this is the name of the currently executing primitive hook
var currentHookNameInDev=null;// In DEV, this list ensures that hooks are called in the same order between renders.
// The list stores the order of hooks used during the initial render (mount).
// Subsequent renders (updates) reference this list.
var hookTypesDev=null;var hookTypesUpdateIndexDev=-1;// In DEV, this tracks whether currently rendering component needs to ignore
// the dependencies for Hooks that need them (e.g. useEffect or useMemo).
// When true, such Hooks will always be "remounted". Only used during hot reload.
var ignorePreviousDependencies=false;function mountHookTypesDev(){{var hookName=currentHookNameInDev;if(hookTypesDev===null){hookTypesDev=[hookName];}else {hookTypesDev.push(hookName);}}}function updateHookTypesDev(){{var hookName=currentHookNameInDev;if(hookTypesDev!==null){hookTypesUpdateIndexDev++;if(hookTypesDev[hookTypesUpdateIndexDev]!==hookName){warnOnHookMismatchInDev(hookName);}}}}function checkDepsAreArrayDev(deps){{if(deps!==undefined&&deps!==null&&!isArray(deps)){// Verify deps, but only on mount to avoid extra checks.
// It's unlikely their type would change as usually you define them inline.
error('%s received a final argument that is not an array (instead, received `%s`). When '+'specified, the final argument must be an array.',currentHookNameInDev,typeof deps);}}}function warnOnHookMismatchInDev(currentHookName){{var componentName=getComponentNameFromFiber(currentlyRenderingFiber$1);if(!didWarnAboutMismatchedHooksForComponent.has(componentName)){didWarnAboutMismatchedHooksForComponent.add(componentName);if(hookTypesDev!==null){var table='';var secondColumnStart=30;for(var i=0;i<=hookTypesUpdateIndexDev;i++){var oldHookName=hookTypesDev[i];var newHookName=i===hookTypesUpdateIndexDev?currentHookName:oldHookName;var row=i+1+". "+oldHookName;// Extra space so second column lines up
// lol @ IE not supporting String#repeat
while(row.length<secondColumnStart){row+=' ';}row+=newHookName+'\n';table+=row;}error('React has detected a change in the order of Hooks called by %s. '+'This will lead to bugs and errors if not fixed. '+'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n'+'   Previous render            Next render\n'+'   ------------------------------------------------------\n'+'%s'+'   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n',componentName,table);}}}}function throwInvalidHookError(){throw new Error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for'+' one of the following reasons:\n'+'1. You might have mismatching versions of React and the renderer (such as React DOM)\n'+'2. You might be breaking the Rules of Hooks\n'+'3. You might have more than one copy of React in the same app\n'+'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');}function areHookInputsEqual(nextDeps,prevDeps){{if(ignorePreviousDependencies){// Only true when this component is being hot reloaded.
return false;}}if(prevDeps===null){{error('%s received a final argument during this render, but not during '+'the previous render. Even though the final argument is optional, '+'its type cannot change between renders.',currentHookNameInDev);}return false;}{// Don't bother comparing lengths in prod because these arrays should be
// passed inline.
if(nextDeps.length!==prevDeps.length){error('The final argument passed to %s changed size between renders. The '+'order and size of this array must remain constant.\n\n'+'Previous: %s\n'+'Incoming: %s',currentHookNameInDev,"["+prevDeps.join(', ')+"]","["+nextDeps.join(', ')+"]");}}for(var i=0;i<prevDeps.length&&i<nextDeps.length;i++){if(objectIs(nextDeps[i],prevDeps[i])){continue;}return false;}return true;}function renderWithHooks(current,workInProgress,Component,props,secondArg,nextRenderLanes){renderLanes=nextRenderLanes;currentlyRenderingFiber$1=workInProgress;{hookTypesDev=current!==null?current._debugHookTypes:null;hookTypesUpdateIndexDev=-1;// Used for hot reloading:
ignorePreviousDependencies=current!==null&&current.type!==workInProgress.type;}workInProgress.memoizedState=null;workInProgress.updateQueue=null;workInProgress.lanes=NoLanes;// The following should have already been reset
// currentHook = null;
// workInProgressHook = null;
// didScheduleRenderPhaseUpdate = false;
// localIdCounter = 0;
// TODO Warn if no hooks are used at all during mount, then some are used during update.
// Currently we will identify the update render as a mount because memoizedState === null.
// This is tricky because it's valid for certain types of components (e.g. React.lazy)
// Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.
// Non-stateful hooks (e.g. context) don't get added to memoizedState,
// so memoizedState would be null during updates and mounts.
{if(current!==null&&current.memoizedState!==null){ReactCurrentDispatcher$1.current=HooksDispatcherOnUpdateInDEV;}else if(hookTypesDev!==null){// This dispatcher handles an edge case where a component is updating,
// but no stateful hooks have been used.
// We want to match the production code behavior (which will use HooksDispatcherOnMount),
// but with the extra DEV validation to ensure hooks ordering hasn't changed.
// This dispatcher does that.
ReactCurrentDispatcher$1.current=HooksDispatcherOnMountWithHookTypesInDEV;}else {ReactCurrentDispatcher$1.current=HooksDispatcherOnMountInDEV;}}var children=Component(props,secondArg);// Check if there was a render phase update
if(didScheduleRenderPhaseUpdateDuringThisPass){// Keep rendering in a loop for as long as render phase updates continue to
// be scheduled. Use a counter to prevent infinite loops.
var numberOfReRenders=0;do{didScheduleRenderPhaseUpdateDuringThisPass=false;localIdCounter=0;if(numberOfReRenders>=RE_RENDER_LIMIT){throw new Error('Too many re-renders. React limits the number of renders to prevent '+'an infinite loop.');}numberOfReRenders+=1;{// Even when hot reloading, allow dependencies to stabilize
// after first render to prevent infinite render phase updates.
ignorePreviousDependencies=false;}// Start over from the beginning of the list
currentHook=null;workInProgressHook=null;workInProgress.updateQueue=null;{// Also validate hook order for cascading updates.
hookTypesUpdateIndexDev=-1;}ReactCurrentDispatcher$1.current=HooksDispatcherOnRerenderInDEV;children=Component(props,secondArg);}while(didScheduleRenderPhaseUpdateDuringThisPass);}// We can assume the previous dispatcher is always this one, since we set it
// at the beginning of the render phase and there's no re-entrance.
ReactCurrentDispatcher$1.current=ContextOnlyDispatcher;{workInProgress._debugHookTypes=hookTypesDev;}// This check uses currentHook so that it works the same in DEV and prod bundles.
// hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.
var didRenderTooFewHooks=currentHook!==null&&currentHook.next!==null;renderLanes=NoLanes;currentlyRenderingFiber$1=null;currentHook=null;workInProgressHook=null;{currentHookNameInDev=null;hookTypesDev=null;hookTypesUpdateIndexDev=-1;// Confirm that a static flag was not added or removed since the last
// render. If this fires, it suggests that we incorrectly reset the static
// flags in some other part of the codebase. This has happened before, for
// example, in the SuspenseList implementation.
if(current!==null&&(current.flags&StaticMask)!==(workInProgress.flags&StaticMask)&&// Disable this warning in legacy mode, because legacy Suspense is weird
// and creates false positives. To make this work in legacy mode, we'd
// need to mark fibers that commit in an incomplete state, somehow. For
// now I'll disable the warning that most of the bugs that would trigger
// it are either exclusive to concurrent mode or exist in both.
(current.mode&ConcurrentMode)!==NoMode){error('Internal React error: Expected static flag was missing. Please '+'notify the React team.');}}didScheduleRenderPhaseUpdate=false;// This is reset by checkDidRenderIdHook
// localIdCounter = 0;
if(didRenderTooFewHooks){throw new Error('Rendered fewer hooks than expected. This may be caused by an accidental '+'early return statement.');}return children;}function checkDidRenderIdHook(){// This should be called immediately after every renderWithHooks call.
// Conceptually, it's part of the return value of renderWithHooks; it's only a
// separate function to avoid using an array tuple.
var didRenderIdHook=localIdCounter!==0;localIdCounter=0;return didRenderIdHook;}function bailoutHooks(current,workInProgress,lanes){workInProgress.updateQueue=current.updateQueue;// TODO: Don't need to reset the flags here, because they're reset in the
// complete phase (bubbleProperties).
if((workInProgress.mode&StrictEffectsMode)!==NoMode){workInProgress.flags&=~(MountPassiveDev|MountLayoutDev|Passive|Update);}else {workInProgress.flags&=~(Passive|Update);}current.lanes=removeLanes(current.lanes,lanes);}function resetHooksAfterThrow(){// We can assume the previous dispatcher is always this one, since we set it
// at the beginning of the render phase and there's no re-entrance.
ReactCurrentDispatcher$1.current=ContextOnlyDispatcher;if(didScheduleRenderPhaseUpdate){// There were render phase updates. These are only valid for this render
// phase, which we are now aborting. Remove the updates from the queues so
// they do not persist to the next render. Do not remove updates from hooks
// that weren't processed.
//
// Only reset the updates from the queue if it has a clone. If it does
// not have a clone, that means it wasn't processed, and the updates were
// scheduled before we entered the render phase.
var hook=currentlyRenderingFiber$1.memoizedState;while(hook!==null){var queue=hook.queue;if(queue!==null){queue.pending=null;}hook=hook.next;}didScheduleRenderPhaseUpdate=false;}renderLanes=NoLanes;currentlyRenderingFiber$1=null;currentHook=null;workInProgressHook=null;{hookTypesDev=null;hookTypesUpdateIndexDev=-1;currentHookNameInDev=null;isUpdatingOpaqueValueInRenderPhase=false;}didScheduleRenderPhaseUpdateDuringThisPass=false;localIdCounter=0;}function mountWorkInProgressHook(){var hook={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};if(workInProgressHook===null){// This is the first hook in the list
currentlyRenderingFiber$1.memoizedState=workInProgressHook=hook;}else {// Append to the end of the list
workInProgressHook=workInProgressHook.next=hook;}return workInProgressHook;}function updateWorkInProgressHook(){// This function is used both for updates and for re-renders triggered by a
// render phase update. It assumes there is either a current hook we can
// clone, or a work-in-progress hook from a previous render pass that we can
// use as a base. When we reach the end of the base list, we must switch to
// the dispatcher used for mounts.
var nextCurrentHook;if(currentHook===null){var current=currentlyRenderingFiber$1.alternate;if(current!==null){nextCurrentHook=current.memoizedState;}else {nextCurrentHook=null;}}else {nextCurrentHook=currentHook.next;}var nextWorkInProgressHook;if(workInProgressHook===null){nextWorkInProgressHook=currentlyRenderingFiber$1.memoizedState;}else {nextWorkInProgressHook=workInProgressHook.next;}if(nextWorkInProgressHook!==null){// There's already a work-in-progress. Reuse it.
workInProgressHook=nextWorkInProgressHook;nextWorkInProgressHook=workInProgressHook.next;currentHook=nextCurrentHook;}else {// Clone from the current hook.
if(nextCurrentHook===null){throw new Error('Rendered more hooks than during the previous render.');}currentHook=nextCurrentHook;var newHook={memoizedState:currentHook.memoizedState,baseState:currentHook.baseState,baseQueue:currentHook.baseQueue,queue:currentHook.queue,next:null};if(workInProgressHook===null){// This is the first hook in the list.
currentlyRenderingFiber$1.memoizedState=workInProgressHook=newHook;}else {// Append to the end of the list.
workInProgressHook=workInProgressHook.next=newHook;}}return workInProgressHook;}function createFunctionComponentUpdateQueue(){return {lastEffect:null,stores:null};}function basicStateReducer(state,action){// $FlowFixMe: Flow doesn't like mixed types
return typeof action==='function'?action(state):action;}function mountReducer(reducer,initialArg,init){var hook=mountWorkInProgressHook();var initialState;if(init!==undefined){initialState=init(initialArg);}else {initialState=initialArg;}hook.memoizedState=hook.baseState=initialState;var queue={pending:null,interleaved:null,lanes:NoLanes,dispatch:null,lastRenderedReducer:reducer,lastRenderedState:initialState};hook.queue=queue;var dispatch=queue.dispatch=dispatchReducerAction.bind(null,currentlyRenderingFiber$1,queue);return [hook.memoizedState,dispatch];}function updateReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook();var queue=hook.queue;if(queue===null){throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');}queue.lastRenderedReducer=reducer;var current=currentHook;// The last rebase update that is NOT part of the base state.
var baseQueue=current.baseQueue;// The last pending update that hasn't been processed yet.
var pendingQueue=queue.pending;if(pendingQueue!==null){// We have new updates that haven't been processed yet.
// We'll add them to the base queue.
if(baseQueue!==null){// Merge the pending queue and the base queue.
var baseFirst=baseQueue.next;var pendingFirst=pendingQueue.next;baseQueue.next=pendingFirst;pendingQueue.next=baseFirst;}{if(current.baseQueue!==baseQueue){// Internal invariant that should never happen, but feasibly could in
// the future if we implement resuming, or some form of that.
error('Internal error: Expected work-in-progress queue to be a clone. '+'This is a bug in React.');}}current.baseQueue=baseQueue=pendingQueue;queue.pending=null;}if(baseQueue!==null){// We have a queue to process.
var first=baseQueue.next;var newState=current.baseState;var newBaseState=null;var newBaseQueueFirst=null;var newBaseQueueLast=null;var update=first;do{var updateLane=update.lane;if(!isSubsetOfLanes(renderLanes,updateLane)){// Priority is insufficient. Skip this update. If this is the first
// skipped update, the previous update/state is the new base
// update/state.
var clone={lane:updateLane,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null};if(newBaseQueueLast===null){newBaseQueueFirst=newBaseQueueLast=clone;newBaseState=newState;}else {newBaseQueueLast=newBaseQueueLast.next=clone;}// Update the remaining priority in the queue.
// TODO: Don't need to accumulate this. Instead, we can remove
// renderLanes from the original lanes.
currentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,updateLane);markSkippedUpdateLanes(updateLane);}else {// This update does have sufficient priority.
if(newBaseQueueLast!==null){var _clone={// This update is going to be committed so we never want uncommit
// it. Using NoLane works because 0 is a subset of all bitmasks, so
// this will never be skipped by the check above.
lane:NoLane,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null};newBaseQueueLast=newBaseQueueLast.next=_clone;}// Process this update.
if(update.hasEagerState){// If this update is a state update (not a reducer) and was processed eagerly,
// we can use the eagerly computed state
newState=update.eagerState;}else {var action=update.action;newState=reducer(newState,action);}}update=update.next;}while(update!==null&&update!==first);if(newBaseQueueLast===null){newBaseState=newState;}else {newBaseQueueLast.next=newBaseQueueFirst;}// Mark that the fiber performed work, but only if the new state is
// different from the current state.
if(!objectIs(newState,hook.memoizedState)){markWorkInProgressReceivedUpdate();}hook.memoizedState=newState;hook.baseState=newBaseState;hook.baseQueue=newBaseQueueLast;queue.lastRenderedState=newState;}// Interleaved updates are stored on a separate queue. We aren't going to
// process them during this render, but we do need to track which lanes
// are remaining.
var lastInterleaved=queue.interleaved;if(lastInterleaved!==null){var interleaved=lastInterleaved;do{var interleavedLane=interleaved.lane;currentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,interleavedLane);markSkippedUpdateLanes(interleavedLane);interleaved=interleaved.next;}while(interleaved!==lastInterleaved);}else if(baseQueue===null){// `queue.lanes` is used for entangling transitions. We can set it back to
// zero once the queue is empty.
queue.lanes=NoLanes;}var dispatch=queue.dispatch;return [hook.memoizedState,dispatch];}function rerenderReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook();var queue=hook.queue;if(queue===null){throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');}queue.lastRenderedReducer=reducer;// This is a re-render. Apply the new render phase updates to the previous
// work-in-progress hook.
var dispatch=queue.dispatch;var lastRenderPhaseUpdate=queue.pending;var newState=hook.memoizedState;if(lastRenderPhaseUpdate!==null){// The queue doesn't persist past this render pass.
queue.pending=null;var firstRenderPhaseUpdate=lastRenderPhaseUpdate.next;var update=firstRenderPhaseUpdate;do{// Process this render phase update. We don't have to check the
// priority because it will always be the same as the current
// render's.
var action=update.action;newState=reducer(newState,action);update=update.next;}while(update!==firstRenderPhaseUpdate);// Mark that the fiber performed work, but only if the new state is
// different from the current state.
if(!objectIs(newState,hook.memoizedState)){markWorkInProgressReceivedUpdate();}hook.memoizedState=newState;// Don't persist the state accumulated from the render phase updates to
// the base state unless the queue is empty.
// TODO: Not sure if this is the desired semantics, but it's what we
// do for gDSFP. I can't remember why.
if(hook.baseQueue===null){hook.baseState=newState;}queue.lastRenderedState=newState;}return [newState,dispatch];}function mountMutableSource(source,getSnapshot,subscribe){{return undefined;}}function updateMutableSource(source,getSnapshot,subscribe){{return undefined;}}function mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){var fiber=currentlyRenderingFiber$1;var hook=mountWorkInProgressHook();var nextSnapshot;var isHydrating=getIsHydrating();if(isHydrating){if(getServerSnapshot===undefined){throw new Error('Missing getServerSnapshot, which is required for '+'server-rendered content. Will revert to client rendering.');}nextSnapshot=getServerSnapshot();{if(!didWarnUncachedGetSnapshot){if(nextSnapshot!==getServerSnapshot()){error('The result of getServerSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}}else {nextSnapshot=getSnapshot();{if(!didWarnUncachedGetSnapshot){var cachedSnapshot=getSnapshot();if(!objectIs(nextSnapshot,cachedSnapshot)){error('The result of getSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}// Unless we're rendering a blocking lane, schedule a consistency check.
// Right before committing, we will walk the tree and check if any of the
// stores were mutated.
//
// We won't do this if we're hydrating server-rendered content, because if
// the content is stale, it's already visible anyway. Instead we'll patch
// it up in a passive effect.
var root=getWorkInProgressRoot();if(root===null){throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');}if(!includesBlockingLane(root,renderLanes)){pushStoreConsistencyCheck(fiber,getSnapshot,nextSnapshot);}}// Read the current snapshot from the store on every render. This breaks the
// normal rules of React, and only works because store updates are
// always synchronous.
hook.memoizedState=nextSnapshot;var inst={value:nextSnapshot,getSnapshot:getSnapshot};hook.queue=inst;// Schedule an effect to subscribe to the store.
mountEffect(subscribeToStore.bind(null,fiber,inst,subscribe),[subscribe]);// Schedule an effect to update the mutable instance fields. We will update
// this whenever subscribe, getSnapshot, or value changes. Because there's no
// clean-up function, and we track the deps correctly, we can call pushEffect
// directly, without storing any additional state. For the same reason, we
// don't need to set a static flag, either.
// TODO: We can move this to the passive phase once we add a pre-commit
// consistency check. See the next comment.
fiber.flags|=Passive;pushEffect(HasEffect|Passive$1,updateStoreInstance.bind(null,fiber,inst,nextSnapshot,getSnapshot),undefined,null);return nextSnapshot;}function updateSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){var fiber=currentlyRenderingFiber$1;var hook=updateWorkInProgressHook();// Read the current snapshot from the store on every render. This breaks the
// normal rules of React, and only works because store updates are
// always synchronous.
var nextSnapshot=getSnapshot();{if(!didWarnUncachedGetSnapshot){var cachedSnapshot=getSnapshot();if(!objectIs(nextSnapshot,cachedSnapshot)){error('The result of getSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}var prevSnapshot=hook.memoizedState;var snapshotChanged=!objectIs(prevSnapshot,nextSnapshot);if(snapshotChanged){hook.memoizedState=nextSnapshot;markWorkInProgressReceivedUpdate();}var inst=hook.queue;updateEffect(subscribeToStore.bind(null,fiber,inst,subscribe),[subscribe]);// Whenever getSnapshot or subscribe changes, we need to check in the
// commit phase if there was an interleaved mutation. In concurrent mode
// this can happen all the time, but even in synchronous mode, an earlier
// effect may have mutated the store.
if(inst.getSnapshot!==getSnapshot||snapshotChanged||// Check if the susbcribe function changed. We can save some memory by
// checking whether we scheduled a subscription effect above.
workInProgressHook!==null&&workInProgressHook.memoizedState.tag&HasEffect){fiber.flags|=Passive;pushEffect(HasEffect|Passive$1,updateStoreInstance.bind(null,fiber,inst,nextSnapshot,getSnapshot),undefined,null);// Unless we're rendering a blocking lane, schedule a consistency check.
// Right before committing, we will walk the tree and check if any of the
// stores were mutated.
var root=getWorkInProgressRoot();if(root===null){throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');}if(!includesBlockingLane(root,renderLanes)){pushStoreConsistencyCheck(fiber,getSnapshot,nextSnapshot);}}return nextSnapshot;}function pushStoreConsistencyCheck(fiber,getSnapshot,renderedSnapshot){fiber.flags|=StoreConsistency;var check={getSnapshot:getSnapshot,value:renderedSnapshot};var componentUpdateQueue=currentlyRenderingFiber$1.updateQueue;if(componentUpdateQueue===null){componentUpdateQueue=createFunctionComponentUpdateQueue();currentlyRenderingFiber$1.updateQueue=componentUpdateQueue;componentUpdateQueue.stores=[check];}else {var stores=componentUpdateQueue.stores;if(stores===null){componentUpdateQueue.stores=[check];}else {stores.push(check);}}}function updateStoreInstance(fiber,inst,nextSnapshot,getSnapshot){// These are updated in the passive phase
inst.value=nextSnapshot;inst.getSnapshot=getSnapshot;// Something may have been mutated in between render and commit. This could
// have been in an event that fired before the passive effects, or it could
// have been in a layout effect. In that case, we would have used the old
// snapsho and getSnapshot values to bail out. We need to check one more time.
if(checkIfSnapshotChanged(inst)){// Force a re-render.
forceStoreRerender(fiber);}}function subscribeToStore(fiber,inst,subscribe){var handleStoreChange=function(){// The store changed. Check if the snapshot changed since the last time we
// read from the store.
if(checkIfSnapshotChanged(inst)){// Force a re-render.
forceStoreRerender(fiber);}};// Subscribe to the store and return a clean-up function.
return subscribe(handleStoreChange);}function checkIfSnapshotChanged(inst){var latestGetSnapshot=inst.getSnapshot;var prevValue=inst.value;try{var nextValue=latestGetSnapshot();return !objectIs(prevValue,nextValue);}catch(error){return true;}}function forceStoreRerender(fiber){var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}function mountState(initialState){var hook=mountWorkInProgressHook();if(typeof initialState==='function'){// $FlowFixMe: Flow doesn't like mixed types
initialState=initialState();}hook.memoizedState=hook.baseState=initialState;var queue={pending:null,interleaved:null,lanes:NoLanes,dispatch:null,lastRenderedReducer:basicStateReducer,lastRenderedState:initialState};hook.queue=queue;var dispatch=queue.dispatch=dispatchSetState.bind(null,currentlyRenderingFiber$1,queue);return [hook.memoizedState,dispatch];}function updateState(initialState){return updateReducer(basicStateReducer);}function rerenderState(initialState){return rerenderReducer(basicStateReducer);}function pushEffect(tag,create,destroy,deps){var effect={tag:tag,create:create,destroy:destroy,deps:deps,// Circular
next:null};var componentUpdateQueue=currentlyRenderingFiber$1.updateQueue;if(componentUpdateQueue===null){componentUpdateQueue=createFunctionComponentUpdateQueue();currentlyRenderingFiber$1.updateQueue=componentUpdateQueue;componentUpdateQueue.lastEffect=effect.next=effect;}else {var lastEffect=componentUpdateQueue.lastEffect;if(lastEffect===null){componentUpdateQueue.lastEffect=effect.next=effect;}else {var firstEffect=lastEffect.next;lastEffect.next=effect;effect.next=firstEffect;componentUpdateQueue.lastEffect=effect;}}return effect;}function mountRef(initialValue){var hook=mountWorkInProgressHook();{var _ref2={current:initialValue};hook.memoizedState=_ref2;return _ref2;}}function updateRef(initialValue){var hook=updateWorkInProgressHook();return hook.memoizedState;}function mountEffectImpl(fiberFlags,hookFlags,create,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;currentlyRenderingFiber$1.flags|=fiberFlags;hook.memoizedState=pushEffect(HasEffect|hookFlags,create,undefined,nextDeps);}function updateEffectImpl(fiberFlags,hookFlags,create,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var destroy=undefined;if(currentHook!==null){var prevEffect=currentHook.memoizedState;destroy=prevEffect.destroy;if(nextDeps!==null){var prevDeps=prevEffect.deps;if(areHookInputsEqual(nextDeps,prevDeps)){hook.memoizedState=pushEffect(hookFlags,create,destroy,nextDeps);return;}}}currentlyRenderingFiber$1.flags|=fiberFlags;hook.memoizedState=pushEffect(HasEffect|hookFlags,create,destroy,nextDeps);}function mountEffect(create,deps){if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){return mountEffectImpl(MountPassiveDev|Passive|PassiveStatic,Passive$1,create,deps);}else {return mountEffectImpl(Passive|PassiveStatic,Passive$1,create,deps);}}function updateEffect(create,deps){return updateEffectImpl(Passive,Passive$1,create,deps);}function mountInsertionEffect(create,deps){return mountEffectImpl(Update,Insertion,create,deps);}function updateInsertionEffect(create,deps){return updateEffectImpl(Update,Insertion,create,deps);}function mountLayoutEffect(create,deps){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}return mountEffectImpl(fiberFlags,Layout,create,deps);}function updateLayoutEffect(create,deps){return updateEffectImpl(Update,Layout,create,deps);}function imperativeHandleEffect(create,ref){if(typeof ref==='function'){var refCallback=ref;var _inst=create();refCallback(_inst);return function(){refCallback(null);};}else if(ref!==null&&ref!==undefined){var refObject=ref;{if(!refObject.hasOwnProperty('current')){error('Expected useImperativeHandle() first argument to either be a '+'ref callback or React.createRef() object. Instead received: %s.','an object with keys {'+Object.keys(refObject).join(', ')+'}');}}var _inst2=create();refObject.current=_inst2;return function(){refObject.current=null;};}}function mountImperativeHandle(ref,create,deps){{if(typeof create!=='function'){error('Expected useImperativeHandle() second argument to be a function '+'that creates a handle. Instead received: %s.',create!==null?typeof create:'null');}}// TODO: If deps are provided, should we skip comparing the ref itself?
var effectDeps=deps!==null&&deps!==undefined?deps.concat([ref]):null;var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}return mountEffectImpl(fiberFlags,Layout,imperativeHandleEffect.bind(null,create,ref),effectDeps);}function updateImperativeHandle(ref,create,deps){{if(typeof create!=='function'){error('Expected useImperativeHandle() second argument to be a function '+'that creates a handle. Instead received: %s.',create!==null?typeof create:'null');}}// TODO: If deps are provided, should we skip comparing the ref itself?
var effectDeps=deps!==null&&deps!==undefined?deps.concat([ref]):null;return updateEffectImpl(Update,Layout,imperativeHandleEffect.bind(null,create,ref),effectDeps);}function mountDebugValue(value,formatterFn){// This hook is normally a no-op.
// The react-debug-hooks package injects its own implementation
// so that e.g. DevTools can display custom hook values.
}var updateDebugValue=mountDebugValue;function mountCallback(callback,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;hook.memoizedState=[callback,nextDeps];return callback;}function updateCallback(callback,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var prevState=hook.memoizedState;if(prevState!==null){if(nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps)){return prevState[0];}}}hook.memoizedState=[callback,nextDeps];return callback;}function mountMemo(nextCreate,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var nextValue=nextCreate();hook.memoizedState=[nextValue,nextDeps];return nextValue;}function updateMemo(nextCreate,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var prevState=hook.memoizedState;if(prevState!==null){// Assume these are defined. If they're not, areHookInputsEqual will warn.
if(nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps)){return prevState[0];}}}var nextValue=nextCreate();hook.memoizedState=[nextValue,nextDeps];return nextValue;}function mountDeferredValue(value){var hook=mountWorkInProgressHook();hook.memoizedState=value;return value;}function updateDeferredValue(value){var hook=updateWorkInProgressHook();var resolvedCurrentHook=currentHook;var prevValue=resolvedCurrentHook.memoizedState;return updateDeferredValueImpl(hook,prevValue,value);}function rerenderDeferredValue(value){var hook=updateWorkInProgressHook();if(currentHook===null){// This is a rerender during a mount.
hook.memoizedState=value;return value;}else {// This is a rerender during an update.
var prevValue=currentHook.memoizedState;return updateDeferredValueImpl(hook,prevValue,value);}}function updateDeferredValueImpl(hook,prevValue,value){var shouldDeferValue=!includesOnlyNonUrgentLanes(renderLanes);if(shouldDeferValue){// This is an urgent update. If the value has changed, keep using the
// previous value and spawn a deferred render to update it later.
if(!objectIs(value,prevValue)){// Schedule a deferred render
var deferredLane=claimNextTransitionLane();currentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,deferredLane);markSkippedUpdateLanes(deferredLane);// Set this to true to indicate that the rendered value is inconsistent
// from the latest value. The name "baseState" doesn't really match how we
// use it because we're reusing a state hook field instead of creating a
// new one.
hook.baseState=true;}// Reuse the previous value
return prevValue;}else {// This is not an urgent update, so we can use the latest value regardless
// of what it is. No need to defer it.
// However, if we're currently inside a spawned render, then we need to mark
// this as an update to prevent the fiber from bailing out.
//
// `baseState` is true when the current value is different from the rendered
// value. The name doesn't really match how we use it because we're reusing
// a state hook field instead of creating a new one.
if(hook.baseState){// Flip this back to false.
hook.baseState=false;markWorkInProgressReceivedUpdate();}hook.memoizedState=value;return value;}}function startTransition(setPending,callback,options){var previousPriority=getCurrentUpdatePriority();setCurrentUpdatePriority(higherEventPriority(previousPriority,ContinuousEventPriority));setPending(true);var prevTransition=ReactCurrentBatchConfig$2.transition;ReactCurrentBatchConfig$2.transition={};var currentTransition=ReactCurrentBatchConfig$2.transition;{ReactCurrentBatchConfig$2.transition._updatedFibers=new Set();}try{setPending(false);callback();}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$2.transition=prevTransition;{if(prevTransition===null&&currentTransition._updatedFibers){var updatedFibersCount=currentTransition._updatedFibers.size;if(updatedFibersCount>10){warn('Detected a large number of updates inside startTransition. '+'If this is due to a subscription please re-write it to use React provided hooks. '+'Otherwise concurrent mode guarantees are off the table.');}currentTransition._updatedFibers.clear();}}}}function mountTransition(){var _mountState=mountState(false),isPending=_mountState[0],setPending=_mountState[1];// The `start` method never changes.
var start=startTransition.bind(null,setPending);var hook=mountWorkInProgressHook();hook.memoizedState=start;return [isPending,start];}function updateTransition(){var _updateState=updateState(),isPending=_updateState[0];var hook=updateWorkInProgressHook();var start=hook.memoizedState;return [isPending,start];}function rerenderTransition(){var _rerenderState=rerenderState(),isPending=_rerenderState[0];var hook=updateWorkInProgressHook();var start=hook.memoizedState;return [isPending,start];}var isUpdatingOpaqueValueInRenderPhase=false;function getIsUpdatingOpaqueValueInRenderPhaseInDEV(){{return isUpdatingOpaqueValueInRenderPhase;}}function mountId(){var hook=mountWorkInProgressHook();var root=getWorkInProgressRoot();// TODO: In Fizz, id generation is specific to each server config. Maybe we
// should do this in Fiber, too? Deferring this decision for now because
// there's no other place to store the prefix except for an internal field on
// the public createRoot object, which the fiber tree does not currently have
// a reference to.
var identifierPrefix=root.identifierPrefix;var id;if(getIsHydrating()){var treeId=getTreeId();// Use a captial R prefix for server-generated ids.
id=':'+identifierPrefix+'R'+treeId;// Unless this is the first id at this level, append a number at the end
// that represents the position of this useId hook among all the useId
// hooks for this fiber.
var localId=localIdCounter++;if(localId>0){id+='H'+localId.toString(32);}id+=':';}else {// Use a lowercase r prefix for client-generated ids.
var globalClientId=globalClientIdCounter++;id=':'+identifierPrefix+'r'+globalClientId.toString(32)+':';}hook.memoizedState=id;return id;}function updateId(){var hook=updateWorkInProgressHook();var id=hook.memoizedState;return id;}function dispatchReducerAction(fiber,queue,action){{if(typeof arguments[3]==='function'){error("State updates from the useState() and useReducer() Hooks don't support the "+'second callback argument. To execute a side effect after '+'rendering, declare it in the component body with useEffect().');}}var lane=requestUpdateLane(fiber);var update={lane:lane,action:action,hasEagerState:false,eagerState:null,next:null};if(isRenderPhaseUpdate(fiber)){enqueueRenderPhaseUpdate(queue,update);}else {var root=enqueueConcurrentHookUpdate(fiber,queue,update,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitionUpdate(root,queue,lane);}}markUpdateInDevTools(fiber,lane);}function dispatchSetState(fiber,queue,action){{if(typeof arguments[3]==='function'){error("State updates from the useState() and useReducer() Hooks don't support the "+'second callback argument. To execute a side effect after '+'rendering, declare it in the component body with useEffect().');}}var lane=requestUpdateLane(fiber);var update={lane:lane,action:action,hasEagerState:false,eagerState:null,next:null};if(isRenderPhaseUpdate(fiber)){enqueueRenderPhaseUpdate(queue,update);}else {var alternate=fiber.alternate;if(fiber.lanes===NoLanes&&(alternate===null||alternate.lanes===NoLanes)){// The queue is currently empty, which means we can eagerly compute the
// next state before entering the render phase. If the new state is the
// same as the current state, we may be able to bail out entirely.
var lastRenderedReducer=queue.lastRenderedReducer;if(lastRenderedReducer!==null){var prevDispatcher;{prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;}try{var currentState=queue.lastRenderedState;var eagerState=lastRenderedReducer(currentState,action);// Stash the eagerly computed state, and the reducer used to compute
// it, on the update object. If the reducer hasn't changed by the
// time we enter the render phase, then the eager state can be used
// without calling the reducer again.
update.hasEagerState=true;update.eagerState=eagerState;if(objectIs(eagerState,currentState)){// Fast path. We can bail out without scheduling React to re-render.
// It's still possible that we'll need to rebase this update later,
// if the component re-renders for a different reason and by that
// time the reducer has changed.
// TODO: Do we still need to entangle transitions in this case?
enqueueConcurrentHookUpdateAndEagerlyBailout(fiber,queue,update,lane);return;}}catch(error){// Suppress the error. It will throw again in the render phase.
}finally{{ReactCurrentDispatcher$1.current=prevDispatcher;}}}}var root=enqueueConcurrentHookUpdate(fiber,queue,update,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitionUpdate(root,queue,lane);}}markUpdateInDevTools(fiber,lane);}function isRenderPhaseUpdate(fiber){var alternate=fiber.alternate;return fiber===currentlyRenderingFiber$1||alternate!==null&&alternate===currentlyRenderingFiber$1;}function enqueueRenderPhaseUpdate(queue,update){// This is a render phase update. Stash it in a lazily-created map of
// queue -> linked list of updates. After this render pass, we'll restart
// and apply the stashed updates on top of the work-in-progress hook.
didScheduleRenderPhaseUpdateDuringThisPass=didScheduleRenderPhaseUpdate=true;var pending=queue.pending;if(pending===null){// This is the first update. Create a circular list.
update.next=update;}else {update.next=pending.next;pending.next=update;}queue.pending=update;}// TODO: Move to ReactFiberConcurrentUpdates?
function entangleTransitionUpdate(root,queue,lane){if(isTransitionLane(lane)){var queueLanes=queue.lanes;// If any entangled lanes are no longer pending on the root, then they
// must have finished. We can remove them from the shared queue, which
// represents a superset of the actually pending lanes. In some cases we
// may entangle more than we need to, but that's OK. In fact it's worse if
// we *don't* entangle when we should.
queueLanes=intersectLanes(queueLanes,root.pendingLanes);// Entangle the new transition lane with the other transition lanes.
var newQueueLanes=mergeLanes(queueLanes,lane);queue.lanes=newQueueLanes;// Even if queue.lanes already include lane, we don't know for certain if
// the lane finished since the last time we entangled it. So we need to
// entangle it again, just to be sure.
markRootEntangled(root,newQueueLanes);}}function markUpdateInDevTools(fiber,lane,action){{markStateUpdateScheduled(fiber,lane);}}var ContextOnlyDispatcher={readContext:readContext,useCallback:throwInvalidHookError,useContext:throwInvalidHookError,useEffect:throwInvalidHookError,useImperativeHandle:throwInvalidHookError,useInsertionEffect:throwInvalidHookError,useLayoutEffect:throwInvalidHookError,useMemo:throwInvalidHookError,useReducer:throwInvalidHookError,useRef:throwInvalidHookError,useState:throwInvalidHookError,useDebugValue:throwInvalidHookError,useDeferredValue:throwInvalidHookError,useTransition:throwInvalidHookError,useMutableSource:throwInvalidHookError,useSyncExternalStore:throwInvalidHookError,useId:throwInvalidHookError,unstable_isNewReconciler:enableNewReconciler};var HooksDispatcherOnMountInDEV=null;var HooksDispatcherOnMountWithHookTypesInDEV=null;var HooksDispatcherOnUpdateInDEV=null;var HooksDispatcherOnRerenderInDEV=null;var InvalidNestedHooksDispatcherOnMountInDEV=null;var InvalidNestedHooksDispatcherOnUpdateInDEV=null;var InvalidNestedHooksDispatcherOnRerenderInDEV=null;{var warnInvalidContextAccess=function(){error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');};var warnInvalidHookAccess=function(){error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. '+'You can only call Hooks at the top level of your React function. '+'For more information, see '+'https://reactjs.org/link/rules-of-hooks');};HooksDispatcherOnMountInDEV={readContext:function(context){return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';mountHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';mountHookTypesDev();checkDepsAreArrayDev(deps);var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';mountHookTypesDev();return mountRef(initialValue);},useState:function(initialState){currentHookNameInDev='useState';mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';mountHookTypesDev();return mountDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';mountHookTypesDev();return mountDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';mountHookTypesDev();return mountTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';mountHookTypesDev();return mountMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';mountHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function(){currentHookNameInDev='useId';mountHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnMountWithHookTypesInDEV={readContext:function(context){return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return mountCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';updateHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return mountEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return mountInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return mountLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return mountRef(initialValue);},useState:function(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return mountDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return mountDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';updateHookTypesDev();return mountTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return mountMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function(){currentHookNameInDev='useId';updateHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnUpdateInDEV={readContext:function(context){return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return updateCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';updateHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return updateRef();},useState:function(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return updateDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return updateDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';updateHookTypesDev();return updateTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function(){currentHookNameInDev='useId';updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnRerenderInDEV={readContext:function(context){return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return updateCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';updateHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return updateRef();},useState:function(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return updateDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return rerenderDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';updateHookTypesDev();return rerenderTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function(){currentHookNameInDev='useId';updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnMountInDEV={readContext:function(context){warnInvalidContextAccess();return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();mountHookTypesDev();return mountCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';warnInvalidHookAccess();mountHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();mountHookTypesDev();return mountEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();mountHookTypesDev();return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();mountHookTypesDev();return mountInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();mountHookTypesDev();return mountLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();mountHookTypesDev();return mountRef(initialValue);},useState:function(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();mountHookTypesDev();return mountDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();mountHookTypesDev();return mountDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';warnInvalidHookAccess();mountHookTypesDev();return mountTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();mountHookTypesDev();return mountMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();mountHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function(){currentHookNameInDev='useId';warnInvalidHookAccess();mountHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnUpdateInDEV={readContext:function(context){warnInvalidContextAccess();return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();updateHookTypesDev();return updateCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';warnInvalidHookAccess();updateHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();updateHookTypesDev();return updateRef();},useState:function(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();updateHookTypesDev();return updateDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();updateHookTypesDev();return updateDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';warnInvalidHookAccess();updateHookTypesDev();return updateTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function(){currentHookNameInDev='useId';warnInvalidHookAccess();updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnRerenderInDEV={readContext:function(context){warnInvalidContextAccess();return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();updateHookTypesDev();return updateCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';warnInvalidHookAccess();updateHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();updateHookTypesDev();return updateRef();},useState:function(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();updateHookTypesDev();return updateDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();updateHookTypesDev();return rerenderDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';warnInvalidHookAccess();updateHookTypesDev();return rerenderTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function(){currentHookNameInDev='useId';warnInvalidHookAccess();updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};}var now$1=Scheduler.unstable_now;var commitTime=0;var layoutEffectStartTime=-1;var profilerStartTime=-1;var passiveEffectStartTime=-1;/**
 * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect).
 *
 * The overall sequence is:
 *   1. render
 *   2. commit (and call `onRender`, `onCommit`)
 *   3. check for nested updates
 *   4. flush passive effects (and call `onPostCommit`)
 *
 * Nested updates are identified in step 3 above,
 * but step 4 still applies to the work that was just committed.
 * We use two flags to track nested updates then:
 * one tracks whether the upcoming update is a nested update,
 * and the other tracks whether the current update was a nested update.
 * The first value gets synced to the second at the start of the render phase.
 */var currentUpdateIsNested=false;var nestedUpdateScheduled=false;function isCurrentUpdateNested(){return currentUpdateIsNested;}function markNestedUpdateScheduled(){{nestedUpdateScheduled=true;}}function resetNestedUpdateFlag(){{currentUpdateIsNested=false;nestedUpdateScheduled=false;}}function syncNestedUpdateFlag(){{currentUpdateIsNested=nestedUpdateScheduled;nestedUpdateScheduled=false;}}function getCommitTime(){return commitTime;}function recordCommitTime(){commitTime=now$1();}function startProfilerTimer(fiber){profilerStartTime=now$1();if(fiber.actualStartTime<0){fiber.actualStartTime=now$1();}}function stopProfilerTimerIfRunning(fiber){profilerStartTime=-1;}function stopProfilerTimerIfRunningAndRecordDelta(fiber,overrideBaseTime){if(profilerStartTime>=0){var elapsedTime=now$1()-profilerStartTime;fiber.actualDuration+=elapsedTime;if(overrideBaseTime){fiber.selfBaseDuration=elapsedTime;}profilerStartTime=-1;}}function recordLayoutEffectDuration(fiber){if(layoutEffectStartTime>=0){var elapsedTime=now$1()-layoutEffectStartTime;layoutEffectStartTime=-1;// Store duration on the next nearest Profiler ancestor
// Or the root (for the DevTools Profiler to read)
var parentFiber=fiber.return;while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.effectDuration+=elapsedTime;return;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.effectDuration+=elapsedTime;return;}parentFiber=parentFiber.return;}}}function recordPassiveEffectDuration(fiber){if(passiveEffectStartTime>=0){var elapsedTime=now$1()-passiveEffectStartTime;passiveEffectStartTime=-1;// Store duration on the next nearest Profiler ancestor
// Or the root (for the DevTools Profiler to read)
var parentFiber=fiber.return;while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;if(root!==null){root.passiveEffectDuration+=elapsedTime;}return;case Profiler:var parentStateNode=parentFiber.stateNode;if(parentStateNode!==null){// Detached fibers have their state node cleared out.
// In this case, the return pointer is also cleared out,
// so we won't be able to report the time spent in this Profiler's subtree.
parentStateNode.passiveEffectDuration+=elapsedTime;}return;}parentFiber=parentFiber.return;}}}function startLayoutEffectTimer(){layoutEffectStartTime=now$1();}function startPassiveEffectTimer(){passiveEffectStartTime=now$1();}function transferActualDuration(fiber){// Transfer time spent rendering these children so we don't lose it
// after we rerender. This is used as a helper in special cases
// where we should count the work of multiple passes.
var child=fiber.child;while(child){fiber.actualDuration+=child.actualDuration;child=child.sibling;}}function createCapturedValueAtFiber(value,source){// If the value is an error, call this function immediately after it is thrown
// so the stack is accurate.
return {value:value,source:source,stack:getStackByFiberInDevAndProd(source),digest:null};}function createCapturedValue(value,digest,stack){return {value:value,source:null,stack:stack!=null?stack:null,digest:digest!=null?digest:null};}// This module is forked in different environments.
// By default, return `true` to log errors to the console.
// Forks can return `false` if this isn't desirable.
function showErrorDialog(boundary,errorInfo){return true;}function logCapturedError(boundary,errorInfo){try{var logError=showErrorDialog(boundary,errorInfo);// Allow injected showErrorDialog() to prevent default console.error logging.
// This enables renderers like ReactNative to better manage redbox behavior.
if(logError===false){return;}var error=errorInfo.value;if(true){var source=errorInfo.source;var stack=errorInfo.stack;var componentStack=stack!==null?stack:'';// Browsers support silencing uncaught errors by calling
// `preventDefault()` in window `error` handler.
// We record this information as an expando on the error.
if(error!=null&&error._suppressLogging){if(boundary.tag===ClassComponent){// The error is recoverable and was silenced.
// Ignore it and don't print the stack addendum.
// This is handy for testing error boundaries without noise.
return;}// The error is fatal. Since the silencing might have
// been accidental, we'll surface it anyway.
// However, the browser would have silenced the original error
// so we'll print it first, and then print the stack addendum.
console['error'](error);// Don't transform to our wrapper
// For a more detailed description of this block, see:
// https://github.com/facebook/react/pull/13384
}var componentName=source?getComponentNameFromFiber(source):null;var componentNameMessage=componentName?"The above error occurred in the <"+componentName+"> component:":'The above error occurred in one of your React components:';var errorBoundaryMessage;if(boundary.tag===HostRoot){errorBoundaryMessage='Consider adding an error boundary to your tree to customize error handling behavior.\n'+'Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.';}else {var errorBoundaryName=getComponentNameFromFiber(boundary)||'Anonymous';errorBoundaryMessage="React will try to recreate this component tree from scratch "+("using the error boundary you provided, "+errorBoundaryName+".");}var combinedMessage=componentNameMessage+"\n"+componentStack+"\n\n"+(""+errorBoundaryMessage);// In development, we provide our own message with just the component stack.
// We don't include the original error message and JS stack because the browser
// has already printed it. Even if the application swallows the error, it is still
// displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
console['error'](combinedMessage);// Don't transform to our wrapper
}}catch(e){// This method must not throw, or React internal state will get messed up.
// If console.error is overridden, or logCapturedError() shows a dialog that throws,
// we want to report this error outside of the normal stack as a last resort.
// https://github.com/facebook/react/issues/13188
setTimeout(function(){throw e;});}}var PossiblyWeakMap$1=typeof WeakMap==='function'?WeakMap:Map;function createRootErrorUpdate(fiber,errorInfo,lane){var update=createUpdate(NoTimestamp,lane);// Unmount the root by rendering null.
update.tag=CaptureUpdate;// Caution: React DevTools currently depends on this property
// being called "element".
update.payload={element:null};var error=errorInfo.value;update.callback=function(){onUncaughtError(error);logCapturedError(fiber,errorInfo);};return update;}function createClassErrorUpdate(fiber,errorInfo,lane){var update=createUpdate(NoTimestamp,lane);update.tag=CaptureUpdate;var getDerivedStateFromError=fiber.type.getDerivedStateFromError;if(typeof getDerivedStateFromError==='function'){var error$1=errorInfo.value;update.payload=function(){return getDerivedStateFromError(error$1);};update.callback=function(){{markFailedErrorBoundaryForHotReloading(fiber);}logCapturedError(fiber,errorInfo);};}var inst=fiber.stateNode;if(inst!==null&&typeof inst.componentDidCatch==='function'){update.callback=function callback(){{markFailedErrorBoundaryForHotReloading(fiber);}logCapturedError(fiber,errorInfo);if(typeof getDerivedStateFromError!=='function'){// To preserve the preexisting retry behavior of error boundaries,
// we keep track of which ones already failed during this batch.
// This gets reset before we yield back to the browser.
// TODO: Warn in strict mode if getDerivedStateFromError is
// not defined.
markLegacyErrorBoundaryAsFailed(this);}var error$1=errorInfo.value;var stack=errorInfo.stack;this.componentDidCatch(error$1,{componentStack:stack!==null?stack:''});{if(typeof getDerivedStateFromError!=='function'){// If componentDidCatch is the only error boundary method defined,
// then it needs to call setState to recover from errors.
// If no state update is scheduled then the boundary will swallow the error.
if(!includesSomeLane(fiber.lanes,SyncLane)){error('%s: Error boundaries should implement getDerivedStateFromError(). '+'In that method, return a state update to display an error message or fallback UI.',getComponentNameFromFiber(fiber)||'Unknown');}}}};}return update;}function attachPingListener(root,wakeable,lanes){// Attach a ping listener
//
// The data might resolve before we have a chance to commit the fallback. Or,
// in the case of a refresh, we'll never commit a fallback. So we need to
// attach a listener now. When it resolves ("pings"), we can decide whether to
// try rendering the tree again.
//
// Only attach a listener if one does not already exist for the lanes
// we're currently rendering (which acts like a "thread ID" here).
//
// We only need to do this in concurrent mode. Legacy Suspense always
// commits fallbacks synchronously, so there are no pings.
var pingCache=root.pingCache;var threadIDs;if(pingCache===null){pingCache=root.pingCache=new PossiblyWeakMap$1();threadIDs=new Set();pingCache.set(wakeable,threadIDs);}else {threadIDs=pingCache.get(wakeable);if(threadIDs===undefined){threadIDs=new Set();pingCache.set(wakeable,threadIDs);}}if(!threadIDs.has(lanes)){// Memoize using the thread ID to prevent redundant listeners.
threadIDs.add(lanes);var ping=pingSuspendedRoot.bind(null,root,wakeable,lanes);{if(isDevToolsPresent){// If we have pending work still, restore the original updaters
restorePendingUpdaters(root,lanes);}}wakeable.then(ping,ping);}}function attachRetryListener(suspenseBoundary,root,wakeable,lanes){// Retry listener
//
// If the fallback does commit, we need to attach a different type of
// listener. This one schedules an update on the Suspense boundary to turn
// the fallback state off.
//
// Stash the wakeable on the boundary fiber so we can access it in the
// commit phase.
//
// When the wakeable resolves, we'll attempt to render the boundary
// again ("retry").
var wakeables=suspenseBoundary.updateQueue;if(wakeables===null){var updateQueue=new Set();updateQueue.add(wakeable);suspenseBoundary.updateQueue=updateQueue;}else {wakeables.add(wakeable);}}function resetSuspendedComponent(sourceFiber,rootRenderLanes){// A legacy mode Suspense quirk, only relevant to hook components.
var tag=sourceFiber.tag;if((sourceFiber.mode&ConcurrentMode)===NoMode&&(tag===FunctionComponent||tag===ForwardRef||tag===SimpleMemoComponent)){var currentSource=sourceFiber.alternate;if(currentSource){sourceFiber.updateQueue=currentSource.updateQueue;sourceFiber.memoizedState=currentSource.memoizedState;sourceFiber.lanes=currentSource.lanes;}else {sourceFiber.updateQueue=null;sourceFiber.memoizedState=null;}}}function getNearestSuspenseBoundaryToCapture(returnFiber){var node=returnFiber;do{if(node.tag===SuspenseComponent&&shouldCaptureSuspense(node)){return node;}// This boundary already captured during this render. Continue to the next
// boundary.
node=node.return;}while(node!==null);return null;}function markSuspenseBoundaryShouldCapture(suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes){// This marks a Suspense boundary so that when we're unwinding the stack,
// it captures the suspended "exception" and does a second (fallback) pass.
if((suspenseBoundary.mode&ConcurrentMode)===NoMode){// Legacy Mode Suspense
//
// If the boundary is in legacy mode, we should *not*
// suspend the commit. Pretend as if the suspended component rendered
// null and keep rendering. When the Suspense boundary completes,
// we'll do a second pass to render the fallback.
if(suspenseBoundary===returnFiber){// Special case where we suspended while reconciling the children of
// a Suspense boundary's inner Offscreen wrapper fiber. This happens
// when a React.lazy component is a direct child of a
// Suspense boundary.
//
// Suspense boundaries are implemented as multiple fibers, but they
// are a single conceptual unit. The legacy mode behavior where we
// pretend the suspended fiber committed as `null` won't work,
// because in this case the "suspended" fiber is the inner
// Offscreen wrapper.
//
// Because the contents of the boundary haven't started rendering
// yet (i.e. nothing in the tree has partially rendered) we can
// switch to the regular, concurrent mode behavior: mark the
// boundary with ShouldCapture and enter the unwind phase.
suspenseBoundary.flags|=ShouldCapture;}else {suspenseBoundary.flags|=DidCapture;sourceFiber.flags|=ForceUpdateForLegacySuspense;// We're going to commit this fiber even though it didn't complete.
// But we shouldn't call any lifecycle methods or callbacks. Remove
// all lifecycle effect tags.
sourceFiber.flags&=~(LifecycleEffectMask|Incomplete);if(sourceFiber.tag===ClassComponent){var currentSourceFiber=sourceFiber.alternate;if(currentSourceFiber===null){// This is a new mount. Change the tag so it's not mistaken for a
// completed class component. For example, we should not call
// componentWillUnmount if it is deleted.
sourceFiber.tag=IncompleteClassComponent;}else {// When we try rendering again, we should not reuse the current fiber,
// since it's known to be in an inconsistent state. Use a force update to
// prevent a bail out.
var update=createUpdate(NoTimestamp,SyncLane);update.tag=ForceUpdate;enqueueUpdate(sourceFiber,update,SyncLane);}}// The source fiber did not complete. Mark it with Sync priority to
// indicate that it still has pending work.
sourceFiber.lanes=mergeLanes(sourceFiber.lanes,SyncLane);}return suspenseBoundary;}// Confirmed that the boundary is in a concurrent mode tree. Continue
// with the normal suspend path.
//
// After this we'll use a set of heuristics to determine whether this
// render pass will run to completion or restart or "suspend" the commit.
// The actual logic for this is spread out in different places.
//
// This first principle is that if we're going to suspend when we complete
// a root, then we should also restart if we get an update or ping that
// might unsuspend it, and vice versa. The only reason to suspend is
// because you think you might want to restart before committing. However,
// it doesn't make sense to restart only while in the period we're suspended.
//
// Restarting too aggressively is also not good because it starves out any
// intermediate loading state. So we use heuristics to determine when.
// Suspense Heuristics
//
// If nothing threw a Promise or all the same fallbacks are already showing,
// then don't suspend/restart.
//
// If this is an initial render of a new tree of Suspense boundaries and
// those trigger a fallback, then don't suspend/restart. We want to ensure
// that we can show the initial loading state as quickly as possible.
//
// If we hit a "Delayed" case, such as when we'd switch from content back into
// a fallback, then we should always suspend/restart. Transitions apply
// to this case. If none is defined, JND is used instead.
//
// If we're already showing a fallback and it gets "retried", allowing us to show
// another level, but there's still an inner boundary that would show a fallback,
// then we suspend/restart for 500ms since the last time we showed a fallback
// anywhere in the tree. This effectively throttles progressive loading into a
// consistent train of commits. This also gives us an opportunity to restart to
// get to the completed state slightly earlier.
//
// If there's ambiguity due to batching it's resolved in preference of:
// 1) "delayed", 2) "initial render", 3) "retry".
//
// We want to ensure that a "busy" state doesn't get force committed. We want to
// ensure that new initial loading states can commit as soon as possible.
suspenseBoundary.flags|=ShouldCapture;// TODO: I think we can remove this, since we now use `DidCapture` in
// the begin phase to prevent an early bailout.
suspenseBoundary.lanes=rootRenderLanes;return suspenseBoundary;}function throwException(root,returnFiber,sourceFiber,value,rootRenderLanes){// The source fiber did not complete.
sourceFiber.flags|=Incomplete;{if(isDevToolsPresent){// If we have pending work still, restore the original updaters
restorePendingUpdaters(root,rootRenderLanes);}}if(value!==null&&typeof value==='object'&&typeof value.then==='function'){// This is a wakeable. The component suspended.
var wakeable=value;resetSuspendedComponent(sourceFiber);{if(getIsHydrating()&&sourceFiber.mode&ConcurrentMode){markDidThrowWhileHydratingDEV();}}var suspenseBoundary=getNearestSuspenseBoundaryToCapture(returnFiber);if(suspenseBoundary!==null){suspenseBoundary.flags&=~ForceClientRender;markSuspenseBoundaryShouldCapture(suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes);// We only attach ping listeners in concurrent mode. Legacy Suspense always
// commits fallbacks synchronously, so there are no pings.
if(suspenseBoundary.mode&ConcurrentMode){attachPingListener(root,wakeable,rootRenderLanes);}attachRetryListener(suspenseBoundary,root,wakeable);return;}else {// No boundary was found. Unless this is a sync update, this is OK.
// We can suspend and wait for more data to arrive.
if(!includesSyncLane(rootRenderLanes)){// This is not a sync update. Suspend. Since we're not activating a
// Suspense boundary, this will unwind all the way to the root without
// performing a second pass to render a fallback. (This is arguably how
// refresh transitions should work, too, since we're not going to commit
// the fallbacks anyway.)
//
// This case also applies to initial hydration.
attachPingListener(root,wakeable,rootRenderLanes);renderDidSuspendDelayIfPossible();return;}// This is a sync/discrete update. We treat this case like an error
// because discrete renders are expected to produce a complete tree
// synchronously to maintain consistency with external state.
var uncaughtSuspenseError=new Error('A component suspended while responding to synchronous input. This '+'will cause the UI to be replaced with a loading indicator. To '+'fix, updates that suspend should be wrapped '+'with startTransition.');// If we're outside a transition, fall through to the regular error path.
// The error will be caught by the nearest suspense boundary.
value=uncaughtSuspenseError;}}else {// This is a regular error, not a Suspense wakeable.
if(getIsHydrating()&&sourceFiber.mode&ConcurrentMode){markDidThrowWhileHydratingDEV();var _suspenseBoundary=getNearestSuspenseBoundaryToCapture(returnFiber);// If the error was thrown during hydration, we may be able to recover by
// discarding the dehydrated content and switching to a client render.
// Instead of surfacing the error, find the nearest Suspense boundary
// and render it again without hydration.
if(_suspenseBoundary!==null){if((_suspenseBoundary.flags&ShouldCapture)===NoFlags){// Set a flag to indicate that we should try rendering the normal
// children again, not the fallback.
_suspenseBoundary.flags|=ForceClientRender;}markSuspenseBoundaryShouldCapture(_suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes);// Even though the user may not be affected by this error, we should
// still log it so it can be fixed.
queueHydrationError(createCapturedValueAtFiber(value,sourceFiber));return;}}}value=createCapturedValueAtFiber(value,sourceFiber);renderDidError(value);// We didn't find a boundary that could handle this type of exception. Start
// over and traverse parent path again, this time treating the exception
// as an error.
var workInProgress=returnFiber;do{switch(workInProgress.tag){case HostRoot:{var _errorInfo=value;workInProgress.flags|=ShouldCapture;var lane=pickArbitraryLane(rootRenderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,lane);var update=createRootErrorUpdate(workInProgress,_errorInfo,lane);enqueueCapturedUpdate(workInProgress,update);return;}case ClassComponent:// Capture and retry
var errorInfo=value;var ctor=workInProgress.type;var instance=workInProgress.stateNode;if((workInProgress.flags&DidCapture)===NoFlags&&(typeof ctor.getDerivedStateFromError==='function'||instance!==null&&typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance))){workInProgress.flags|=ShouldCapture;var _lane=pickArbitraryLane(rootRenderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,_lane);// Schedule the error boundary to re-render using updated state
var _update=createClassErrorUpdate(workInProgress,errorInfo,_lane);enqueueCapturedUpdate(workInProgress,_update);return;}break;}workInProgress=workInProgress.return;}while(workInProgress!==null);}function getSuspendedCache(){{return null;}// This function is called when a Suspense boundary suspends. It returns the
}var ReactCurrentOwner$1=ReactSharedInternals.ReactCurrentOwner;var didReceiveUpdate=false;var didWarnAboutBadClass;var didWarnAboutModulePatternComponent;var didWarnAboutContextTypeOnFunctionComponent;var didWarnAboutGetDerivedStateOnFunctionComponent;var didWarnAboutFunctionRefs;var didWarnAboutReassigningProps;var didWarnAboutRevealOrder;var didWarnAboutTailOptions;{didWarnAboutBadClass={};didWarnAboutModulePatternComponent={};didWarnAboutContextTypeOnFunctionComponent={};didWarnAboutGetDerivedStateOnFunctionComponent={};didWarnAboutFunctionRefs={};didWarnAboutReassigningProps=false;didWarnAboutRevealOrder={};didWarnAboutTailOptions={};}function reconcileChildren(current,workInProgress,nextChildren,renderLanes){if(current===null){// If this is a fresh new component that hasn't been rendered yet, we
// won't update its child set by applying minimal side-effects. Instead,
// we will add them all to the child before it gets rendered. That means
// we can optimize this reconciliation pass by not tracking side-effects.
workInProgress.child=mountChildFibers(workInProgress,null,nextChildren,renderLanes);}else {// If the current child is the same as the work in progress, it means that
// we haven't yet started any work on these children. Therefore, we use
// the clone algorithm to create a copy of all the current children.
// If we had any progressed work already, that is invalid at this point so
// let's throw it out.
workInProgress.child=reconcileChildFibers(workInProgress,current.child,nextChildren,renderLanes);}}function forceUnmountCurrentAndReconcile(current,workInProgress,nextChildren,renderLanes){// This function is fork of reconcileChildren. It's used in cases where we
// want to reconcile without matching against the existing set. This has the
// effect of all current children being unmounted; even if the type and key
// are the same, the old child is unmounted and a new child is created.
//
// To do this, we're going to go through the reconcile algorithm twice. In
// the first pass, we schedule a deletion for all the current children by
// passing null.
workInProgress.child=reconcileChildFibers(workInProgress,current.child,null,renderLanes);// In the second pass, we mount the new children. The trick here is that we
// pass null in place of where we usually pass the current child set. This has
// the effect of remounting all children regardless of whether their
// identities match.
workInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderLanes);}function updateForwardRef(current,workInProgress,Component,nextProps,renderLanes){// TODO: current can be non-null here even if the component
// hasn't yet mounted. This happens after the first render suspends.
// We'll need to figure out if this is fine or can cause issues.
{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement
// because they're only guaranteed to be resolved here.
var innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props
'prop',getComponentNameFromType(Component));}}}var render=Component.render;var ref=workInProgress.ref;// The rest is a fork of updateFunctionComponent
var nextChildren;var hasId;prepareToReadContext(workInProgress,renderLanes);{markComponentRenderStarted(workInProgress);}{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);nextChildren=renderWithHooks(current,workInProgress,render,nextProps,ref,renderLanes);hasId=checkDidRenderIdHook();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{nextChildren=renderWithHooks(current,workInProgress,render,nextProps,ref,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}if(current!==null&&!didReceiveUpdate){bailoutHooks(current,workInProgress,renderLanes);return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}// React DevTools reads this flag.
workInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateMemoComponent(current,workInProgress,Component,nextProps,renderLanes){if(current===null){var type=Component.type;if(isSimpleFunctionComponent(type)&&Component.compare===null&&// SimpleMemoComponent codepath doesn't resolve outer props either.
Component.defaultProps===undefined){var resolvedType=type;{resolvedType=resolveFunctionForHotReloading(type);}// If this is a plain function component without default props,
// and with only the default shallow comparison, we upgrade it
// to a SimpleMemoComponent to allow fast path updates.
workInProgress.tag=SimpleMemoComponent;workInProgress.type=resolvedType;{validateFunctionComponentInDev(workInProgress,type);}return updateSimpleMemoComponent(current,workInProgress,resolvedType,nextProps,renderLanes);}{var innerPropTypes=type.propTypes;if(innerPropTypes){// Inner memo component props aren't currently validated in createElement.
// We could move it there, but we'd still need this for lazy code path.
checkPropTypes(innerPropTypes,nextProps,// Resolved props
'prop',getComponentNameFromType(type));}}var child=createFiberFromTypeAndProps(Component.type,null,nextProps,workInProgress,workInProgress.mode,renderLanes);child.ref=workInProgress.ref;child.return=workInProgress;workInProgress.child=child;return child;}{var _type=Component.type;var _innerPropTypes=_type.propTypes;if(_innerPropTypes){// Inner memo component props aren't currently validated in createElement.
// We could move it there, but we'd still need this for lazy code path.
checkPropTypes(_innerPropTypes,nextProps,// Resolved props
'prop',getComponentNameFromType(_type));}}var currentChild=current.child;// This is always exactly one child
var hasScheduledUpdateOrContext=checkScheduledUpdateOrContext(current,renderLanes);if(!hasScheduledUpdateOrContext){// This will be the props with resolved defaultProps,
// unlike current.memoizedProps which will be the unresolved ones.
var prevProps=currentChild.memoizedProps;// Default to shallow comparison
var compare=Component.compare;compare=compare!==null?compare:shallowEqual;if(compare(prevProps,nextProps)&&current.ref===workInProgress.ref){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}}// React DevTools reads this flag.
workInProgress.flags|=PerformedWork;var newChild=createWorkInProgress(currentChild,nextProps);newChild.ref=workInProgress.ref;newChild.return=workInProgress;workInProgress.child=newChild;return newChild;}function updateSimpleMemoComponent(current,workInProgress,Component,nextProps,renderLanes){// TODO: current can be non-null here even if the component
// hasn't yet mounted. This happens when the inner render suspends.
// We'll need to figure out if this is fine or can cause issues.
{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement
// because they're only guaranteed to be resolved here.
var outerMemoType=workInProgress.elementType;if(outerMemoType.$$typeof===REACT_LAZY_TYPE){// We warn when you define propTypes on lazy()
// so let's just skip over it to find memo() outer wrapper.
// Inner props for memo are validated later.
var lazyComponent=outerMemoType;var payload=lazyComponent._payload;var init=lazyComponent._init;try{outerMemoType=init(payload);}catch(x){outerMemoType=null;}// Inner propTypes will be validated in the function component path.
var outerPropTypes=outerMemoType&&outerMemoType.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,nextProps,// Resolved (SimpleMemoComponent has no defaultProps)
'prop',getComponentNameFromType(outerMemoType));}}}}if(current!==null){var prevProps=current.memoizedProps;if(shallowEqual(prevProps,nextProps)&&current.ref===workInProgress.ref&&// Prevent bailout if the implementation changed due to hot reload.
workInProgress.type===current.type){didReceiveUpdate=false;// The props are shallowly equal. Reuse the previous props object, like we
// would during a normal fiber bailout.
//
// We don't have strong guarantees that the props object is referentially
// equal during updates where we can't bail out anyway — like if the props
// are shallowly equal, but there's a local state or context update in the
// same batch.
//
// However, as a principle, we should aim to make the behavior consistent
// across different ways of memoizing a component. For example, React.memo
// has a different internal Fiber layout if you pass a normal function
// component (SimpleMemoComponent) versus if you pass a different type
// like forwardRef (MemoComponent). But this is an implementation detail.
// Wrapping a component in forwardRef (or React.lazy, etc) shouldn't
// affect whether the props object is reused during a bailout.
workInProgress.pendingProps=nextProps=prevProps;if(!checkScheduledUpdateOrContext(current,renderLanes)){// The pending lanes were cleared at the beginning of beginWork. We're
// about to bail out, but there might be other lanes that weren't
// included in the current render. Usually, the priority level of the
// remaining updates is accumulated during the evaluation of the
// component (i.e. when processing the update queue). But since since
// we're bailing out early *without* evaluating the component, we need
// to account for it here, too. Reset to the value of the current fiber.
// NOTE: This only applies to SimpleMemoComponent, not MemoComponent,
// because a MemoComponent fiber does not have hooks or an update queue;
// rather, it wraps around an inner component, which may or may not
// contains hooks.
// TODO: Move the reset at in beginWork out of the common path so that
// this is no longer necessary.
workInProgress.lanes=current.lanes;return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}else if((current.flags&ForceUpdateForLegacySuspense)!==NoFlags){// This is a special case that only exists for legacy mode.
// See https://github.com/facebook/react/pull/19216.
didReceiveUpdate=true;}}}return updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes);}function updateOffscreenComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;var nextChildren=nextProps.children;var prevState=current!==null?current.memoizedState:null;if(nextProps.mode==='hidden'||enableLegacyHidden){// Rendering a hidden tree.
if((workInProgress.mode&ConcurrentMode)===NoMode){// In legacy sync mode, don't defer the subtree. Render it now.
// TODO: Consider how Offscreen should work with transitions in the future
var nextState={baseLanes:NoLanes,cachePool:null,transitions:null};workInProgress.memoizedState=nextState;pushRenderLanes(workInProgress,renderLanes);}else if(!includesSomeLane(renderLanes,OffscreenLane)){var spawnedCachePool=null;// We're hidden, and we're not rendering at Offscreen. We will bail out
// and resume this tree later.
var nextBaseLanes;if(prevState!==null){var prevBaseLanes=prevState.baseLanes;nextBaseLanes=mergeLanes(prevBaseLanes,renderLanes);}else {nextBaseLanes=renderLanes;}// Schedule this fiber to re-render at offscreen priority. Then bailout.
workInProgress.lanes=workInProgress.childLanes=laneToLanes(OffscreenLane);var _nextState={baseLanes:nextBaseLanes,cachePool:spawnedCachePool,transitions:null};workInProgress.memoizedState=_nextState;workInProgress.updateQueue=null;// to avoid a push/pop misalignment.
pushRenderLanes(workInProgress,nextBaseLanes);return null;}else {// This is the second render. The surrounding visible content has already
// committed. Now we resume rendering the hidden tree.
// Rendering at offscreen, so we can clear the base lanes.
var _nextState2={baseLanes:NoLanes,cachePool:null,transitions:null};workInProgress.memoizedState=_nextState2;// Push the lanes that were skipped when we bailed out.
var subtreeRenderLanes=prevState!==null?prevState.baseLanes:renderLanes;pushRenderLanes(workInProgress,subtreeRenderLanes);}}else {// Rendering a visible tree.
var _subtreeRenderLanes;if(prevState!==null){// We're going from hidden -> visible.
_subtreeRenderLanes=mergeLanes(prevState.baseLanes,renderLanes);workInProgress.memoizedState=null;}else {// We weren't previously hidden, and we still aren't, so there's nothing
// special to do. Need to push to the stack regardless, though, to avoid
// a push/pop misalignment.
_subtreeRenderLanes=renderLanes;}pushRenderLanes(workInProgress,_subtreeRenderLanes);}reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}// Note: These happen to have identical begin phases, for now. We shouldn't hold
function updateFragment(current,workInProgress,renderLanes){var nextChildren=workInProgress.pendingProps;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateMode(current,workInProgress,renderLanes){var nextChildren=workInProgress.pendingProps.children;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateProfiler(current,workInProgress,renderLanes){{workInProgress.flags|=Update;{// Reset effect durations for the next eventual effect phase.
// These are reset during render to allow the DevTools commit hook a chance to read them,
var stateNode=workInProgress.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}}var nextProps=workInProgress.pendingProps;var nextChildren=nextProps.children;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function markRef(current,workInProgress){var ref=workInProgress.ref;if(current===null&&ref!==null||current!==null&&current.ref!==ref){// Schedule a Ref effect
workInProgress.flags|=Ref;{workInProgress.flags|=RefStatic;}}}function updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes){{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement
// because they're only guaranteed to be resolved here.
var innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props
'prop',getComponentNameFromType(Component));}}}var context;{var unmaskedContext=getUnmaskedContext(workInProgress,Component,true);context=getMaskedContext(workInProgress,unmaskedContext);}var nextChildren;var hasId;prepareToReadContext(workInProgress,renderLanes);{markComponentRenderStarted(workInProgress);}{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,context,renderLanes);hasId=checkDidRenderIdHook();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,context,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}if(current!==null&&!didReceiveUpdate){bailoutHooks(current,workInProgress,renderLanes);return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}// React DevTools reads this flag.
workInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateClassComponent(current,workInProgress,Component,nextProps,renderLanes){{// This is used by DevTools to force a boundary to error.
switch(shouldError(workInProgress)){case false:{var _instance=workInProgress.stateNode;var ctor=workInProgress.type;// TODO This way of resetting the error boundary state is a hack.
// Is there a better way to do this?
var tempInstance=new ctor(workInProgress.memoizedProps,_instance.context);var state=tempInstance.state;_instance.updater.enqueueSetState(_instance,state,null);break;}case true:{workInProgress.flags|=DidCapture;workInProgress.flags|=ShouldCapture;// eslint-disable-next-line react-internal/prod-error-codes
var error$1=new Error('Simulated error coming from DevTools');var lane=pickArbitraryLane(renderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,lane);// Schedule the error boundary to re-render using updated state
var update=createClassErrorUpdate(workInProgress,createCapturedValueAtFiber(error$1,workInProgress),lane);enqueueCapturedUpdate(workInProgress,update);break;}}if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement
// because they're only guaranteed to be resolved here.
var innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props
'prop',getComponentNameFromType(Component));}}}// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else {hasContext=false;}prepareToReadContext(workInProgress,renderLanes);var instance=workInProgress.stateNode;var shouldUpdate;if(instance===null){resetSuspendedCurrentOnMountInLegacyMode(current,workInProgress);// In the initial pass we might need to construct the instance.
constructClassInstance(workInProgress,Component,nextProps);mountClassInstance(workInProgress,Component,nextProps,renderLanes);shouldUpdate=true;}else if(current===null){// In a resume, we'll already have an instance we can reuse.
shouldUpdate=resumeMountClassInstance(workInProgress,Component,nextProps,renderLanes);}else {shouldUpdate=updateClassInstance(current,workInProgress,Component,nextProps,renderLanes);}var nextUnitOfWork=finishClassComponent(current,workInProgress,Component,shouldUpdate,hasContext,renderLanes);{var inst=workInProgress.stateNode;if(shouldUpdate&&inst.props!==nextProps){if(!didWarnAboutReassigningProps){error('It looks like %s is reassigning its own `this.props` while rendering. '+'This is not supported and can lead to confusing bugs.',getComponentNameFromFiber(workInProgress)||'a component');}didWarnAboutReassigningProps=true;}}return nextUnitOfWork;}function finishClassComponent(current,workInProgress,Component,shouldUpdate,hasContext,renderLanes){// Refs should update even if shouldComponentUpdate returns false
markRef(current,workInProgress);var didCaptureError=(workInProgress.flags&DidCapture)!==NoFlags;if(!shouldUpdate&&!didCaptureError){// Context providers should defer to sCU for rendering
if(hasContext){invalidateContextProvider(workInProgress,Component,false);}return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}var instance=workInProgress.stateNode;// Rerender
ReactCurrentOwner$1.current=workInProgress;var nextChildren;if(didCaptureError&&typeof Component.getDerivedStateFromError!=='function'){// If we captured an error, but getDerivedStateFromError is not defined,
// unmount all the children. componentDidCatch will schedule an update to
// re-render a fallback. This is temporary until we migrate everyone to
// the new API.
// TODO: Warn in a future release.
nextChildren=null;{stopProfilerTimerIfRunning();}}else {{markComponentRenderStarted(workInProgress);}{setIsRendering(true);nextChildren=instance.render();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{instance.render();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}}// React DevTools reads this flag.
workInProgress.flags|=PerformedWork;if(current!==null&&didCaptureError){// If we're recovering from an error, reconcile without reusing any of
// the existing children. Conceptually, the normal children and the children
// that are shown on error are two different sets, so we shouldn't reuse
// normal children even if their identities match.
forceUnmountCurrentAndReconcile(current,workInProgress,nextChildren,renderLanes);}else {reconcileChildren(current,workInProgress,nextChildren,renderLanes);}// Memoize state using the values we just used to render.
// TODO: Restructure so we never read values from the instance.
workInProgress.memoizedState=instance.state;// The context might have changed so we need to recalculate it.
if(hasContext){invalidateContextProvider(workInProgress,Component,true);}return workInProgress.child;}function pushHostRootContext(workInProgress){var root=workInProgress.stateNode;if(root.pendingContext){pushTopLevelContextObject(workInProgress,root.pendingContext,root.pendingContext!==root.context);}else if(root.context){// Should always be set
pushTopLevelContextObject(workInProgress,root.context,false);}pushHostContainer(workInProgress,root.containerInfo);}function updateHostRoot(current,workInProgress,renderLanes){pushHostRootContext(workInProgress);if(current===null){throw new Error('Should have a current fiber. This is a bug in React.');}var nextProps=workInProgress.pendingProps;var prevState=workInProgress.memoizedState;var prevChildren=prevState.element;cloneUpdateQueue(current,workInProgress);processUpdateQueue(workInProgress,nextProps,null,renderLanes);var nextState=workInProgress.memoizedState;workInProgress.stateNode;// being called "element".
var nextChildren=nextState.element;if(prevState.isDehydrated){// This is a hydration root whose shell has not yet hydrated. We should
// attempt to hydrate.
// Flip isDehydrated to false to indicate that when this render
// finishes, the root will no longer be dehydrated.
var overrideState={element:nextChildren,isDehydrated:false,cache:nextState.cache,pendingSuspenseBoundaries:nextState.pendingSuspenseBoundaries,transitions:nextState.transitions};var updateQueue=workInProgress.updateQueue;// `baseState` can always be the last state because the root doesn't
// have reducer functions so it doesn't need rebasing.
updateQueue.baseState=overrideState;workInProgress.memoizedState=overrideState;if(workInProgress.flags&ForceClientRender){// Something errored during a previous attempt to hydrate the shell, so we
// forced a client render.
var recoverableError=createCapturedValueAtFiber(new Error('There was an error while hydrating. Because the error happened outside '+'of a Suspense boundary, the entire root will switch to '+'client rendering.'),workInProgress);return mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,recoverableError);}else if(nextChildren!==prevChildren){var _recoverableError=createCapturedValueAtFiber(new Error('This root received an early update, before anything was able '+'hydrate. Switched the entire root to client rendering.'),workInProgress);return mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,_recoverableError);}else {// The outermost shell has not hydrated yet. Start hydrating.
enterHydrationState(workInProgress);var child=mountChildFibers(workInProgress,null,nextChildren,renderLanes);workInProgress.child=child;var node=child;while(node){// Mark each child as hydrating. This is a fast path to know whether this
// tree is part of a hydrating tree. This is used to determine if a child
// node has fully mounted yet, and for scheduling event replaying.
// Conceptually this is similar to Placement in that a new subtree is
// inserted into the React tree here. It just happens to not need DOM
// mutations because it already exists.
node.flags=node.flags&~Placement|Hydrating;node=node.sibling;}}}else {// Root is not dehydrated. Either this is a client-only root, or it
// already hydrated.
resetHydrationState();if(nextChildren===prevChildren){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}reconcileChildren(current,workInProgress,nextChildren,renderLanes);}return workInProgress.child;}function mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,recoverableError){// Revert to client rendering.
resetHydrationState();queueHydrationError(recoverableError);workInProgress.flags|=ForceClientRender;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateHostComponent(current,workInProgress,renderLanes){pushHostContext(workInProgress);if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var type=workInProgress.type;var nextProps=workInProgress.pendingProps;var prevProps=current!==null?current.memoizedProps:null;var nextChildren=nextProps.children;var isDirectTextChild=shouldSetTextContent(type,nextProps);if(isDirectTextChild){// We special case a direct text child of a host node. This is a common
// case. We won't handle it as a reified child. We will instead handle
// this in the host environment that also has access to this prop. That
// avoids allocating another HostText fiber and traversing it.
nextChildren=null;}else if(prevProps!==null&&shouldSetTextContent(type,prevProps)){// If we're switching from a direct text child to a normal child, or to
// empty, we need to schedule the text content to be reset.
workInProgress.flags|=ContentReset;}markRef(current,workInProgress);reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateHostText(current,workInProgress){if(current===null){tryToClaimNextHydratableInstance(workInProgress);}// Nothing to do here. This is terminal. We'll do the completion step
// immediately after.
return null;}function mountLazyComponent(_current,workInProgress,elementType,renderLanes){resetSuspendedCurrentOnMountInLegacyMode(_current,workInProgress);var props=workInProgress.pendingProps;var lazyComponent=elementType;var payload=lazyComponent._payload;var init=lazyComponent._init;var Component=init(payload);// Store the unwrapped component in the type.
workInProgress.type=Component;var resolvedTag=workInProgress.tag=resolveLazyComponentTag(Component);var resolvedProps=resolveDefaultProps(Component,props);var child;switch(resolvedTag){case FunctionComponent:{{validateFunctionComponentInDev(workInProgress,Component);workInProgress.type=Component=resolveFunctionForHotReloading(Component);}child=updateFunctionComponent(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case ClassComponent:{{workInProgress.type=Component=resolveClassForHotReloading(Component);}child=updateClassComponent(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case ForwardRef:{{workInProgress.type=Component=resolveForwardRefForHotReloading(Component);}child=updateForwardRef(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case MemoComponent:{{if(workInProgress.type!==workInProgress.elementType){var outerPropTypes=Component.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,resolvedProps,// Resolved for outer only
'prop',getComponentNameFromType(Component));}}}child=updateMemoComponent(null,workInProgress,Component,resolveDefaultProps(Component.type,resolvedProps),// The inner type can have defaults too
renderLanes);return child;}}var hint='';{if(Component!==null&&typeof Component==='object'&&Component.$$typeof===REACT_LAZY_TYPE){hint=' Did you wrap a component in React.lazy() more than once?';}}// This message intentionally doesn't mention ForwardRef or MemoComponent
// because the fact that it's a separate type of work is an
// implementation detail.
throw new Error("Element type is invalid. Received a promise that resolves to: "+Component+". "+("Lazy element type must resolve to a class or function."+hint));}function mountIncompleteClassComponent(_current,workInProgress,Component,nextProps,renderLanes){resetSuspendedCurrentOnMountInLegacyMode(_current,workInProgress);// Promote the fiber to a class and try rendering again.
workInProgress.tag=ClassComponent;// The rest of this function is a fork of `updateClassComponent`
// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else {hasContext=false;}prepareToReadContext(workInProgress,renderLanes);constructClassInstance(workInProgress,Component,nextProps);mountClassInstance(workInProgress,Component,nextProps,renderLanes);return finishClassComponent(null,workInProgress,Component,true,hasContext,renderLanes);}function mountIndeterminateComponent(_current,workInProgress,Component,renderLanes){resetSuspendedCurrentOnMountInLegacyMode(_current,workInProgress);var props=workInProgress.pendingProps;var context;{var unmaskedContext=getUnmaskedContext(workInProgress,Component,false);context=getMaskedContext(workInProgress,unmaskedContext);}prepareToReadContext(workInProgress,renderLanes);var value;var hasId;{markComponentRenderStarted(workInProgress);}{if(Component.prototype&&typeof Component.prototype.render==='function'){var componentName=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutBadClass[componentName]){error("The <%s /> component appears to have a render method, but doesn't extend React.Component. "+'This is likely to cause errors. Change %s to extend React.Component instead.',componentName,componentName);didWarnAboutBadClass[componentName]=true;}}if(workInProgress.mode&StrictLegacyMode){ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,null);}setIsRendering(true);ReactCurrentOwner$1.current=workInProgress;value=renderWithHooks(null,workInProgress,Component,props,context,renderLanes);hasId=checkDidRenderIdHook();setIsRendering(false);}{markComponentRenderStopped();}// React DevTools reads this flag.
workInProgress.flags|=PerformedWork;{// Support for module components is deprecated and is removed behind a flag.
// Whether or not it would crash later, we want to show a good message in DEV first.
if(typeof value==='object'&&value!==null&&typeof value.render==='function'&&value.$$typeof===undefined){var _componentName=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutModulePatternComponent[_componentName]){error('The <%s /> component appears to be a function component that returns a class instance. '+'Change %s to a class that extends React.Component instead. '+"If you can't use a class try assigning the prototype on the function as a workaround. "+"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it "+'cannot be called with `new` by React.',_componentName,_componentName,_componentName);didWarnAboutModulePatternComponent[_componentName]=true;}}}if(// Run these checks in production only if the flag is off.
// Eventually we'll delete this branch altogether.
typeof value==='object'&&value!==null&&typeof value.render==='function'&&value.$$typeof===undefined){{var _componentName2=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutModulePatternComponent[_componentName2]){error('The <%s /> component appears to be a function component that returns a class instance. '+'Change %s to a class that extends React.Component instead. '+"If you can't use a class try assigning the prototype on the function as a workaround. "+"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it "+'cannot be called with `new` by React.',_componentName2,_componentName2,_componentName2);didWarnAboutModulePatternComponent[_componentName2]=true;}}// Proceed under the assumption that this is a class instance
workInProgress.tag=ClassComponent;// Throw out any hooks that were used.
workInProgress.memoizedState=null;workInProgress.updateQueue=null;// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext=false;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else {hasContext=false;}workInProgress.memoizedState=value.state!==null&&value.state!==undefined?value.state:null;initializeUpdateQueue(workInProgress);adoptClassInstance(workInProgress,value);mountClassInstance(workInProgress,Component,props,renderLanes);return finishClassComponent(null,workInProgress,Component,true,hasContext,renderLanes);}else {// Proceed under the assumption that this is a function component
workInProgress.tag=FunctionComponent;{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{value=renderWithHooks(null,workInProgress,Component,props,context,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}reconcileChildren(null,workInProgress,value,renderLanes);{validateFunctionComponentInDev(workInProgress,Component);}return workInProgress.child;}}function validateFunctionComponentInDev(workInProgress,Component){{if(Component){if(Component.childContextTypes){error('%s(...): childContextTypes cannot be defined on a function component.',Component.displayName||Component.name||'Component');}}if(workInProgress.ref!==null){var info='';var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){info+='\n\nCheck the render method of `'+ownerName+'`.';}var warningKey=ownerName||'';var debugSource=workInProgress._debugSource;if(debugSource){warningKey=debugSource.fileName+':'+debugSource.lineNumber;}if(!didWarnAboutFunctionRefs[warningKey]){didWarnAboutFunctionRefs[warningKey]=true;error('Function components cannot be given refs. '+'Attempts to access this ref will fail. '+'Did you mean to use React.forwardRef()?%s',info);}}if(typeof Component.getDerivedStateFromProps==='function'){var _componentName3=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]){error('%s: Function components do not support getDerivedStateFromProps.',_componentName3);didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]=true;}}if(typeof Component.contextType==='object'&&Component.contextType!==null){var _componentName4=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutContextTypeOnFunctionComponent[_componentName4]){error('%s: Function components do not support contextType.',_componentName4);didWarnAboutContextTypeOnFunctionComponent[_componentName4]=true;}}}}var SUSPENDED_MARKER={dehydrated:null,treeContext:null,retryLane:NoLane};function mountSuspenseOffscreenState(renderLanes){return {baseLanes:renderLanes,cachePool:getSuspendedCache(),transitions:null};}function updateSuspenseOffscreenState(prevOffscreenState,renderLanes){var cachePool=null;return {baseLanes:mergeLanes(prevOffscreenState.baseLanes,renderLanes),cachePool:cachePool,transitions:prevOffscreenState.transitions};}// TODO: Probably should inline this back
function shouldRemainOnFallback(suspenseContext,current,workInProgress,renderLanes){// If we're already showing a fallback, there are cases where we need to
// remain on that fallback regardless of whether the content has resolved.
// For example, SuspenseList coordinates when nested content appears.
if(current!==null){var suspenseState=current.memoizedState;if(suspenseState===null){// Currently showing content. Don't hide it, even if ForceSuspenseFallback
// is true. More precise name might be "ForceRemainSuspenseFallback".
// Note: This is a factoring smell. Can't remain on a fallback if there's
// no fallback to remain on.
return false;}}// Not currently showing content. Consult the Suspense context.
return hasSuspenseContext(suspenseContext,ForceSuspenseFallback);}function getRemainingWorkInPrimaryTree(current,renderLanes){// TODO: Should not remove render lanes that were pinged during this render
return removeLanes(current.childLanes,renderLanes);}function updateSuspenseComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;// This is used by DevTools to force a boundary to suspend.
{if(shouldSuspend(workInProgress)){workInProgress.flags|=DidCapture;}}var suspenseContext=suspenseStackCursor.current;var showFallback=false;var didSuspend=(workInProgress.flags&DidCapture)!==NoFlags;if(didSuspend||shouldRemainOnFallback(suspenseContext,current)){// Something in this boundary's subtree already suspended. Switch to
// rendering the fallback children.
showFallback=true;workInProgress.flags&=~DidCapture;}else {// Attempting the main content
if(current===null||current.memoizedState!==null){// This is a new mount or this boundary is already showing a fallback state.
// Mark this subtree context as having at least one invisible parent that could
// handle the fallback state.
// Avoided boundaries are not considered since they cannot handle preferred fallback states.
{suspenseContext=addSubtreeSuspenseContext(suspenseContext,InvisibleParentSuspenseContext);}}}suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);pushSuspenseContext(workInProgress,suspenseContext);// OK, the next part is confusing. We're about to reconcile the Suspense
// boundary's children. This involves some custom reconciliation logic. Two
// main reasons this is so complicated.
//
// First, Legacy Mode has different semantics for backwards compatibility. The
// primary tree will commit in an inconsistent state, so when we do the
// second pass to render the fallback, we do some exceedingly, uh, clever
// hacks to make that not totally break. Like transferring effects and
// deletions from hidden tree. In Concurrent Mode, it's much simpler,
// because we bailout on the primary tree completely and leave it in its old
// state, no effects. Same as what we do for Offscreen (except that
// Offscreen doesn't have the first render pass).
//
// Second is hydration. During hydration, the Suspense fiber has a slightly
// different layout, where the child points to a dehydrated fragment, which
// contains the DOM rendered by the server.
//
// Third, even if you set all that aside, Suspense is like error boundaries in
// that we first we try to render one tree, and if that fails, we render again
// and switch to a different tree. Like a try/catch block. So we have to track
// which branch we're currently rendering. Ideally we would model this using
// a stack.
if(current===null){// Initial mount
// Special path for hydration
// If we're currently hydrating, try to hydrate this boundary.
tryToClaimNextHydratableInstance(workInProgress);// This could've been a dehydrated suspense component.
var suspenseState=workInProgress.memoizedState;if(suspenseState!==null){var dehydrated=suspenseState.dehydrated;if(dehydrated!==null){return mountDehydratedSuspenseComponent(workInProgress,dehydrated);}}var nextPrimaryChildren=nextProps.children;var nextFallbackChildren=nextProps.fallback;if(showFallback){var fallbackFragment=mountSuspenseFallbackChildren(workInProgress,nextPrimaryChildren,nextFallbackChildren,renderLanes);var primaryChildFragment=workInProgress.child;primaryChildFragment.memoizedState=mountSuspenseOffscreenState(renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackFragment;}else {return mountSuspensePrimaryChildren(workInProgress,nextPrimaryChildren);}}else {// This is an update.
// Special path for hydration
var prevState=current.memoizedState;if(prevState!==null){var _dehydrated=prevState.dehydrated;if(_dehydrated!==null){return updateDehydratedSuspenseComponent(current,workInProgress,didSuspend,nextProps,_dehydrated,prevState,renderLanes);}}if(showFallback){var _nextFallbackChildren=nextProps.fallback;var _nextPrimaryChildren=nextProps.children;var fallbackChildFragment=updateSuspenseFallbackChildren(current,workInProgress,_nextPrimaryChildren,_nextFallbackChildren,renderLanes);var _primaryChildFragment2=workInProgress.child;var prevOffscreenState=current.child.memoizedState;_primaryChildFragment2.memoizedState=prevOffscreenState===null?mountSuspenseOffscreenState(renderLanes):updateSuspenseOffscreenState(prevOffscreenState,renderLanes);_primaryChildFragment2.childLanes=getRemainingWorkInPrimaryTree(current,renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackChildFragment;}else {var _nextPrimaryChildren2=nextProps.children;var _primaryChildFragment3=updateSuspensePrimaryChildren(current,workInProgress,_nextPrimaryChildren2,renderLanes);workInProgress.memoizedState=null;return _primaryChildFragment3;}}}function mountSuspensePrimaryChildren(workInProgress,primaryChildren,renderLanes){var mode=workInProgress.mode;var primaryChildProps={mode:'visible',children:primaryChildren};var primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,mode);primaryChildFragment.return=workInProgress;workInProgress.child=primaryChildFragment;return primaryChildFragment;}function mountSuspenseFallbackChildren(workInProgress,primaryChildren,fallbackChildren,renderLanes){var mode=workInProgress.mode;var progressedPrimaryFragment=workInProgress.child;var primaryChildProps={mode:'hidden',children:primaryChildren};var primaryChildFragment;var fallbackChildFragment;if((mode&ConcurrentMode)===NoMode&&progressedPrimaryFragment!==null){// In legacy mode, we commit the primary tree as if it successfully
// completed, even though it's in an inconsistent state.
primaryChildFragment=progressedPrimaryFragment;primaryChildFragment.childLanes=NoLanes;primaryChildFragment.pendingProps=primaryChildProps;if(workInProgress.mode&ProfileMode){// Reset the durations from the first pass so they aren't included in the
// final amounts. This seems counterintuitive, since we're intentionally
// not measuring part of the render phase, but this makes it match what we
// do in Concurrent Mode.
primaryChildFragment.actualDuration=0;primaryChildFragment.actualStartTime=-1;primaryChildFragment.selfBaseDuration=0;primaryChildFragment.treeBaseDuration=0;}fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);}else {primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,mode);fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);}primaryChildFragment.return=workInProgress;fallbackChildFragment.return=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;return fallbackChildFragment;}function mountWorkInProgressOffscreenFiber(offscreenProps,mode,renderLanes){// The props argument to `createFiberFromOffscreen` is `any` typed, so we use
// this wrapper function to constrain it.
return createFiberFromOffscreen(offscreenProps,mode,NoLanes,null);}function updateWorkInProgressOffscreenFiber(current,offscreenProps){// The props argument to `createWorkInProgress` is `any` typed, so we use this
// wrapper function to constrain it.
return createWorkInProgress(current,offscreenProps);}function updateSuspensePrimaryChildren(current,workInProgress,primaryChildren,renderLanes){var currentPrimaryChildFragment=current.child;var currentFallbackChildFragment=currentPrimaryChildFragment.sibling;var primaryChildFragment=updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment,{mode:'visible',children:primaryChildren});if((workInProgress.mode&ConcurrentMode)===NoMode){primaryChildFragment.lanes=renderLanes;}primaryChildFragment.return=workInProgress;primaryChildFragment.sibling=null;if(currentFallbackChildFragment!==null){// Delete the fallback child fragment
var deletions=workInProgress.deletions;if(deletions===null){workInProgress.deletions=[currentFallbackChildFragment];workInProgress.flags|=ChildDeletion;}else {deletions.push(currentFallbackChildFragment);}}workInProgress.child=primaryChildFragment;return primaryChildFragment;}function updateSuspenseFallbackChildren(current,workInProgress,primaryChildren,fallbackChildren,renderLanes){var mode=workInProgress.mode;var currentPrimaryChildFragment=current.child;var currentFallbackChildFragment=currentPrimaryChildFragment.sibling;var primaryChildProps={mode:'hidden',children:primaryChildren};var primaryChildFragment;if(// In legacy mode, we commit the primary tree as if it successfully
// completed, even though it's in an inconsistent state.
(mode&ConcurrentMode)===NoMode&&// Make sure we're on the second pass, i.e. the primary child fragment was
// already cloned. In legacy mode, the only case where this isn't true is
// when DevTools forces us to display a fallback; we skip the first render
// pass entirely and go straight to rendering the fallback. (In Concurrent
// Mode, SuspenseList can also trigger this scenario, but this is a legacy-
// only codepath.)
workInProgress.child!==currentPrimaryChildFragment){var progressedPrimaryFragment=workInProgress.child;primaryChildFragment=progressedPrimaryFragment;primaryChildFragment.childLanes=NoLanes;primaryChildFragment.pendingProps=primaryChildProps;if(workInProgress.mode&ProfileMode){// Reset the durations from the first pass so they aren't included in the
// final amounts. This seems counterintuitive, since we're intentionally
// not measuring part of the render phase, but this makes it match what we
// do in Concurrent Mode.
primaryChildFragment.actualDuration=0;primaryChildFragment.actualStartTime=-1;primaryChildFragment.selfBaseDuration=currentPrimaryChildFragment.selfBaseDuration;primaryChildFragment.treeBaseDuration=currentPrimaryChildFragment.treeBaseDuration;}// The fallback fiber was added as a deletion during the first pass.
// However, since we're going to remain on the fallback, we no longer want
// to delete it.
workInProgress.deletions=null;}else {primaryChildFragment=updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment,primaryChildProps);// Since we're reusing a current tree, we need to reuse the flags, too.
// (We don't do this in legacy mode, because in legacy mode we don't re-use
// the current tree; see previous branch.)
primaryChildFragment.subtreeFlags=currentPrimaryChildFragment.subtreeFlags&StaticMask;}var fallbackChildFragment;if(currentFallbackChildFragment!==null){fallbackChildFragment=createWorkInProgress(currentFallbackChildFragment,fallbackChildren);}else {fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);// Needs a placement effect because the parent (the Suspense boundary) already
// mounted but this is a new fiber.
fallbackChildFragment.flags|=Placement;}fallbackChildFragment.return=workInProgress;primaryChildFragment.return=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;return fallbackChildFragment;}function retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,recoverableError){// Falling back to client rendering. Because this has performance
// implications, it's considered a recoverable error, even though the user
// likely won't observe anything wrong with the UI.
//
// The error is passed in as an argument to enforce that every caller provide
// a custom message, or explicitly opt out (currently the only path that opts
// out is legacy mode; every concurrent path provides an error).
if(recoverableError!==null){queueHydrationError(recoverableError);}// This will add the old fiber to the deletion list
reconcileChildFibers(workInProgress,current.child,null,renderLanes);// We're now not suspended nor dehydrated.
var nextProps=workInProgress.pendingProps;var primaryChildren=nextProps.children;var primaryChildFragment=mountSuspensePrimaryChildren(workInProgress,primaryChildren);// Needs a placement effect because the parent (the Suspense boundary) already
// mounted but this is a new fiber.
primaryChildFragment.flags|=Placement;workInProgress.memoizedState=null;return primaryChildFragment;}function mountSuspenseFallbackAfterRetryWithoutHydrating(current,workInProgress,primaryChildren,fallbackChildren,renderLanes){var fiberMode=workInProgress.mode;var primaryChildProps={mode:'visible',children:primaryChildren};var primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,fiberMode);var fallbackChildFragment=createFiberFromFragment(fallbackChildren,fiberMode,renderLanes,null);// Needs a placement effect because the parent (the Suspense
// boundary) already mounted but this is a new fiber.
fallbackChildFragment.flags|=Placement;primaryChildFragment.return=workInProgress;fallbackChildFragment.return=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;if((workInProgress.mode&ConcurrentMode)!==NoMode){// We will have dropped the effect list which contains the
// deletion. We need to reconcile to delete the current child.
reconcileChildFibers(workInProgress,current.child,null,renderLanes);}return fallbackChildFragment;}function mountDehydratedSuspenseComponent(workInProgress,suspenseInstance,renderLanes){// During the first pass, we'll bail out and not drill into the children.
// Instead, we'll leave the content in place and try to hydrate it later.
if((workInProgress.mode&ConcurrentMode)===NoMode){{error('Cannot hydrate Suspense in legacy mode. Switch from '+'ReactDOM.hydrate(element, container) to '+'ReactDOMClient.hydrateRoot(container, <App />)'+'.render(element) or remove the Suspense components from '+'the server rendered components.');}workInProgress.lanes=laneToLanes(SyncLane);}else if(isSuspenseInstanceFallback(suspenseInstance)){// This is a client-only boundary. Since we won't get any content from the server
// for this, we need to schedule that at a higher priority based on when it would
// have timed out. In theory we could render it in this pass but it would have the
// wrong priority associated with it and will prevent hydration of parent path.
// Instead, we'll leave work left on it to render it in a separate commit.
// TODO This time should be the time at which the server rendered response that is
// a parent to this boundary was displayed. However, since we currently don't have
// a protocol to transfer that time, we'll just estimate it by using the current
// time. This will mean that Suspense timeouts are slightly shifted to later than
// they should be.
// Schedule a normal pri update to render this content.
workInProgress.lanes=laneToLanes(DefaultHydrationLane);}else {// We'll continue hydrating the rest at offscreen priority since we'll already
// be showing the right content coming from the server, it is no rush.
workInProgress.lanes=laneToLanes(OffscreenLane);}return null;}function updateDehydratedSuspenseComponent(current,workInProgress,didSuspend,nextProps,suspenseInstance,suspenseState,renderLanes){if(!didSuspend){// This is the first render pass. Attempt to hydrate.
// We should never be hydrating at this point because it is the first pass,
// but after we've already committed once.
warnIfHydrating();if((workInProgress.mode&ConcurrentMode)===NoMode){return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,// TODO: When we delete legacy mode, we should make this error argument
// required — every concurrent mode path that causes hydration to
// de-opt to client rendering should have an error message.
null);}if(isSuspenseInstanceFallback(suspenseInstance)){// This boundary is in a permanent fallback state. In this case, we'll never
// get an update and we'll never be able to hydrate the final content. Let's just try the
// client side render instead.
var digest,message,stack;{var _getSuspenseInstanceF=getSuspenseInstanceFallbackErrorDetails(suspenseInstance);digest=_getSuspenseInstanceF.digest;message=_getSuspenseInstanceF.message;stack=_getSuspenseInstanceF.stack;}var error;if(message){// eslint-disable-next-line react-internal/prod-error-codes
error=new Error(message);}else {error=new Error('The server could not finish this Suspense boundary, likely '+'due to an error during server rendering. Switched to '+'client rendering.');}var capturedValue=createCapturedValue(error,digest,stack);return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,capturedValue);}// any context has changed, we need to treat is as if the input might have changed.
var hasContextChanged=includesSomeLane(renderLanes,current.childLanes);if(didReceiveUpdate||hasContextChanged){// This boundary has changed since the first render. This means that we are now unable to
// hydrate it. We might still be able to hydrate it using a higher priority lane.
var root=getWorkInProgressRoot();if(root!==null){var attemptHydrationAtLane=getBumpedLaneForHydration(root,renderLanes);if(attemptHydrationAtLane!==NoLane&&attemptHydrationAtLane!==suspenseState.retryLane){// Intentionally mutating since this render will get interrupted. This
// is one of the very rare times where we mutate the current tree
// during the render phase.
suspenseState.retryLane=attemptHydrationAtLane;// TODO: Ideally this would inherit the event time of the current render
var eventTime=NoTimestamp;enqueueConcurrentRenderForLane(current,attemptHydrationAtLane);scheduleUpdateOnFiber(root,current,attemptHydrationAtLane,eventTime);}}// If we have scheduled higher pri work above, this will probably just abort the render
// since we now have higher priority work, but in case it doesn't, we need to prepare to
// render something, if we time out. Even if that requires us to delete everything and
// skip hydration.
// Delay having to do this as long as the suspense timeout allows us.
renderDidSuspendDelayIfPossible();var _capturedValue=createCapturedValue(new Error('This Suspense boundary received an update before it finished '+'hydrating. This caused the boundary to switch to client rendering. '+'The usual way to fix this is to wrap the original update '+'in startTransition.'));return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,_capturedValue);}else if(isSuspenseInstancePending(suspenseInstance)){// This component is still pending more data from the server, so we can't hydrate its
// content. We treat it as if this component suspended itself. It might seem as if
// we could just try to render it client-side instead. However, this will perform a
// lot of unnecessary work and is unlikely to complete since it often will suspend
// on missing data anyway. Additionally, the server might be able to render more
// than we can on the client yet. In that case we'd end up with more fallback states
// on the client than if we just leave it alone. If the server times out or errors
// these should update this boundary to the permanent Fallback state instead.
// Mark it as having captured (i.e. suspended).
workInProgress.flags|=DidCapture;// Leave the child in place. I.e. the dehydrated fragment.
workInProgress.child=current.child;// Register a callback to retry this boundary once the server has sent the result.
var retry=retryDehydratedSuspenseBoundary.bind(null,current);registerSuspenseInstanceRetry(suspenseInstance,retry);return null;}else {// This is the first attempt.
reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress,suspenseInstance,suspenseState.treeContext);var primaryChildren=nextProps.children;var primaryChildFragment=mountSuspensePrimaryChildren(workInProgress,primaryChildren);// Mark the children as hydrating. This is a fast path to know whether this
// tree is part of a hydrating tree. This is used to determine if a child
// node has fully mounted yet, and for scheduling event replaying.
// Conceptually this is similar to Placement in that a new subtree is
// inserted into the React tree here. It just happens to not need DOM
// mutations because it already exists.
primaryChildFragment.flags|=Hydrating;return primaryChildFragment;}}else {// This is the second render pass. We already attempted to hydrated, but
// something either suspended or errored.
if(workInProgress.flags&ForceClientRender){// Something errored during hydration. Try again without hydrating.
workInProgress.flags&=~ForceClientRender;var _capturedValue2=createCapturedValue(new Error('There was an error while hydrating this Suspense boundary. '+'Switched to client rendering.'));return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,_capturedValue2);}else if(workInProgress.memoizedState!==null){// Something suspended and we should still be in dehydrated mode.
// Leave the existing child in place.
workInProgress.child=current.child;// The dehydrated completion pass expects this flag to be there
// but the normal suspense pass doesn't.
workInProgress.flags|=DidCapture;return null;}else {// Suspended but we should no longer be in dehydrated mode.
// Therefore we now have to render the fallback.
var nextPrimaryChildren=nextProps.children;var nextFallbackChildren=nextProps.fallback;var fallbackChildFragment=mountSuspenseFallbackAfterRetryWithoutHydrating(current,workInProgress,nextPrimaryChildren,nextFallbackChildren,renderLanes);var _primaryChildFragment4=workInProgress.child;_primaryChildFragment4.memoizedState=mountSuspenseOffscreenState(renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackChildFragment;}}}function scheduleSuspenseWorkOnFiber(fiber,renderLanes,propagationRoot){fiber.lanes=mergeLanes(fiber.lanes,renderLanes);var alternate=fiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,renderLanes);}scheduleContextWorkOnParentPath(fiber.return,renderLanes,propagationRoot);}function propagateSuspenseContextChange(workInProgress,firstChild,renderLanes){// Mark any Suspense boundaries with fallbacks as having work to do.
// If they were previously forced into fallbacks, they may now be able
// to unblock.
var node=firstChild;while(node!==null){if(node.tag===SuspenseComponent){var state=node.memoizedState;if(state!==null){scheduleSuspenseWorkOnFiber(node,renderLanes,workInProgress);}}else if(node.tag===SuspenseListComponent){// If the tail is hidden there might not be an Suspense boundaries
// to schedule work on. In this case we have to schedule it on the
// list itself.
// We don't have to traverse to the children of the list since
// the list will propagate the change when it rerenders.
scheduleSuspenseWorkOnFiber(node,renderLanes,workInProgress);}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node.return===null||node.return===workInProgress){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}function findLastContentRow(firstChild){// This is going to find the last row among these children that is already
// showing content on the screen, as opposed to being in fallback state or
// new. If a row has multiple Suspense boundaries, any of them being in the
// fallback state, counts as the whole row being in a fallback state.
// Note that the "rows" will be workInProgress, but any nested children
// will still be current since we haven't rendered them yet. The mounted
// order may not be the same as the new order. We use the new order.
var row=firstChild;var lastContentRow=null;while(row!==null){var currentRow=row.alternate;// New rows can't be content rows.
if(currentRow!==null&&findFirstSuspended(currentRow)===null){lastContentRow=row;}row=row.sibling;}return lastContentRow;}function validateRevealOrder(revealOrder){{if(revealOrder!==undefined&&revealOrder!=='forwards'&&revealOrder!=='backwards'&&revealOrder!=='together'&&!didWarnAboutRevealOrder[revealOrder]){didWarnAboutRevealOrder[revealOrder]=true;if(typeof revealOrder==='string'){switch(revealOrder.toLowerCase()){case'together':case'forwards':case'backwards':{error('"%s" is not a valid value for revealOrder on <SuspenseList />. '+'Use lowercase "%s" instead.',revealOrder,revealOrder.toLowerCase());break;}case'forward':case'backward':{error('"%s" is not a valid value for revealOrder on <SuspenseList />. '+'React uses the -s suffix in the spelling. Use "%ss" instead.',revealOrder,revealOrder.toLowerCase());break;}default:error('"%s" is not a supported revealOrder on <SuspenseList />. '+'Did you mean "together", "forwards" or "backwards"?',revealOrder);break;}}else {error('%s is not a supported value for revealOrder on <SuspenseList />. '+'Did you mean "together", "forwards" or "backwards"?',revealOrder);}}}}function validateTailOptions(tailMode,revealOrder){{if(tailMode!==undefined&&!didWarnAboutTailOptions[tailMode]){if(tailMode!=='collapsed'&&tailMode!=='hidden'){didWarnAboutTailOptions[tailMode]=true;error('"%s" is not a supported value for tail on <SuspenseList />. '+'Did you mean "collapsed" or "hidden"?',tailMode);}else if(revealOrder!=='forwards'&&revealOrder!=='backwards'){didWarnAboutTailOptions[tailMode]=true;error('<SuspenseList tail="%s" /> is only valid if revealOrder is '+'"forwards" or "backwards". '+'Did you mean to specify revealOrder="forwards"?',tailMode);}}}}function validateSuspenseListNestedChild(childSlot,index){{var isAnArray=isArray(childSlot);var isIterable=!isAnArray&&typeof getIteratorFn(childSlot)==='function';if(isAnArray||isIterable){var type=isAnArray?'array':'iterable';error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in '+'an additional SuspenseList to configure its revealOrder: '+'<SuspenseList revealOrder=...> ... '+'<SuspenseList revealOrder=...>{%s}</SuspenseList> ... '+'</SuspenseList>',type,index,type);return false;}}return true;}function validateSuspenseListChildren(children,revealOrder){{if((revealOrder==='forwards'||revealOrder==='backwards')&&children!==undefined&&children!==null&&children!==false){if(isArray(children)){for(var i=0;i<children.length;i++){if(!validateSuspenseListNestedChild(children[i],i)){return;}}}else {var iteratorFn=getIteratorFn(children);if(typeof iteratorFn==='function'){var childrenIterator=iteratorFn.call(children);if(childrenIterator){var step=childrenIterator.next();var _i=0;for(;!step.done;step=childrenIterator.next()){if(!validateSuspenseListNestedChild(step.value,_i)){return;}_i++;}}}else {error('A single row was passed to a <SuspenseList revealOrder="%s" />. '+'This is not useful since it needs multiple rows. '+'Did you mean to pass multiple children or an array?',revealOrder);}}}}}function initSuspenseListRenderState(workInProgress,isBackwards,tail,lastContentRow,tailMode){var renderState=workInProgress.memoizedState;if(renderState===null){workInProgress.memoizedState={isBackwards:isBackwards,rendering:null,renderingStartTime:0,last:lastContentRow,tail:tail,tailMode:tailMode};}else {// We can reuse the existing object from previous renders.
renderState.isBackwards=isBackwards;renderState.rendering=null;renderState.renderingStartTime=0;renderState.last=lastContentRow;renderState.tail=tail;renderState.tailMode=tailMode;}}// This can end up rendering this component multiple passes.
// The first pass splits the children fibers into two sets. A head and tail.
// We first render the head. If anything is in fallback state, we do another
// pass through beginWork to rerender all children (including the tail) with
// the force suspend context. If the first render didn't have anything in
// in fallback state. Then we render each row in the tail one-by-one.
// That happens in the completeWork phase without going back to beginWork.
function updateSuspenseListComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;var revealOrder=nextProps.revealOrder;var tailMode=nextProps.tail;var newChildren=nextProps.children;validateRevealOrder(revealOrder);validateTailOptions(tailMode,revealOrder);validateSuspenseListChildren(newChildren,revealOrder);reconcileChildren(current,workInProgress,newChildren,renderLanes);var suspenseContext=suspenseStackCursor.current;var shouldForceFallback=hasSuspenseContext(suspenseContext,ForceSuspenseFallback);if(shouldForceFallback){suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback);workInProgress.flags|=DidCapture;}else {var didSuspendBefore=current!==null&&(current.flags&DidCapture)!==NoFlags;if(didSuspendBefore){// If we previously forced a fallback, we need to schedule work
// on any nested boundaries to let them know to try to render
// again. This is the same as context updating.
propagateSuspenseContextChange(workInProgress,workInProgress.child,renderLanes);}suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);}pushSuspenseContext(workInProgress,suspenseContext);if((workInProgress.mode&ConcurrentMode)===NoMode){// In legacy mode, SuspenseList doesn't work so we just
// use make it a noop by treating it as the default revealOrder.
workInProgress.memoizedState=null;}else {switch(revealOrder){case'forwards':{var lastContentRow=findLastContentRow(workInProgress.child);var tail;if(lastContentRow===null){// The whole list is part of the tail.
// TODO: We could fast path by just rendering the tail now.
tail=workInProgress.child;workInProgress.child=null;}else {// Disconnect the tail rows after the content row.
// We're going to render them separately later.
tail=lastContentRow.sibling;lastContentRow.sibling=null;}initSuspenseListRenderState(workInProgress,false,// isBackwards
tail,lastContentRow,tailMode);break;}case'backwards':{// We're going to find the first row that has existing content.
// At the same time we're going to reverse the list of everything
// we pass in the meantime. That's going to be our tail in reverse
// order.
var _tail=null;var row=workInProgress.child;workInProgress.child=null;while(row!==null){var currentRow=row.alternate;// New rows can't be content rows.
if(currentRow!==null&&findFirstSuspended(currentRow)===null){// This is the beginning of the main content.
workInProgress.child=row;break;}var nextRow=row.sibling;row.sibling=_tail;_tail=row;row=nextRow;}// TODO: If workInProgress.child is null, we can continue on the tail immediately.
initSuspenseListRenderState(workInProgress,true,// isBackwards
_tail,null,// last
tailMode);break;}case'together':{initSuspenseListRenderState(workInProgress,false,// isBackwards
null,// tail
null,// last
undefined);break;}default:{// The default reveal order is the same as not having
// a boundary.
workInProgress.memoizedState=null;}}}return workInProgress.child;}function updatePortalComponent(current,workInProgress,renderLanes){pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);var nextChildren=workInProgress.pendingProps;if(current===null){// Portals are special because we don't append the children during mount
// but at commit. Therefore we need to track insertions which the normal
// flow doesn't do during mount. This doesn't happen at the root because
// the root always starts with a "current" with a null child.
// TODO: Consider unifying this with how the root works.
workInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderLanes);}else {reconcileChildren(current,workInProgress,nextChildren,renderLanes);}return workInProgress.child;}var hasWarnedAboutUsingNoValuePropOnContextProvider=false;function updateContextProvider(current,workInProgress,renderLanes){var providerType=workInProgress.type;var context=providerType._context;var newProps=workInProgress.pendingProps;var oldProps=workInProgress.memoizedProps;var newValue=newProps.value;{if(!('value'in newProps)){if(!hasWarnedAboutUsingNoValuePropOnContextProvider){hasWarnedAboutUsingNoValuePropOnContextProvider=true;error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');}}var providerPropTypes=workInProgress.type.propTypes;if(providerPropTypes){checkPropTypes(providerPropTypes,newProps,'prop','Context.Provider');}}pushProvider(workInProgress,context,newValue);{if(oldProps!==null){var oldValue=oldProps.value;if(objectIs(oldValue,newValue)){// No change. Bailout early if children are the same.
if(oldProps.children===newProps.children&&!hasContextChanged()){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}}else {// The context value changed. Search for matching consumers and schedule
// them to update.
propagateContextChange(workInProgress,context,renderLanes);}}}var newChildren=newProps.children;reconcileChildren(current,workInProgress,newChildren,renderLanes);return workInProgress.child;}var hasWarnedAboutUsingContextAsConsumer=false;function updateContextConsumer(current,workInProgress,renderLanes){var context=workInProgress.type;// The logic below for Context differs depending on PROD or DEV mode. In
// DEV mode, we create a separate object for Context.Consumer that acts
// like a proxy to Context. This proxy object adds unnecessary code in PROD
// so we use the old behaviour (Context.Consumer references Context) to
// reduce size and overhead. The separate object references context via
// a property called "_context", which also gives us the ability to check
// in DEV mode if this property exists or not and warn if it does not.
{if(context._context===undefined){// This may be because it's a Context (rather than a Consumer).
// Or it may be because it's older React where they're the same thing.
// We only want to warn if we're sure it's a new React.
if(context!==context.Consumer){if(!hasWarnedAboutUsingContextAsConsumer){hasWarnedAboutUsingContextAsConsumer=true;error('Rendering <Context> directly is not supported and will be removed in '+'a future major release. Did you mean to render <Context.Consumer> instead?');}}}else {context=context._context;}}var newProps=workInProgress.pendingProps;var render=newProps.children;{if(typeof render!=='function'){error('A context consumer was rendered with multiple children, or a child '+"that isn't a function. A context consumer expects a single child "+'that is a function. If you did pass a function, make sure there '+'is no trailing or leading whitespace around it.');}}prepareToReadContext(workInProgress,renderLanes);var newValue=readContext(context);{markComponentRenderStarted(workInProgress);}var newChildren;{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);newChildren=render(newValue);setIsRendering(false);}{markComponentRenderStopped();}// React DevTools reads this flag.
workInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,newChildren,renderLanes);return workInProgress.child;}function markWorkInProgressReceivedUpdate(){didReceiveUpdate=true;}function resetSuspendedCurrentOnMountInLegacyMode(current,workInProgress){if((workInProgress.mode&ConcurrentMode)===NoMode){if(current!==null){// A lazy component only mounts if it suspended inside a non-
// concurrent tree, in an inconsistent state. We want to treat it like
// a new mount, even though an empty version of it already committed.
// Disconnect the alternate pointers.
current.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect
workInProgress.flags|=Placement;}}}function bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes){if(current!==null){// Reuse previous dependencies
workInProgress.dependencies=current.dependencies;}{// Don't update "base" render times for bailouts.
stopProfilerTimerIfRunning();}markSkippedUpdateLanes(workInProgress.lanes);// Check if the children have any pending work.
if(!includesSomeLane(renderLanes,workInProgress.childLanes)){// The children don't have any work either. We can skip them.
// TODO: Once we add back resuming, we should check if the children are
// a work-in-progress set. If so, we need to transfer their effects.
{return null;}}// This fiber doesn't have work, but its subtree does. Clone the child
// fibers and continue.
cloneChildFibers(current,workInProgress);return workInProgress.child;}function remountFiber(current,oldWorkInProgress,newWorkInProgress){{var returnFiber=oldWorkInProgress.return;if(returnFiber===null){// eslint-disable-next-line react-internal/prod-error-codes
throw new Error('Cannot swap the root fiber.');}// Disconnect from the old current.
// It will get deleted.
current.alternate=null;oldWorkInProgress.alternate=null;// Connect to the new tree.
newWorkInProgress.index=oldWorkInProgress.index;newWorkInProgress.sibling=oldWorkInProgress.sibling;newWorkInProgress.return=oldWorkInProgress.return;newWorkInProgress.ref=oldWorkInProgress.ref;// Replace the child/sibling pointers above it.
if(oldWorkInProgress===returnFiber.child){returnFiber.child=newWorkInProgress;}else {var prevSibling=returnFiber.child;if(prevSibling===null){// eslint-disable-next-line react-internal/prod-error-codes
throw new Error('Expected parent to have a child.');}while(prevSibling.sibling!==oldWorkInProgress){prevSibling=prevSibling.sibling;if(prevSibling===null){// eslint-disable-next-line react-internal/prod-error-codes
throw new Error('Expected to find the previous sibling.');}}prevSibling.sibling=newWorkInProgress;}// Delete the old fiber and place the new one.
// Since the old fiber is disconnected, we have to schedule it manually.
var deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[current];returnFiber.flags|=ChildDeletion;}else {deletions.push(current);}newWorkInProgress.flags|=Placement;// Restart work from the new fiber.
return newWorkInProgress;}}function checkScheduledUpdateOrContext(current,renderLanes){// Before performing an early bailout, we must check if there are pending
// updates or context.
var updateLanes=current.lanes;if(includesSomeLane(updateLanes,renderLanes)){return true;}// No pending update, but because context is propagated lazily, we need
return false;}function attemptEarlyBailoutIfNoScheduledUpdate(current,workInProgress,renderLanes){// This fiber does not have any pending work. Bailout without entering
// the begin phase. There's still some bookkeeping we that needs to be done
// in this optimized path, mostly pushing stuff onto the stack.
switch(workInProgress.tag){case HostRoot:pushHostRootContext(workInProgress);workInProgress.stateNode;resetHydrationState();break;case HostComponent:pushHostContext(workInProgress);break;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){pushContextProvider(workInProgress);}break;}case HostPortal:pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);break;case ContextProvider:{var newValue=workInProgress.memoizedProps.value;var context=workInProgress.type._context;pushProvider(workInProgress,context,newValue);break;}case Profiler:{// Profiler should only call onRender when one of its descendants actually rendered.
var hasChildWork=includesSomeLane(renderLanes,workInProgress.childLanes);if(hasChildWork){workInProgress.flags|=Update;}{// Reset effect durations for the next eventual effect phase.
// These are reset during render to allow the DevTools commit hook a chance to read them,
var stateNode=workInProgress.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}}break;case SuspenseComponent:{var state=workInProgress.memoizedState;if(state!==null){if(state.dehydrated!==null){pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));// We know that this component will suspend again because if it has
// been unsuspended it has committed as a resolved Suspense component.
// If it needs to be retried, it should have work scheduled on it.
workInProgress.flags|=DidCapture;// We should never render the children of a dehydrated boundary until we
// upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.
return null;}// If this boundary is currently timed out, we need to decide
// whether to retry the primary children, or to skip over it and
// go straight to the fallback. Check the priority of the primary
// child fragment.
var primaryChildFragment=workInProgress.child;var primaryChildLanes=primaryChildFragment.childLanes;if(includesSomeLane(renderLanes,primaryChildLanes)){// The primary children have pending work. Use the normal path
// to attempt to render the primary children again.
return updateSuspenseComponent(current,workInProgress,renderLanes);}else {// The primary child fragment does not have pending work marked
// on it
pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));// The primary children do not have pending work with sufficient
// priority. Bailout.
var child=bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);if(child!==null){// The fallback children have pending work. Skip over the
// primary children and work on the fallback.
return child.sibling;}else {// Note: We can return `null` here because we already checked
// whether there were nested context consumers, via the call to
// `bailoutOnAlreadyFinishedWork` above.
return null;}}}else {pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));}break;}case SuspenseListComponent:{var didSuspendBefore=(current.flags&DidCapture)!==NoFlags;var _hasChildWork=includesSomeLane(renderLanes,workInProgress.childLanes);if(didSuspendBefore){if(_hasChildWork){// If something was in fallback state last time, and we have all the
// same children then we're still in progressive loading state.
// Something might get unblocked by state updates or retries in the
// tree which will affect the tail. So we need to use the normal
// path to compute the correct tail.
return updateSuspenseListComponent(current,workInProgress,renderLanes);}// If none of the children had any work, that means that none of
// them got retried so they'll still be blocked in the same way
// as before. We can fast bail out.
workInProgress.flags|=DidCapture;}// If nothing suspended before and we're rendering the same children,
// then the tail doesn't matter. Anything new that suspends will work
// in the "together" mode, so we can continue from the state we had.
var renderState=workInProgress.memoizedState;if(renderState!==null){// Reset to the "together" mode in case we've started a different
// update in the past but didn't complete it.
renderState.rendering=null;renderState.tail=null;renderState.lastEffect=null;}pushSuspenseContext(workInProgress,suspenseStackCursor.current);if(_hasChildWork){break;}else {// If none of the children had any work, that means that none of
// them got retried so they'll still be blocked in the same way
// as before. We can fast bail out.
return null;}}case OffscreenComponent:case LegacyHiddenComponent:{// Need to check if the tree still needs to be deferred. This is
// almost identical to the logic used in the normal update path,
// so we'll just enter that. The only difference is we'll bail out
// at the next level instead of this one, because the child props
// have not changed. Which is fine.
// TODO: Probably should refactor `beginWork` to split the bailout
// path from the normal path. I'm tempted to do a labeled break here
// but I won't :)
workInProgress.lanes=NoLanes;return updateOffscreenComponent(current,workInProgress,renderLanes);}}return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}function beginWork(current,workInProgress,renderLanes){{if(workInProgress._debugNeedsRemount&&current!==null){// This will restart the begin phase with a new fiber.
return remountFiber(current,workInProgress,createFiberFromTypeAndProps(workInProgress.type,workInProgress.key,workInProgress.pendingProps,workInProgress._debugOwner||null,workInProgress.mode,workInProgress.lanes));}}if(current!==null){var oldProps=current.memoizedProps;var newProps=workInProgress.pendingProps;if(oldProps!==newProps||hasContextChanged()||// Force a re-render if the implementation changed due to hot reload:
workInProgress.type!==current.type){// If props or context changed, mark the fiber as having performed work.
// This may be unset if the props are determined to be equal later (memo).
didReceiveUpdate=true;}else {// Neither props nor legacy context changes. Check if there's a pending
// update or context change.
var hasScheduledUpdateOrContext=checkScheduledUpdateOrContext(current,renderLanes);if(!hasScheduledUpdateOrContext&&// If this is the second pass of an error or suspense boundary, there
// may not be work scheduled on `current`, so we check for this flag.
(workInProgress.flags&DidCapture)===NoFlags){// No pending updates or context. Bail out now.
didReceiveUpdate=false;return attemptEarlyBailoutIfNoScheduledUpdate(current,workInProgress,renderLanes);}if((current.flags&ForceUpdateForLegacySuspense)!==NoFlags){// This is a special case that only exists for legacy mode.
// See https://github.com/facebook/react/pull/19216.
didReceiveUpdate=true;}else {// An update was scheduled on this fiber, but there are no new props
// nor legacy context. Set this to false. If an update queue or context
// consumer produces a changed value, it will set this to true. Otherwise,
// the component will assume the children have not changed and bail out.
didReceiveUpdate=false;}}}else {didReceiveUpdate=false;if(getIsHydrating()&&isForkedChild(workInProgress)){// Check if this child belongs to a list of muliple children in
// its parent.
//
// In a true multi-threaded implementation, we would render children on
// parallel threads. This would represent the beginning of a new render
// thread for this subtree.
//
// We only use this for id generation during hydration, which is why the
// logic is located in this special branch.
var slotIndex=workInProgress.index;var numberOfForks=getForksAtLevel();pushTreeId(workInProgress,numberOfForks,slotIndex);}}// Before entering the begin phase, clear pending update priority.
// TODO: This assumes that we're about to evaluate the component and process
// the update queue. However, there's an exception: SimpleMemoComponent
// sometimes bails out later in the begin phase. This indicates that we should
// move this assignment out of the common path and into each branch.
workInProgress.lanes=NoLanes;switch(workInProgress.tag){case IndeterminateComponent:{return mountIndeterminateComponent(current,workInProgress,workInProgress.type,renderLanes);}case LazyComponent:{var elementType=workInProgress.elementType;return mountLazyComponent(current,workInProgress,elementType,renderLanes);}case FunctionComponent:{var Component=workInProgress.type;var unresolvedProps=workInProgress.pendingProps;var resolvedProps=workInProgress.elementType===Component?unresolvedProps:resolveDefaultProps(Component,unresolvedProps);return updateFunctionComponent(current,workInProgress,Component,resolvedProps,renderLanes);}case ClassComponent:{var _Component=workInProgress.type;var _unresolvedProps=workInProgress.pendingProps;var _resolvedProps=workInProgress.elementType===_Component?_unresolvedProps:resolveDefaultProps(_Component,_unresolvedProps);return updateClassComponent(current,workInProgress,_Component,_resolvedProps,renderLanes);}case HostRoot:return updateHostRoot(current,workInProgress,renderLanes);case HostComponent:return updateHostComponent(current,workInProgress,renderLanes);case HostText:return updateHostText(current,workInProgress);case SuspenseComponent:return updateSuspenseComponent(current,workInProgress,renderLanes);case HostPortal:return updatePortalComponent(current,workInProgress,renderLanes);case ForwardRef:{var type=workInProgress.type;var _unresolvedProps2=workInProgress.pendingProps;var _resolvedProps2=workInProgress.elementType===type?_unresolvedProps2:resolveDefaultProps(type,_unresolvedProps2);return updateForwardRef(current,workInProgress,type,_resolvedProps2,renderLanes);}case Fragment:return updateFragment(current,workInProgress,renderLanes);case Mode:return updateMode(current,workInProgress,renderLanes);case Profiler:return updateProfiler(current,workInProgress,renderLanes);case ContextProvider:return updateContextProvider(current,workInProgress,renderLanes);case ContextConsumer:return updateContextConsumer(current,workInProgress,renderLanes);case MemoComponent:{var _type2=workInProgress.type;var _unresolvedProps3=workInProgress.pendingProps;// Resolve outer props first, then resolve inner props.
var _resolvedProps3=resolveDefaultProps(_type2,_unresolvedProps3);{if(workInProgress.type!==workInProgress.elementType){var outerPropTypes=_type2.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,_resolvedProps3,// Resolved for outer only
'prop',getComponentNameFromType(_type2));}}}_resolvedProps3=resolveDefaultProps(_type2.type,_resolvedProps3);return updateMemoComponent(current,workInProgress,_type2,_resolvedProps3,renderLanes);}case SimpleMemoComponent:{return updateSimpleMemoComponent(current,workInProgress,workInProgress.type,workInProgress.pendingProps,renderLanes);}case IncompleteClassComponent:{var _Component2=workInProgress.type;var _unresolvedProps4=workInProgress.pendingProps;var _resolvedProps4=workInProgress.elementType===_Component2?_unresolvedProps4:resolveDefaultProps(_Component2,_unresolvedProps4);return mountIncompleteClassComponent(current,workInProgress,_Component2,_resolvedProps4,renderLanes);}case SuspenseListComponent:{return updateSuspenseListComponent(current,workInProgress,renderLanes);}case ScopeComponent:{break;}case OffscreenComponent:{return updateOffscreenComponent(current,workInProgress,renderLanes);}}throw new Error("Unknown unit of work tag ("+workInProgress.tag+"). This error is likely caused by a bug in "+'React. Please file an issue.');}function markUpdate(workInProgress){// Tag the fiber with an update effect. This turns a Placement into
// a PlacementAndUpdate.
workInProgress.flags|=Update;}function markRef$1(workInProgress){workInProgress.flags|=Ref;{workInProgress.flags|=RefStatic;}}var appendAllChildren;var updateHostContainer;var updateHostComponent$1;var updateHostText$1;{// Mutation mode
appendAllChildren=function(parent,workInProgress,needsVisibilityToggle,isHidden){// We only have the top Fiber that was created but we need recurse down its
// children to find all the terminal nodes.
var node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendInitialChild(parent,node.stateNode);}else if(node.tag===HostPortal);else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node.return===null||node.return===workInProgress){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}};updateHostContainer=function(current,workInProgress){// Noop
};updateHostComponent$1=function(current,workInProgress,type,newProps,rootContainerInstance){// If we have an alternate, that means this is an update and we need to
// schedule a side-effect to do the updates.
var oldProps=current.memoizedProps;if(oldProps===newProps){// In mutation mode, this is sufficient for a bailout because
// we won't touch this node even if children changed.
return;}// If we get updated because one of our children updated, we don't
// have newProps so we'll have to reuse them.
// TODO: Split the update API as separate for the props vs. children.
// Even better would be if children weren't special cased at all tho.
var instance=workInProgress.stateNode;var currentHostContext=getHostContext();// TODO: Experiencing an error where oldProps is null. Suggests a host
// component is hitting the resume path. Figure out why. Possibly
// related to `hidden`.
var updatePayload=prepareUpdate(instance,type,oldProps,newProps,rootContainerInstance,currentHostContext);// TODO: Type this specific to this type of component.
workInProgress.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there
// is a new ref we mark this as an update. All the work is done in commitWork.
if(updatePayload){markUpdate(workInProgress);}};updateHostText$1=function(current,workInProgress,oldText,newText){// If the text differs, mark it as an update. All the work in done in commitWork.
if(oldText!==newText){markUpdate(workInProgress);}};}function cutOffTailIfNeeded(renderState,hasRenderedATailFallback){if(getIsHydrating()){// If we're hydrating, we should consume as many items as we can
// so we don't leave any behind.
return;}switch(renderState.tailMode){case'hidden':{// Any insertions at the end of the tail list after this point
// should be invisible. If there are already mounted boundaries
// anything before them are not considered for collapsing.
// Therefore we need to go through the whole tail to find if
// there are any.
var tailNode=renderState.tail;var lastTailNode=null;while(tailNode!==null){if(tailNode.alternate!==null){lastTailNode=tailNode;}tailNode=tailNode.sibling;}// Next we're simply going to delete all insertions after the
// last rendered item.
if(lastTailNode===null){// All remaining items in the tail are insertions.
renderState.tail=null;}else {// Detach the insertion after the last node that was already
// inserted.
lastTailNode.sibling=null;}break;}case'collapsed':{// Any insertions at the end of the tail list after this point
// should be invisible. If there are already mounted boundaries
// anything before them are not considered for collapsing.
// Therefore we need to go through the whole tail to find if
// there are any.
var _tailNode=renderState.tail;var _lastTailNode=null;while(_tailNode!==null){if(_tailNode.alternate!==null){_lastTailNode=_tailNode;}_tailNode=_tailNode.sibling;}// Next we're simply going to delete all insertions after the
// last rendered item.
if(_lastTailNode===null){// All remaining items in the tail are insertions.
if(!hasRenderedATailFallback&&renderState.tail!==null){// We suspended during the head. We want to show at least one
// row at the tail. So we'll keep on and cut off the rest.
renderState.tail.sibling=null;}else {renderState.tail=null;}}else {// Detach the insertion after the last node that was already
// inserted.
_lastTailNode.sibling=null;}break;}}}function bubbleProperties(completedWork){var didBailout=completedWork.alternate!==null&&completedWork.alternate.child===completedWork.child;var newChildLanes=NoLanes;var subtreeFlags=NoFlags;if(!didBailout){// Bubble up the earliest expiration time.
if((completedWork.mode&ProfileMode)!==NoMode){// In profiling mode, resetChildExpirationTime is also used to reset
// profiler durations.
var actualDuration=completedWork.actualDuration;var treeBaseDuration=completedWork.selfBaseDuration;var child=completedWork.child;while(child!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(child.lanes,child.childLanes));subtreeFlags|=child.subtreeFlags;subtreeFlags|=child.flags;// When a fiber is cloned, its actualDuration is reset to 0. This value will
// only be updated if work is done on the fiber (i.e. it doesn't bailout).
// When work is done, it should bubble to the parent's actualDuration. If
// the fiber has not been cloned though, (meaning no work was done), then
// this value will reflect the amount of time spent working on a previous
// render. In that case it should not bubble. We determine whether it was
// cloned by comparing the child pointer.
actualDuration+=child.actualDuration;treeBaseDuration+=child.treeBaseDuration;child=child.sibling;}completedWork.actualDuration=actualDuration;completedWork.treeBaseDuration=treeBaseDuration;}else {var _child=completedWork.child;while(_child!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child.lanes,_child.childLanes));subtreeFlags|=_child.subtreeFlags;subtreeFlags|=_child.flags;// Update the return pointer so the tree is consistent. This is a code
// smell because it assumes the commit phase is never concurrent with
// the render phase. Will address during refactor to alternate model.
_child.return=completedWork;_child=_child.sibling;}}completedWork.subtreeFlags|=subtreeFlags;}else {// Bubble up the earliest expiration time.
if((completedWork.mode&ProfileMode)!==NoMode){// In profiling mode, resetChildExpirationTime is also used to reset
// profiler durations.
var _treeBaseDuration=completedWork.selfBaseDuration;var _child2=completedWork.child;while(_child2!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child2.lanes,_child2.childLanes));// "Static" flags share the lifetime of the fiber/hook they belong to,
// so we should bubble those up even during a bailout. All the other
// flags have a lifetime only of a single render + commit, so we should
// ignore them.
subtreeFlags|=_child2.subtreeFlags&StaticMask;subtreeFlags|=_child2.flags&StaticMask;_treeBaseDuration+=_child2.treeBaseDuration;_child2=_child2.sibling;}completedWork.treeBaseDuration=_treeBaseDuration;}else {var _child3=completedWork.child;while(_child3!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child3.lanes,_child3.childLanes));// "Static" flags share the lifetime of the fiber/hook they belong to,
// so we should bubble those up even during a bailout. All the other
// flags have a lifetime only of a single render + commit, so we should
// ignore them.
subtreeFlags|=_child3.subtreeFlags&StaticMask;subtreeFlags|=_child3.flags&StaticMask;// Update the return pointer so the tree is consistent. This is a code
// smell because it assumes the commit phase is never concurrent with
// the render phase. Will address during refactor to alternate model.
_child3.return=completedWork;_child3=_child3.sibling;}}completedWork.subtreeFlags|=subtreeFlags;}completedWork.childLanes=newChildLanes;return didBailout;}function completeDehydratedSuspenseBoundary(current,workInProgress,nextState){if(hasUnhydratedTailNodes()&&(workInProgress.mode&ConcurrentMode)!==NoMode&&(workInProgress.flags&DidCapture)===NoFlags){warnIfUnhydratedTailNodes(workInProgress);resetHydrationState();workInProgress.flags|=ForceClientRender|Incomplete|ShouldCapture;return false;}var wasHydrated=popHydrationState(workInProgress);if(nextState!==null&&nextState.dehydrated!==null){// We might be inside a hydration state the first time we're picking up this
// Suspense boundary, and also after we've reentered it for further hydration.
if(current===null){if(!wasHydrated){throw new Error('A dehydrated suspense component was completed without a hydrated node. '+'This is probably a bug in React.');}prepareToHydrateHostSuspenseInstance(workInProgress);bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){var isTimedOutSuspense=nextState!==null;if(isTimedOutSuspense){// Don't count time spent in a timed out Suspense subtree as part of the base duration.
var primaryChildFragment=workInProgress.child;if(primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator
workInProgress.treeBaseDuration-=primaryChildFragment.treeBaseDuration;}}}}return false;}else {// We might have reentered this boundary to hydrate it. If so, we need to reset the hydration
// state since we're now exiting out of it. popHydrationState doesn't do that for us.
resetHydrationState();if((workInProgress.flags&DidCapture)===NoFlags){// This boundary did not suspend so it's now hydrated and unsuspended.
workInProgress.memoizedState=null;}// If nothing suspended, we need to schedule an effect to mark this boundary
// as having hydrated so events know that they're free to be invoked.
// It's also a signal to replay events and the suspense callback.
// If something suspended, schedule an effect to attach retry listeners.
// So we might as well always mark this.
workInProgress.flags|=Update;bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){var _isTimedOutSuspense=nextState!==null;if(_isTimedOutSuspense){// Don't count time spent in a timed out Suspense subtree as part of the base duration.
var _primaryChildFragment=workInProgress.child;if(_primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator
workInProgress.treeBaseDuration-=_primaryChildFragment.treeBaseDuration;}}}}return false;}}else {// Successfully completed this tree. If this was a forced client render,
// there may have been recoverable errors during first hydration
// attempt. If so, add them to a queue so we can log them in the
// commit phase.
upgradeHydrationErrorsToRecoverable();// Fall through to normal Suspense path
return true;}}function completeWork(current,workInProgress,renderLanes){var newProps=workInProgress.pendingProps;// Note: This intentionally doesn't check if we're hydrating because comparing
// to the current tree provider fiber is just as fast and less error-prone.
// Ideally we would have a special version of the work loop only
// for hydration.
popTreeContext(workInProgress);switch(workInProgress.tag){case IndeterminateComponent:case LazyComponent:case SimpleMemoComponent:case FunctionComponent:case ForwardRef:case Fragment:case Mode:case Profiler:case ContextConsumer:case MemoComponent:bubbleProperties(workInProgress);return null;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}bubbleProperties(workInProgress);return null;}case HostRoot:{var fiberRoot=workInProgress.stateNode;popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);resetWorkInProgressVersions();if(fiberRoot.pendingContext){fiberRoot.context=fiberRoot.pendingContext;fiberRoot.pendingContext=null;}if(current===null||current.child===null){// If we hydrated, pop so that we can delete any remaining children
// that weren't hydrated.
var wasHydrated=popHydrationState(workInProgress);if(wasHydrated){// If we hydrated, then we'll need to schedule an update for
// the commit side-effects on the root.
markUpdate(workInProgress);}else {if(current!==null){var prevState=current.memoizedState;if(// Check if this is a client root
!prevState.isDehydrated||// Check if we reverted to client rendering (e.g. due to an error)
(workInProgress.flags&ForceClientRender)!==NoFlags){// Schedule an effect to clear this container at the start of the
// next commit. This handles the case of React rendering into a
// container with previous children. It's also safe to do for
// updates too, because current.child would only be null if the
// previous render was null (so the container would already
// be empty).
workInProgress.flags|=Snapshot;// If this was a forced client render, there may have been
// recoverable errors during first hydration attempt. If so, add
// them to a queue so we can log them in the commit phase.
upgradeHydrationErrorsToRecoverable();}}}}updateHostContainer(current,workInProgress);bubbleProperties(workInProgress);return null;}case HostComponent:{popHostContext(workInProgress);var rootContainerInstance=getRootHostContainer();var type=workInProgress.type;if(current!==null&&workInProgress.stateNode!=null){updateHostComponent$1(current,workInProgress,type,newProps,rootContainerInstance);if(current.ref!==workInProgress.ref){markRef$1(workInProgress);}}else {if(!newProps){if(workInProgress.stateNode===null){throw new Error('We must have new props for new mounts. This error is likely '+'caused by a bug in React. Please file an issue.');}// This can happen when we abort work.
bubbleProperties(workInProgress);return null;}var currentHostContext=getHostContext();// TODO: Move createInstance to beginWork and keep it on a context
// "stack" as the parent. Then append children as we go in beginWork
// or completeWork depending on whether we want to add them top->down or
// bottom->up. Top->down is faster in IE11.
var _wasHydrated=popHydrationState(workInProgress);if(_wasHydrated){// TODO: Move this and createInstance step into the beginPhase
// to consolidate.
if(prepareToHydrateHostInstance(workInProgress,rootContainerInstance,currentHostContext)){// If changes to the hydrated node need to be applied at the
// commit-phase we mark this as such.
markUpdate(workInProgress);}}else {var instance=createInstance(type,newProps,rootContainerInstance,currentHostContext,workInProgress);appendAllChildren(instance,workInProgress,false,false);workInProgress.stateNode=instance;// Certain renderers require commit-time effects for initial mount.
// (eg DOM renderer supports auto-focus for certain elements).
// Make sure such renderers get scheduled for later work.
if(finalizeInitialChildren(instance,type,newProps,rootContainerInstance)){markUpdate(workInProgress);}}if(workInProgress.ref!==null){// If there is a ref on a host node we need to schedule a callback
markRef$1(workInProgress);}}bubbleProperties(workInProgress);return null;}case HostText:{var newText=newProps;if(current&&workInProgress.stateNode!=null){var oldText=current.memoizedProps;// If we have an alternate, that means this is an update and we need
// to schedule a side-effect to do the updates.
updateHostText$1(current,workInProgress,oldText,newText);}else {if(typeof newText!=='string'){if(workInProgress.stateNode===null){throw new Error('We must have new props for new mounts. This error is likely '+'caused by a bug in React. Please file an issue.');}// This can happen when we abort work.
}var _rootContainerInstance=getRootHostContainer();var _currentHostContext=getHostContext();var _wasHydrated2=popHydrationState(workInProgress);if(_wasHydrated2){if(prepareToHydrateHostTextInstance(workInProgress)){markUpdate(workInProgress);}}else {workInProgress.stateNode=createTextInstance(newText,_rootContainerInstance,_currentHostContext,workInProgress);}}bubbleProperties(workInProgress);return null;}case SuspenseComponent:{popSuspenseContext(workInProgress);var nextState=workInProgress.memoizedState;// Special path for dehydrated boundaries. We may eventually move this
// to its own fiber type so that we can add other kinds of hydration
// boundaries that aren't associated with a Suspense tree. In anticipation
// of such a refactor, all the hydration logic is contained in
// this branch.
if(current===null||current.memoizedState!==null&&current.memoizedState.dehydrated!==null){var fallthroughToNormalSuspensePath=completeDehydratedSuspenseBoundary(current,workInProgress,nextState);if(!fallthroughToNormalSuspensePath){if(workInProgress.flags&ShouldCapture){// Special case. There were remaining unhydrated nodes. We treat
// this as a mismatch. Revert to client rendering.
return workInProgress;}else {// Did not finish hydrating, either because this is the initial
// render or because something suspended.
return null;}}// Continue with the normal Suspense path.
}if((workInProgress.flags&DidCapture)!==NoFlags){// Something suspended. Re-render with the fallback children.
workInProgress.lanes=renderLanes;// Do not reset the effect list.
if((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}// Don't bubble properties in this case.
return workInProgress;}var nextDidTimeout=nextState!==null;var prevDidTimeout=current!==null&&current.memoizedState!==null;// a passive effect, which is when we process the transitions
if(nextDidTimeout!==prevDidTimeout){// an effect to toggle the subtree's visibility. When we switch from
// fallback -> primary, the inner Offscreen fiber schedules this effect
// as part of its normal complete phase. But when we switch from
// primary -> fallback, the inner Offscreen fiber does not have a complete
// phase. So we need to schedule its effect here.
//
// We also use this flag to connect/disconnect the effects, but the same
// logic applies: when re-connecting, the Offscreen fiber's complete
// phase will handle scheduling the effect. It's only when the fallback
// is active that we have to do anything special.
if(nextDidTimeout){var _offscreenFiber2=workInProgress.child;_offscreenFiber2.flags|=Visibility;// TODO: This will still suspend a synchronous tree if anything
// in the concurrent tree already suspended during this render.
// This is a known bug.
if((workInProgress.mode&ConcurrentMode)!==NoMode){// TODO: Move this back to throwException because this is too late
// if this is a large tree which is common for initial loads. We
// don't know if we should restart a render or not until we get
// this marker, and this is too late.
// If this render already had a ping or lower pri updates,
// and this is the first time we know we're going to suspend we
// should be able to immediately restart from within throwException.
var hasInvisibleChildContext=current===null&&(workInProgress.memoizedProps.unstable_avoidThisFallback!==true||!enableSuspenseAvoidThisFallback);if(hasInvisibleChildContext||hasSuspenseContext(suspenseStackCursor.current,InvisibleParentSuspenseContext)){// If this was in an invisible tree or a new render, then showing
// this boundary is ok.
renderDidSuspend();}else {// Otherwise, we're going to have to hide content so we should
// suspend for longer if possible.
renderDidSuspendDelayIfPossible();}}}}var wakeables=workInProgress.updateQueue;if(wakeables!==null){// Schedule an effect to attach a retry listener to the promise.
// TODO: Move to passive phase
workInProgress.flags|=Update;}bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){if(nextDidTimeout){// Don't count time spent in a timed out Suspense subtree as part of the base duration.
var primaryChildFragment=workInProgress.child;if(primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator
workInProgress.treeBaseDuration-=primaryChildFragment.treeBaseDuration;}}}}return null;}case HostPortal:popHostContainer(workInProgress);updateHostContainer(current,workInProgress);if(current===null){preparePortalMount(workInProgress.stateNode.containerInfo);}bubbleProperties(workInProgress);return null;case ContextProvider:// Pop provider fiber
var context=workInProgress.type._context;popProvider(context,workInProgress);bubbleProperties(workInProgress);return null;case IncompleteClassComponent:{// Same as class component case. I put it down here so that the tags are
// sequential to ensure this switch is compiled to a jump table.
var _Component=workInProgress.type;if(isContextProvider(_Component)){popContext(workInProgress);}bubbleProperties(workInProgress);return null;}case SuspenseListComponent:{popSuspenseContext(workInProgress);var renderState=workInProgress.memoizedState;if(renderState===null){// We're running in the default, "independent" mode.
// We don't do anything in this mode.
bubbleProperties(workInProgress);return null;}var didSuspendAlready=(workInProgress.flags&DidCapture)!==NoFlags;var renderedTail=renderState.rendering;if(renderedTail===null){// We just rendered the head.
if(!didSuspendAlready){// This is the first pass. We need to figure out if anything is still
// suspended in the rendered set.
// If new content unsuspended, but there's still some content that
// didn't. Then we need to do a second pass that forces everything
// to keep showing their fallbacks.
// We might be suspended if something in this render pass suspended, or
// something in the previous committed pass suspended. Otherwise,
// there's no chance so we can skip the expensive call to
// findFirstSuspended.
var cannotBeSuspended=renderHasNotSuspendedYet()&&(current===null||(current.flags&DidCapture)===NoFlags);if(!cannotBeSuspended){var row=workInProgress.child;while(row!==null){var suspended=findFirstSuspended(row);if(suspended!==null){didSuspendAlready=true;workInProgress.flags|=DidCapture;cutOffTailIfNeeded(renderState,false);// If this is a newly suspended tree, it might not get committed as
// part of the second pass. In that case nothing will subscribe to
// its thenables. Instead, we'll transfer its thenables to the
// SuspenseList so that it can retry if they resolve.
// There might be multiple of these in the list but since we're
// going to wait for all of them anyway, it doesn't really matter
// which ones gets to ping. In theory we could get clever and keep
// track of how many dependencies remain but it gets tricky because
// in the meantime, we can add/remove/change items and dependencies.
// We might bail out of the loop before finding any but that
// doesn't matter since that means that the other boundaries that
// we did find already has their listeners attached.
var newThenables=suspended.updateQueue;if(newThenables!==null){workInProgress.updateQueue=newThenables;workInProgress.flags|=Update;}// Rerender the whole list, but this time, we'll force fallbacks
// to stay in place.
// Reset the effect flags before doing the second pass since that's now invalid.
// Reset the child fibers to their original state.
workInProgress.subtreeFlags=NoFlags;resetChildFibers(workInProgress,renderLanes);// Set up the Suspense Context to force suspense and immediately
// rerender the children.
pushSuspenseContext(workInProgress,setShallowSuspenseContext(suspenseStackCursor.current,ForceSuspenseFallback));// Don't bubble properties in this case.
return workInProgress.child;}row=row.sibling;}}if(renderState.tail!==null&&now()>getRenderTargetTime()){// We have already passed our CPU deadline but we still have rows
// left in the tail. We'll just give up further attempts to render
// the main content and only render fallbacks.
workInProgress.flags|=DidCapture;didSuspendAlready=true;cutOffTailIfNeeded(renderState,false);// Since nothing actually suspended, there will nothing to ping this
// to get it started back up to attempt the next item. While in terms
// of priority this work has the same priority as this current render,
// it's not part of the same transition once the transition has
// committed. If it's sync, we still want to yield so that it can be
// painted. Conceptually, this is really the same as pinging.
// We can use any RetryLane even if it's the one currently rendering
// since we're leaving it behind on this node.
workInProgress.lanes=SomeRetryLane;}}else {cutOffTailIfNeeded(renderState,false);}// Next we're going to render the tail.
}else {// Append the rendered row to the child list.
if(!didSuspendAlready){var _suspended=findFirstSuspended(renderedTail);if(_suspended!==null){workInProgress.flags|=DidCapture;didSuspendAlready=true;// Ensure we transfer the update queue to the parent so that it doesn't
// get lost if this row ends up dropped during a second pass.
var _newThenables=_suspended.updateQueue;if(_newThenables!==null){workInProgress.updateQueue=_newThenables;workInProgress.flags|=Update;}cutOffTailIfNeeded(renderState,true);// This might have been modified.
if(renderState.tail===null&&renderState.tailMode==='hidden'&&!renderedTail.alternate&&!getIsHydrating()// We don't cut it if we're hydrating.
){// We're done.
bubbleProperties(workInProgress);return null;}}else if(// The time it took to render last row is greater than the remaining
// time we have to render. So rendering one more row would likely
// exceed it.
now()*2-renderState.renderingStartTime>getRenderTargetTime()&&renderLanes!==OffscreenLane){// We have now passed our CPU deadline and we'll just give up further
// attempts to render the main content and only render fallbacks.
// The assumption is that this is usually faster.
workInProgress.flags|=DidCapture;didSuspendAlready=true;cutOffTailIfNeeded(renderState,false);// Since nothing actually suspended, there will nothing to ping this
// to get it started back up to attempt the next item. While in terms
// of priority this work has the same priority as this current render,
// it's not part of the same transition once the transition has
// committed. If it's sync, we still want to yield so that it can be
// painted. Conceptually, this is really the same as pinging.
// We can use any RetryLane even if it's the one currently rendering
// since we're leaving it behind on this node.
workInProgress.lanes=SomeRetryLane;}}if(renderState.isBackwards){// The effect list of the backwards tail will have been added
// to the end. This breaks the guarantee that life-cycles fire in
// sibling order but that isn't a strong guarantee promised by React.
// Especially since these might also just pop in during future commits.
// Append to the beginning of the list.
renderedTail.sibling=workInProgress.child;workInProgress.child=renderedTail;}else {var previousSibling=renderState.last;if(previousSibling!==null){previousSibling.sibling=renderedTail;}else {workInProgress.child=renderedTail;}renderState.last=renderedTail;}}if(renderState.tail!==null){// We still have tail rows to render.
// Pop a row.
var next=renderState.tail;renderState.rendering=next;renderState.tail=next.sibling;renderState.renderingStartTime=now();next.sibling=null;// Restore the context.
// TODO: We can probably just avoid popping it instead and only
// setting it the first time we go from not suspended to suspended.
var suspenseContext=suspenseStackCursor.current;if(didSuspendAlready){suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback);}else {suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);}pushSuspenseContext(workInProgress,suspenseContext);// Do a pass over the next row.
// Don't bubble properties in this case.
return next;}bubbleProperties(workInProgress);return null;}case ScopeComponent:{break;}case OffscreenComponent:case LegacyHiddenComponent:{popRenderLanes(workInProgress);var _nextState=workInProgress.memoizedState;var nextIsHidden=_nextState!==null;if(current!==null){var _prevState=current.memoizedState;var prevIsHidden=_prevState!==null;if(prevIsHidden!==nextIsHidden&&// LegacyHidden doesn't do any hiding — it only pre-renders.
!enableLegacyHidden){workInProgress.flags|=Visibility;}}if(!nextIsHidden||(workInProgress.mode&ConcurrentMode)===NoMode){bubbleProperties(workInProgress);}else {// Don't bubble properties for hidden children unless we're rendering
// at offscreen priority.
if(includesSomeLane(subtreeRenderLanes,OffscreenLane)){bubbleProperties(workInProgress);{// Check if there was an insertion or update in the hidden subtree.
// If so, we need to hide those nodes in the commit phase, so
// schedule a visibility effect.
if(workInProgress.subtreeFlags&(Placement|Update)){workInProgress.flags|=Visibility;}}}}return null;}case CacheComponent:{return null;}case TracingMarkerComponent:{return null;}}throw new Error("Unknown unit of work tag ("+workInProgress.tag+"). This error is likely caused by a bug in "+'React. Please file an issue.');}function unwindWork(current,workInProgress,renderLanes){// Note: This intentionally doesn't check if we're hydrating because comparing
// to the current tree provider fiber is just as fast and less error-prone.
// Ideally we would have a special version of the work loop only
// for hydration.
popTreeContext(workInProgress);switch(workInProgress.tag){case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}var flags=workInProgress.flags;if(flags&ShouldCapture){workInProgress.flags=flags&~ShouldCapture|DidCapture;if((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}return workInProgress;}return null;}case HostRoot:{workInProgress.stateNode;popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);resetWorkInProgressVersions();var _flags=workInProgress.flags;if((_flags&ShouldCapture)!==NoFlags&&(_flags&DidCapture)===NoFlags){// There was an error during render that wasn't captured by a suspense
// boundary. Do a second pass on the root to unmount the children.
workInProgress.flags=_flags&~ShouldCapture|DidCapture;return workInProgress;}// We unwound to the root without completing it. Exit.
return null;}case HostComponent:{// TODO: popHydrationState
popHostContext(workInProgress);return null;}case SuspenseComponent:{popSuspenseContext(workInProgress);var suspenseState=workInProgress.memoizedState;if(suspenseState!==null&&suspenseState.dehydrated!==null){if(workInProgress.alternate===null){throw new Error('Threw in newly mounted dehydrated component. This is likely a bug in '+'React. Please file an issue.');}resetHydrationState();}var _flags2=workInProgress.flags;if(_flags2&ShouldCapture){workInProgress.flags=_flags2&~ShouldCapture|DidCapture;// Captured a suspense effect. Re-render the boundary.
if((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}return workInProgress;}return null;}case SuspenseListComponent:{popSuspenseContext(workInProgress);// SuspenseList doesn't actually catch anything. It should've been
// caught by a nested boundary. If not, it should bubble through.
return null;}case HostPortal:popHostContainer(workInProgress);return null;case ContextProvider:var context=workInProgress.type._context;popProvider(context,workInProgress);return null;case OffscreenComponent:case LegacyHiddenComponent:popRenderLanes(workInProgress);return null;case CacheComponent:return null;default:return null;}}function unwindInterruptedWork(current,interruptedWork,renderLanes){// Note: This intentionally doesn't check if we're hydrating because comparing
// to the current tree provider fiber is just as fast and less error-prone.
// Ideally we would have a special version of the work loop only
// for hydration.
popTreeContext(interruptedWork);switch(interruptedWork.tag){case ClassComponent:{var childContextTypes=interruptedWork.type.childContextTypes;if(childContextTypes!==null&&childContextTypes!==undefined){popContext(interruptedWork);}break;}case HostRoot:{interruptedWork.stateNode;popHostContainer(interruptedWork);popTopLevelContextObject(interruptedWork);resetWorkInProgressVersions();break;}case HostComponent:{popHostContext(interruptedWork);break;}case HostPortal:popHostContainer(interruptedWork);break;case SuspenseComponent:popSuspenseContext(interruptedWork);break;case SuspenseListComponent:popSuspenseContext(interruptedWork);break;case ContextProvider:var context=interruptedWork.type._context;popProvider(context,interruptedWork);break;case OffscreenComponent:case LegacyHiddenComponent:popRenderLanes(interruptedWork);break;}}var didWarnAboutUndefinedSnapshotBeforeUpdate=null;{didWarnAboutUndefinedSnapshotBeforeUpdate=new Set();}// Used during the commit phase to track the state of the Offscreen component stack.
// Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.
// Only used when enableSuspenseLayoutEffectSemantics is enabled.
var offscreenSubtreeIsHidden=false;var offscreenSubtreeWasHidden=false;var PossiblyWeakSet=typeof WeakSet==='function'?WeakSet:Set;var nextEffect=null;// Used for Profiling builds to track updaters.
var inProgressLanes=null;var inProgressRoot=null;function reportUncaughtErrorInDEV(error){// Wrapping each small part of the commit phase into a guarded
// callback is a bit too slow (https://github.com/facebook/react/pull/21666).
// But we rely on it to surface errors to DEV tools like overlays
// (https://github.com/facebook/react/issues/21712).
// As a compromise, rethrow only caught errors in a guard.
{invokeGuardedCallback(null,function(){throw error;});clearCaughtError();}}var callComponentWillUnmountWithTimer=function(current,instance){instance.props=current.memoizedProps;instance.state=current.memoizedState;if(current.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentWillUnmount();}finally{recordLayoutEffectDuration(current);}}else {instance.componentWillUnmount();}};// Capture errors so they don't interrupt mounting.
function safelyCallCommitHookLayoutEffectListMount(current,nearestMountedAncestor){try{commitHookEffectListMount(Layout,current);}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt unmounting.
function safelyCallComponentWillUnmount(current,nearestMountedAncestor,instance){try{callComponentWillUnmountWithTimer(current,instance);}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt mounting.
function safelyCallComponentDidMount(current,nearestMountedAncestor,instance){try{instance.componentDidMount();}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt mounting.
function safelyAttachRef(current,nearestMountedAncestor){try{commitAttachRef(current);}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}function safelyDetachRef(current,nearestMountedAncestor){var ref=current.ref;if(ref!==null){if(typeof ref==='function'){var retVal;try{if(enableProfilerTimer&&enableProfilerCommitHooks&&current.mode&ProfileMode){try{startLayoutEffectTimer();retVal=ref(null);}finally{recordLayoutEffectDuration(current);}}else {retVal=ref(null);}}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}{if(typeof retVal==='function'){error('Unexpected return value from a callback ref in %s. '+'A callback ref should not return a function.',getComponentNameFromFiber(current));}}}else {ref.current=null;}}}function safelyCallDestroy(current,nearestMountedAncestor,destroy){try{destroy();}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}var shouldFireAfterActiveInstanceBlur=false;function commitBeforeMutationEffects(root,firstChild){prepareForCommit(root.containerInfo);nextEffect=firstChild;commitBeforeMutationEffects_begin();// We no longer need to track the active instance fiber
var shouldFire=shouldFireAfterActiveInstanceBlur;shouldFireAfterActiveInstanceBlur=false;return shouldFire;}function commitBeforeMutationEffects_begin(){while(nextEffect!==null){var fiber=nextEffect;// This phase is only used for beforeActiveInstanceBlur.
var child=fiber.child;if((fiber.subtreeFlags&BeforeMutationMask)!==NoFlags&&child!==null){child.return=fiber;nextEffect=child;}else {commitBeforeMutationEffects_complete();}}}function commitBeforeMutationEffects_complete(){while(nextEffect!==null){var fiber=nextEffect;setCurrentFiber(fiber);try{commitBeforeMutationEffectsOnFiber(fiber);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}resetCurrentFiber();var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function commitBeforeMutationEffectsOnFiber(finishedWork){var current=finishedWork.alternate;var flags=finishedWork.flags;if((flags&Snapshot)!==NoFlags){setCurrentFiber(finishedWork);switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{break;}case ClassComponent:{if(current!==null){var prevProps=current.memoizedProps;var prevState=current.memoizedState;var instance=finishedWork.stateNode;// We could update instance props and state here,
// but instead we rely on them being set during last render.
// TODO: revisit this when we implement resuming.
{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'getSnapshotBeforeUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'getSnapshotBeforeUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}var snapshot=instance.getSnapshotBeforeUpdate(finishedWork.elementType===finishedWork.type?prevProps:resolveDefaultProps(finishedWork.type,prevProps),prevState);{var didWarnSet=didWarnAboutUndefinedSnapshotBeforeUpdate;if(snapshot===undefined&&!didWarnSet.has(finishedWork.type)){didWarnSet.add(finishedWork.type);error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) '+'must be returned. You have returned undefined.',getComponentNameFromFiber(finishedWork));}}instance.__reactInternalSnapshotBeforeUpdate=snapshot;}break;}case HostRoot:{{var root=finishedWork.stateNode;clearContainer(root.containerInfo);}break;}case HostComponent:case HostText:case HostPortal:case IncompleteClassComponent:// Nothing to do for these component types
break;default:{throw new Error('This unit of work tag should not have side-effects. This error is '+'likely caused by a bug in React. Please file an issue.');}}resetCurrentFiber();}}function commitHookEffectListUnmount(flags,finishedWork,nearestMountedAncestor){var updateQueue=finishedWork.updateQueue;var lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{if((effect.tag&flags)===flags){// Unmount
var destroy=effect.destroy;effect.destroy=undefined;if(destroy!==undefined){{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectUnmountStarted(finishedWork);}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectUnmountStarted(finishedWork);}}{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(true);}}safelyCallDestroy(finishedWork,nearestMountedAncestor,destroy);{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(false);}}{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectUnmountStopped();}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectUnmountStopped();}}}}effect=effect.next;}while(effect!==firstEffect);}}function commitHookEffectListMount(flags,finishedWork){var updateQueue=finishedWork.updateQueue;var lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{if((effect.tag&flags)===flags){{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectMountStarted(finishedWork);}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectMountStarted(finishedWork);}}// Mount
var create=effect.create;{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(true);}}effect.destroy=create();{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(false);}}{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectMountStopped();}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectMountStopped();}}{var destroy=effect.destroy;if(destroy!==undefined&&typeof destroy!=='function'){var hookName=void 0;if((effect.tag&Layout)!==NoFlags){hookName='useLayoutEffect';}else if((effect.tag&Insertion)!==NoFlags){hookName='useInsertionEffect';}else {hookName='useEffect';}var addendum=void 0;if(destroy===null){addendum=' You returned null. If your effect does not require clean '+'up, return undefined (or nothing).';}else if(typeof destroy.then==='function'){addendum='\n\nIt looks like you wrote '+hookName+'(async () => ...) or returned a Promise. '+'Instead, write the async function inside your effect '+'and call it immediately:\n\n'+hookName+'(() => {\n'+'  async function fetchData() {\n'+'    // You can await here\n'+'    const response = await MyAPI.getData(someId);\n'+'    // ...\n'+'  }\n'+'  fetchData();\n'+"}, [someId]); // Or [] if effect doesn't need props or state\n\n"+'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';}else {addendum=' You returned: '+destroy;}error('%s must not return anything besides a function, '+'which is used for clean-up.%s',hookName,addendum);}}}effect=effect.next;}while(effect!==firstEffect);}}function commitPassiveEffectDurations(finishedRoot,finishedWork){{// Only Profilers with work in their subtree will have an Update effect scheduled.
if((finishedWork.flags&Update)!==NoFlags){switch(finishedWork.tag){case Profiler:{var passiveEffectDuration=finishedWork.stateNode.passiveEffectDuration;var _finishedWork$memoize=finishedWork.memoizedProps,id=_finishedWork$memoize.id,onPostCommit=_finishedWork$memoize.onPostCommit;// This value will still reflect the previous commit phase.
// It does not get reset until the start of the next commit phase.
var commitTime=getCommitTime();var phase=finishedWork.alternate===null?'mount':'update';{if(isCurrentUpdateNested()){phase='nested-update';}}if(typeof onPostCommit==='function'){onPostCommit(id,phase,passiveEffectDuration,commitTime);}// Bubble times to the next nearest ancestor Profiler.
// After we process that Profiler, we'll bubble further up.
var parentFiber=finishedWork.return;outer:while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.passiveEffectDuration+=passiveEffectDuration;break outer;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.passiveEffectDuration+=passiveEffectDuration;break outer;}parentFiber=parentFiber.return;}break;}}}}}function commitLayoutEffectOnFiber(finishedRoot,current,finishedWork,committedLanes){if((finishedWork.flags&LayoutMask)!==NoFlags){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(!offscreenSubtreeWasHidden){// At this point layout effects have already been destroyed (during mutation phase).
// This is done to prevent sibling component effects from interfering with each other,
// e.g. a destroy function in one component should never override a ref set
// by a create function in another component during the same commit.
if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListMount(Layout|HasEffect,finishedWork);}finally{recordLayoutEffectDuration(finishedWork);}}else {commitHookEffectListMount(Layout|HasEffect,finishedWork);}}break;}case ClassComponent:{var instance=finishedWork.stateNode;if(finishedWork.flags&Update){if(!offscreenSubtreeWasHidden){if(current===null){// We could update instance props and state here,
// but instead we rely on them being set during last render.
// TODO: revisit this when we implement resuming.
{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'componentDidMount. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'componentDidMount. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentDidMount();}finally{recordLayoutEffectDuration(finishedWork);}}else {instance.componentDidMount();}}else {var prevProps=finishedWork.elementType===finishedWork.type?current.memoizedProps:resolveDefaultProps(finishedWork.type,current.memoizedProps);var prevState=current.memoizedState;// We could update instance props and state here,
// but instead we rely on them being set during last render.
// TODO: revisit this when we implement resuming.
{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'componentDidUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'componentDidUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate);}finally{recordLayoutEffectDuration(finishedWork);}}else {instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate);}}}}// TODO: I think this is now always non-null by the time it reaches the
// commit phase. Consider removing the type check.
var updateQueue=finishedWork.updateQueue;if(updateQueue!==null){{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'processing the update queue. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'processing the update queue. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}// We could update instance props and state here,
// but instead we rely on them being set during last render.
// TODO: revisit this when we implement resuming.
commitUpdateQueue(finishedWork,updateQueue,instance);}break;}case HostRoot:{// TODO: I think this is now always non-null by the time it reaches the
// commit phase. Consider removing the type check.
var _updateQueue=finishedWork.updateQueue;if(_updateQueue!==null){var _instance=null;if(finishedWork.child!==null){switch(finishedWork.child.tag){case HostComponent:_instance=getPublicInstance(finishedWork.child.stateNode);break;case ClassComponent:_instance=finishedWork.child.stateNode;break;}}commitUpdateQueue(finishedWork,_updateQueue,_instance);}break;}case HostComponent:{var _instance2=finishedWork.stateNode;// Renderers may schedule work to be done after host components are mounted
// (eg DOM renderer may schedule auto-focus for inputs and form controls).
// These effects should only be committed when components are first mounted,
// aka when there is no current/alternate.
if(current===null&&finishedWork.flags&Update){var type=finishedWork.type;var props=finishedWork.memoizedProps;commitMount(_instance2,type,props);}break;}case HostText:{// We have no life-cycles associated with text.
break;}case HostPortal:{// We have no life-cycles associated with portals.
break;}case Profiler:{{var _finishedWork$memoize2=finishedWork.memoizedProps,onCommit=_finishedWork$memoize2.onCommit,onRender=_finishedWork$memoize2.onRender;var effectDuration=finishedWork.stateNode.effectDuration;var commitTime=getCommitTime();var phase=current===null?'mount':'update';{if(isCurrentUpdateNested()){phase='nested-update';}}if(typeof onRender==='function'){onRender(finishedWork.memoizedProps.id,phase,finishedWork.actualDuration,finishedWork.treeBaseDuration,finishedWork.actualStartTime,commitTime);}{if(typeof onCommit==='function'){onCommit(finishedWork.memoizedProps.id,phase,effectDuration,commitTime);}// Schedule a passive effect for this Profiler to call onPostCommit hooks.
// This effect should be scheduled even if there is no onPostCommit callback for this Profiler,
// because the effect is also where times bubble to parent Profilers.
enqueuePendingPassiveProfilerEffect(finishedWork);// Propagate layout effect durations to the next nearest Profiler ancestor.
// Do not reset these values until the next render so DevTools has a chance to read them first.
var parentFiber=finishedWork.return;outer:while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.effectDuration+=effectDuration;break outer;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.effectDuration+=effectDuration;break outer;}parentFiber=parentFiber.return;}}}break;}case SuspenseComponent:{commitSuspenseHydrationCallbacks(finishedRoot,finishedWork);break;}case SuspenseListComponent:case IncompleteClassComponent:case ScopeComponent:case OffscreenComponent:case LegacyHiddenComponent:case TracingMarkerComponent:{break;}default:throw new Error('This unit of work tag should not have side-effects. This error is '+'likely caused by a bug in React. Please file an issue.');}}if(!offscreenSubtreeWasHidden){{if(finishedWork.flags&Ref){commitAttachRef(finishedWork);}}}}function reappearLayoutEffectsOnFiber(node){// Turn on layout effects in a tree that previously disappeared.
// TODO (Offscreen) Check: flags & LayoutStatic
switch(node.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(node.mode&ProfileMode){try{startLayoutEffectTimer();safelyCallCommitHookLayoutEffectListMount(node,node.return);}finally{recordLayoutEffectDuration(node);}}else {safelyCallCommitHookLayoutEffectListMount(node,node.return);}break;}case ClassComponent:{var instance=node.stateNode;if(typeof instance.componentDidMount==='function'){safelyCallComponentDidMount(node,node.return,instance);}safelyAttachRef(node,node.return);break;}case HostComponent:{safelyAttachRef(node,node.return);break;}}}function hideOrUnhideAllChildren(finishedWork,isHidden){// Only hide or unhide the top-most host nodes.
var hostSubtreeRoot=null;{// We only have the top Fiber that was inserted but we need to recurse down its
// children to find all the terminal nodes.
var node=finishedWork;while(true){if(node.tag===HostComponent){if(hostSubtreeRoot===null){hostSubtreeRoot=node;try{var instance=node.stateNode;if(isHidden){hideInstance(instance);}else {unhideInstance(node.stateNode,node.memoizedProps);}}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}else if(node.tag===HostText){if(hostSubtreeRoot===null){try{var _instance3=node.stateNode;if(isHidden){hideTextInstance(_instance3);}else {unhideTextInstance(_instance3,node.memoizedProps);}}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}else if((node.tag===OffscreenComponent||node.tag===LegacyHiddenComponent)&&node.memoizedState!==null&&node!==finishedWork);else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===finishedWork){return;}while(node.sibling===null){if(node.return===null||node.return===finishedWork){return;}if(hostSubtreeRoot===node){hostSubtreeRoot=null;}node=node.return;}if(hostSubtreeRoot===node){hostSubtreeRoot=null;}node.sibling.return=node.return;node=node.sibling;}}}function commitAttachRef(finishedWork){var ref=finishedWork.ref;if(ref!==null){var instance=finishedWork.stateNode;var instanceToUse;switch(finishedWork.tag){case HostComponent:instanceToUse=getPublicInstance(instance);break;default:instanceToUse=instance;}// Moved outside to ensure DCE works with this flag
if(typeof ref==='function'){var retVal;if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();retVal=ref(instanceToUse);}finally{recordLayoutEffectDuration(finishedWork);}}else {retVal=ref(instanceToUse);}{if(typeof retVal==='function'){error('Unexpected return value from a callback ref in %s. '+'A callback ref should not return a function.',getComponentNameFromFiber(finishedWork));}}}else {{if(!ref.hasOwnProperty('current')){error('Unexpected ref object provided for %s. '+'Use either a ref-setter function or React.createRef().',getComponentNameFromFiber(finishedWork));}}ref.current=instanceToUse;}}}function detachFiberMutation(fiber){// Cut off the return pointer to disconnect it from the tree.
// This enables us to detect and warn against state updates on an unmounted component.
// It also prevents events from bubbling from within disconnected components.
//
// Ideally, we should also clear the child pointer of the parent alternate to let this
// get GC:ed but we don't know which for sure which parent is the current
// one so we'll settle for GC:ing the subtree of this child.
// This child itself will be GC:ed when the parent updates the next time.
//
// Note that we can't clear child or sibling pointers yet.
// They're needed for passive effects and for findDOMNode.
// We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).
//
// Don't reset the alternate yet, either. We need that so we can detach the
// alternate's fields in the passive phase. Clearing the return pointer is
// sufficient for findDOMNode semantics.
var alternate=fiber.alternate;if(alternate!==null){alternate.return=null;}fiber.return=null;}function detachFiberAfterEffects(fiber){var alternate=fiber.alternate;if(alternate!==null){fiber.alternate=null;detachFiberAfterEffects(alternate);}// Note: Defensively using negation instead of < in case
// `deletedTreeCleanUpLevel` is undefined.
{// Clear cyclical Fiber fields. This level alone is designed to roughly
// approximate the planned Fiber refactor. In that world, `setState` will be
// bound to a special "instance" object instead of a Fiber. The Instance
// object will not have any of these fields. It will only be connected to
// the fiber tree via a single link at the root. So if this level alone is
// sufficient to fix memory issues, that bodes well for our plans.
fiber.child=null;fiber.deletions=null;fiber.sibling=null;// The `stateNode` is cyclical because on host nodes it points to the host
// tree, which has its own pointers to children, parents, and siblings.
// The other host nodes also point back to fibers, so we should detach that
// one, too.
if(fiber.tag===HostComponent){var hostInstance=fiber.stateNode;if(hostInstance!==null){detachDeletedInstance(hostInstance);}}fiber.stateNode=null;// I'm intentionally not clearing the `return` field in this level. We
// already disconnect the `return` pointer at the root of the deleted
// subtree (in `detachFiberMutation`). Besides, `return` by itself is not
// cyclical — it's only cyclical when combined with `child`, `sibling`, and
// `alternate`. But we'll clear it in the next level anyway, just in case.
{fiber._debugOwner=null;}{// Theoretically, nothing in here should be necessary, because we already
// disconnected the fiber from the tree. So even if something leaks this
// particular fiber, it won't leak anything else
//
// The purpose of this branch is to be super aggressive so we can measure
// if there's any difference in memory impact. If there is, that could
// indicate a React leak we don't know about.
fiber.return=null;fiber.dependencies=null;fiber.memoizedProps=null;fiber.memoizedState=null;fiber.pendingProps=null;fiber.stateNode=null;// TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.
fiber.updateQueue=null;}}}function getHostParentFiber(fiber){var parent=fiber.return;while(parent!==null){if(isHostParent(parent)){return parent;}parent=parent.return;}throw new Error('Expected to find a host parent. This error is likely caused by a bug '+'in React. Please file an issue.');}function isHostParent(fiber){return fiber.tag===HostComponent||fiber.tag===HostRoot||fiber.tag===HostPortal;}function getHostSibling(fiber){// We're going to search forward into the tree until we find a sibling host
// node. Unfortunately, if multiple insertions are done in a row we have to
// search past them. This leads to exponential search for the next sibling.
// TODO: Find a more efficient way to do this.
var node=fiber;siblings:while(true){// If we didn't find anything, let's try the next sibling.
while(node.sibling===null){if(node.return===null||isHostParent(node.return)){// If we pop out of the root or hit the parent the fiber we are the
// last sibling.
return null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;while(node.tag!==HostComponent&&node.tag!==HostText&&node.tag!==DehydratedFragment){// If it is not host node and, we might have a host node inside it.
// Try to search down until we find one.
if(node.flags&Placement){// If we don't have a child, try the siblings instead.
continue siblings;}// If we don't have a child, try the siblings instead.
// We also skip portals because they are not part of this host tree.
if(node.child===null||node.tag===HostPortal){continue siblings;}else {node.child.return=node;node=node.child;}}// Check if this host node is stable or about to be placed.
if(!(node.flags&Placement)){// Found it!
return node.stateNode;}}}function commitPlacement(finishedWork){var parentFiber=getHostParentFiber(finishedWork);// Note: these two variables *must* always be updated together.
switch(parentFiber.tag){case HostComponent:{var parent=parentFiber.stateNode;if(parentFiber.flags&ContentReset){// Reset the text content of the parent before doing any insertions
resetTextContent(parent);// Clear ContentReset from the effect tag
parentFiber.flags&=~ContentReset;}var before=getHostSibling(finishedWork);// We only have the top Fiber that was inserted but we need to recurse down its
// children to find all the terminal nodes.
insertOrAppendPlacementNode(finishedWork,before,parent);break;}case HostRoot:case HostPortal:{var _parent=parentFiber.stateNode.containerInfo;var _before=getHostSibling(finishedWork);insertOrAppendPlacementNodeIntoContainer(finishedWork,_before,_parent);break;}// eslint-disable-next-line-no-fallthrough
default:throw new Error('Invalid host parent fiber. This error is likely caused by a bug '+'in React. Please file an issue.');}}function insertOrAppendPlacementNodeIntoContainer(node,before,parent){var tag=node.tag;var isHost=tag===HostComponent||tag===HostText;if(isHost){var stateNode=node.stateNode;if(before){insertInContainerBefore(parent,stateNode,before);}else {appendChildToContainer(parent,stateNode);}}else if(tag===HostPortal);else {var child=node.child;if(child!==null){insertOrAppendPlacementNodeIntoContainer(child,before,parent);var sibling=child.sibling;while(sibling!==null){insertOrAppendPlacementNodeIntoContainer(sibling,before,parent);sibling=sibling.sibling;}}}}function insertOrAppendPlacementNode(node,before,parent){var tag=node.tag;var isHost=tag===HostComponent||tag===HostText;if(isHost){var stateNode=node.stateNode;if(before){insertBefore(parent,stateNode,before);}else {appendChild(parent,stateNode);}}else if(tag===HostPortal);else {var child=node.child;if(child!==null){insertOrAppendPlacementNode(child,before,parent);var sibling=child.sibling;while(sibling!==null){insertOrAppendPlacementNode(sibling,before,parent);sibling=sibling.sibling;}}}}// These are tracked on the stack as we recursively traverse a
// deleted subtree.
// TODO: Update these during the whole mutation phase, not just during
// a deletion.
var hostParent=null;var hostParentIsContainer=false;function commitDeletionEffects(root,returnFiber,deletedFiber){{// We only have the top Fiber that was deleted but we need to recurse down its
// children to find all the terminal nodes.
// Recursively delete all host nodes from the parent, detach refs, clean
// up mounted layout effects, and call componentWillUnmount.
// We only need to remove the topmost host child in each branch. But then we
// still need to keep traversing to unmount effects, refs, and cWU. TODO: We
// could split this into two separate traversals functions, where the second
// one doesn't include any removeChild logic. This is maybe the same
// function as "disappearLayoutEffects" (or whatever that turns into after
// the layout phase is refactored to use recursion).
// Before starting, find the nearest host parent on the stack so we know
// which instance/container to remove the children from.
// TODO: Instead of searching up the fiber return path on every deletion, we
// can track the nearest host component on the JS stack as we traverse the
// tree during the commit phase. This would make insertions faster, too.
var parent=returnFiber;findParent:while(parent!==null){switch(parent.tag){case HostComponent:{hostParent=parent.stateNode;hostParentIsContainer=false;break findParent;}case HostRoot:{hostParent=parent.stateNode.containerInfo;hostParentIsContainer=true;break findParent;}case HostPortal:{hostParent=parent.stateNode.containerInfo;hostParentIsContainer=true;break findParent;}}parent=parent.return;}if(hostParent===null){throw new Error('Expected to find a host parent. This error is likely caused by '+'a bug in React. Please file an issue.');}commitDeletionEffectsOnFiber(root,returnFiber,deletedFiber);hostParent=null;hostParentIsContainer=false;}detachFiberMutation(deletedFiber);}function recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,parent){// TODO: Use a static flag to skip trees that don't have unmount effects
var child=parent.child;while(child!==null){commitDeletionEffectsOnFiber(finishedRoot,nearestMountedAncestor,child);child=child.sibling;}}function commitDeletionEffectsOnFiber(finishedRoot,nearestMountedAncestor,deletedFiber){onCommitUnmount(deletedFiber);// The cases in this outer switch modify the stack before they traverse
// into their subtree. There are simpler cases in the inner switch
// that don't modify the stack.
switch(deletedFiber.tag){case HostComponent:{if(!offscreenSubtreeWasHidden){safelyDetachRef(deletedFiber,nearestMountedAncestor);}// Intentional fallthrough to next branch
}// eslint-disable-next-line-no-fallthrough
case HostText:{// We only need to remove the nearest host child. Set the host parent
// to `null` on the stack to indicate that nested children don't
// need to be removed.
{var prevHostParent=hostParent;var prevHostParentIsContainer=hostParentIsContainer;hostParent=null;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);hostParent=prevHostParent;hostParentIsContainer=prevHostParentIsContainer;if(hostParent!==null){// Now that all the child effects have unmounted, we can remove the
// node from the tree.
if(hostParentIsContainer){removeChildFromContainer(hostParent,deletedFiber.stateNode);}else {removeChild(hostParent,deletedFiber.stateNode);}}}return;}case DehydratedFragment:{// Delete the dehydrated suspense boundary and all of its content.
{if(hostParent!==null){if(hostParentIsContainer){clearSuspenseBoundaryFromContainer(hostParent,deletedFiber.stateNode);}else {clearSuspenseBoundary(hostParent,deletedFiber.stateNode);}}}return;}case HostPortal:{{// When we go into a portal, it becomes the parent to remove from.
var _prevHostParent=hostParent;var _prevHostParentIsContainer=hostParentIsContainer;hostParent=deletedFiber.stateNode.containerInfo;hostParentIsContainer=true;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);hostParent=_prevHostParent;hostParentIsContainer=_prevHostParentIsContainer;}return;}case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{if(!offscreenSubtreeWasHidden){var updateQueue=deletedFiber.updateQueue;if(updateQueue!==null){var lastEffect=updateQueue.lastEffect;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{var _effect=effect,destroy=_effect.destroy,tag=_effect.tag;if(destroy!==undefined){if((tag&Insertion)!==NoFlags$1){safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy);}else if((tag&Layout)!==NoFlags$1){{markComponentLayoutEffectUnmountStarted(deletedFiber);}if(deletedFiber.mode&ProfileMode){startLayoutEffectTimer();safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy);recordLayoutEffectDuration(deletedFiber);}else {safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy);}{markComponentLayoutEffectUnmountStopped();}}}effect=effect.next;}while(effect!==firstEffect);}}}recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}case ClassComponent:{if(!offscreenSubtreeWasHidden){safelyDetachRef(deletedFiber,nearestMountedAncestor);var instance=deletedFiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(deletedFiber,nearestMountedAncestor,instance);}}recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}case ScopeComponent:{recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}case OffscreenComponent:{if(// TODO: Remove this dead flag
deletedFiber.mode&ConcurrentMode){// If this offscreen component is hidden, we already unmounted it. Before
// deleting the children, track that it's already unmounted so that we
// don't attempt to unmount the effects again.
// TODO: If the tree is hidden, in most cases we should be able to skip
// over the nested children entirely. An exception is we haven't yet found
// the topmost host node to delete, which we already track on the stack.
// But the other case is portals, which need to be detached no matter how
// deeply they are nested. We should use a subtree flag to track whether a
// subtree includes a nested portal.
var prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden||deletedFiber.memoizedState!==null;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;}else {recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);}break;}default:{recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}}}function commitSuspenseCallback(finishedWork){// TODO: Move this to passive phase
finishedWork.memoizedState;}function commitSuspenseHydrationCallbacks(finishedRoot,finishedWork){var newState=finishedWork.memoizedState;if(newState===null){var current=finishedWork.alternate;if(current!==null){var prevState=current.memoizedState;if(prevState!==null){var suspenseInstance=prevState.dehydrated;if(suspenseInstance!==null){commitHydratedSuspenseInstance(suspenseInstance);}}}}}function attachSuspenseRetryListeners(finishedWork){// If this boundary just timed out, then it will have a set of wakeables.
// For each wakeable, attach a listener so that when it resolves, React
// attempts to re-render the boundary in the primary (pre-timeout) state.
var wakeables=finishedWork.updateQueue;if(wakeables!==null){finishedWork.updateQueue=null;var retryCache=finishedWork.stateNode;if(retryCache===null){retryCache=finishedWork.stateNode=new PossiblyWeakSet();}wakeables.forEach(function(wakeable){// Memoize using the boundary fiber to prevent redundant listeners.
var retry=resolveRetryWakeable.bind(null,finishedWork,wakeable);if(!retryCache.has(wakeable)){retryCache.add(wakeable);{if(isDevToolsPresent){if(inProgressLanes!==null&&inProgressRoot!==null){// If we have pending work still, associate the original updaters with it.
restorePendingUpdaters(inProgressRoot,inProgressLanes);}else {throw Error('Expected finished root and lanes to be set. This is a bug in React.');}}}wakeable.then(retry,retry);}});}}// This function detects when a Suspense boundary goes from visible to hidden.
function commitMutationEffects(root,finishedWork,committedLanes){inProgressLanes=committedLanes;inProgressRoot=root;setCurrentFiber(finishedWork);commitMutationEffectsOnFiber(finishedWork,root);setCurrentFiber(finishedWork);inProgressLanes=null;inProgressRoot=null;}function recursivelyTraverseMutationEffects(root,parentFiber,lanes){// Deletions effects can be scheduled on any fiber type. They need to happen
// before the children effects hae fired.
var deletions=parentFiber.deletions;if(deletions!==null){for(var i=0;i<deletions.length;i++){var childToDelete=deletions[i];try{commitDeletionEffects(root,parentFiber,childToDelete);}catch(error){captureCommitPhaseError(childToDelete,parentFiber,error);}}}var prevDebugFiber=getCurrentFiber();if(parentFiber.subtreeFlags&MutationMask){var child=parentFiber.child;while(child!==null){setCurrentFiber(child);commitMutationEffectsOnFiber(child,root);child=child.sibling;}}setCurrentFiber(prevDebugFiber);}function commitMutationEffectsOnFiber(finishedWork,root,lanes){var current=finishedWork.alternate;var flags=finishedWork.flags;// The effect flag should be checked *after* we refine the type of fiber,
// because the fiber tag is more specific. An exception is any flag related
// to reconcilation, because those can be set on all fiber types.
switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){try{commitHookEffectListUnmount(Insertion|HasEffect,finishedWork,finishedWork.return);commitHookEffectListMount(Insertion|HasEffect,finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}// Layout effects are destroyed during the mutation phase so that all
// destroy functions for all fibers are called before any create functions.
// This prevents sibling component effects from interfering with each other,
// e.g. a destroy function in one component should never override a ref set
// by a create function in another component during the same commit.
if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork.return);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}recordLayoutEffectDuration(finishedWork);}else {try{commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork.return);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}return;}case ClassComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Ref){if(current!==null){safelyDetachRef(current,current.return);}}return;}case HostComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Ref){if(current!==null){safelyDetachRef(current,current.return);}}{// TODO: ContentReset gets cleared by the children during the commit
// phase. This is a refactor hazard because it means we must read
// flags the flags after `commitReconciliationEffects` has already run;
// the order matters. We should refactor so that ContentReset does not
// rely on mutating the flag during commit. Like by setting a flag
// during the render phase instead.
if(finishedWork.flags&ContentReset){var instance=finishedWork.stateNode;try{resetTextContent(instance);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}if(flags&Update){var _instance4=finishedWork.stateNode;if(_instance4!=null){// Commit the work prepared earlier.
var newProps=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps
// as the newProps. The updatePayload will contain the real change in
// this case.
var oldProps=current!==null?current.memoizedProps:newProps;var type=finishedWork.type;// TODO: Type the updateQueue to be specific to host components.
var updatePayload=finishedWork.updateQueue;finishedWork.updateQueue=null;if(updatePayload!==null){try{commitUpdate(_instance4,updatePayload,type,oldProps,newProps,finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}}}return;}case HostText:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){{if(finishedWork.stateNode===null){throw new Error('This should have a text node initialized. This error is likely '+'caused by a bug in React. Please file an issue.');}var textInstance=finishedWork.stateNode;var newText=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps
// as the newProps. The updatePayload will contain the real change in
// this case.
var oldText=current!==null?current.memoizedProps:newText;try{commitTextUpdate(textInstance,oldText,newText);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}return;}case HostRoot:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){{if(current!==null){var prevRootState=current.memoizedState;if(prevRootState.isDehydrated){try{commitHydratedContainer(root.containerInfo);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}}}return;}case HostPortal:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);return;}case SuspenseComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);var offscreenFiber=finishedWork.child;if(offscreenFiber.flags&Visibility){var offscreenInstance=offscreenFiber.stateNode;var newState=offscreenFiber.memoizedState;var isHidden=newState!==null;// Track the current state on the Offscreen instance so we can
// read it during an event
offscreenInstance.isHidden=isHidden;if(isHidden){var wasHidden=offscreenFiber.alternate!==null&&offscreenFiber.alternate.memoizedState!==null;if(!wasHidden){// TODO: Move to passive phase
markCommitTimeOfFallback();}}}if(flags&Update){try{commitSuspenseCallback(finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}attachSuspenseRetryListeners(finishedWork);}return;}case OffscreenComponent:{var _wasHidden=current!==null&&current.memoizedState!==null;if(// TODO: Remove this dead flag
finishedWork.mode&ConcurrentMode){// Before committing the children, track on the stack whether this
// offscreen subtree was already hidden, so that we don't unmount the
// effects again.
var prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden||_wasHidden;recursivelyTraverseMutationEffects(root,finishedWork);offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;}else {recursivelyTraverseMutationEffects(root,finishedWork);}commitReconciliationEffects(finishedWork);if(flags&Visibility){var _offscreenInstance=finishedWork.stateNode;var _newState=finishedWork.memoizedState;var _isHidden=_newState!==null;var offscreenBoundary=finishedWork;// Track the current state on the Offscreen instance so we can
// read it during an event
_offscreenInstance.isHidden=_isHidden;{if(_isHidden){if(!_wasHidden){if((offscreenBoundary.mode&ConcurrentMode)!==NoMode){nextEffect=offscreenBoundary;var offscreenChild=offscreenBoundary.child;while(offscreenChild!==null){nextEffect=offscreenChild;disappearLayoutEffects_begin(offscreenChild);offscreenChild=offscreenChild.sibling;}}}}}{// TODO: This needs to run whenever there's an insertion or update
// inside a hidden Offscreen tree.
hideOrUnhideAllChildren(offscreenBoundary,_isHidden);}}return;}case SuspenseListComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){attachSuspenseRetryListeners(finishedWork);}return;}case ScopeComponent:{return;}default:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);return;}}}function commitReconciliationEffects(finishedWork){// Placement effects (insertions, reorders) can be scheduled on any fiber
// type. They needs to happen after the children effects have fired, but
// before the effects on this fiber have fired.
var flags=finishedWork.flags;if(flags&Placement){try{commitPlacement(finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}// Clear the "placement" from effect tag so that we know that this is
// inserted, before any life-cycles like componentDidMount gets called.
// TODO: findDOMNode doesn't rely on this any more but isMounted does
// and isMounted is deprecated anyway so we should be able to kill this.
finishedWork.flags&=~Placement;}if(flags&Hydrating){finishedWork.flags&=~Hydrating;}}function commitLayoutEffects(finishedWork,root,committedLanes){inProgressLanes=committedLanes;inProgressRoot=root;nextEffect=finishedWork;commitLayoutEffects_begin(finishedWork,root,committedLanes);inProgressLanes=null;inProgressRoot=null;}function commitLayoutEffects_begin(subtreeRoot,root,committedLanes){// Suspense layout effects semantics don't change for legacy roots.
var isModernRoot=(subtreeRoot.mode&ConcurrentMode)!==NoMode;while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if(fiber.tag===OffscreenComponent&&isModernRoot){// Keep track of the current Offscreen stack's state.
var isHidden=fiber.memoizedState!==null;var newOffscreenSubtreeIsHidden=isHidden||offscreenSubtreeIsHidden;if(newOffscreenSubtreeIsHidden){// The Offscreen tree is hidden. Skip over its layout effects.
commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);continue;}else {// TODO (Offscreen) Also check: subtreeFlags & LayoutMask
var current=fiber.alternate;var wasHidden=current!==null&&current.memoizedState!==null;var newOffscreenSubtreeWasHidden=wasHidden||offscreenSubtreeWasHidden;var prevOffscreenSubtreeIsHidden=offscreenSubtreeIsHidden;var prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;// Traverse the Offscreen subtree with the current Offscreen as the root.
offscreenSubtreeIsHidden=newOffscreenSubtreeIsHidden;offscreenSubtreeWasHidden=newOffscreenSubtreeWasHidden;if(offscreenSubtreeWasHidden&&!prevOffscreenSubtreeWasHidden){// This is the root of a reappearing boundary. Turn its layout effects
// back on.
nextEffect=fiber;reappearLayoutEffects_begin(fiber);}var child=firstChild;while(child!==null){nextEffect=child;commitLayoutEffects_begin(child,// New root; bubble back up to here and stop.
root,committedLanes);child=child.sibling;}// Restore Offscreen state and resume in our-progress traversal.
nextEffect=fiber;offscreenSubtreeIsHidden=prevOffscreenSubtreeIsHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);continue;}}if((fiber.subtreeFlags&LayoutMask)!==NoFlags&&firstChild!==null){firstChild.return=fiber;nextEffect=firstChild;}else {commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);}}}function commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&LayoutMask)!==NoFlags){var current=fiber.alternate;setCurrentFiber(fiber);try{commitLayoutEffectOnFiber(root,current,fiber,committedLanes);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}resetCurrentFiber();}if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function disappearLayoutEffects_begin(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;// TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)
switch(fiber.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{if(fiber.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListUnmount(Layout,fiber,fiber.return);}finally{recordLayoutEffectDuration(fiber);}}else {commitHookEffectListUnmount(Layout,fiber,fiber.return);}break;}case ClassComponent:{// TODO (Offscreen) Check: flags & RefStatic
safelyDetachRef(fiber,fiber.return);var instance=fiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(fiber,fiber.return,instance);}break;}case HostComponent:{safelyDetachRef(fiber,fiber.return);break;}case OffscreenComponent:{// Check if this is a
var isHidden=fiber.memoizedState!==null;if(isHidden){// Nested Offscreen tree is already hidden. Don't disappear
// its effects.
disappearLayoutEffects_complete(subtreeRoot);continue;}break;}}// TODO (Offscreen) Check: subtreeFlags & LayoutStatic
if(firstChild!==null){firstChild.return=fiber;nextEffect=firstChild;}else {disappearLayoutEffects_complete(subtreeRoot);}}}function disappearLayoutEffects_complete(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function reappearLayoutEffects_begin(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if(fiber.tag===OffscreenComponent){var isHidden=fiber.memoizedState!==null;if(isHidden){// Nested Offscreen tree is still hidden. Don't re-appear its effects.
reappearLayoutEffects_complete(subtreeRoot);continue;}}// TODO (Offscreen) Check: subtreeFlags & LayoutStatic
if(firstChild!==null){// This node may have been reused from a previous render, so we can't
// assume its return pointer is correct.
firstChild.return=fiber;nextEffect=firstChild;}else {reappearLayoutEffects_complete(subtreeRoot);}}}function reappearLayoutEffects_complete(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;// TODO (Offscreen) Check: flags & LayoutStatic
setCurrentFiber(fiber);try{reappearLayoutEffectsOnFiber(fiber);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}resetCurrentFiber();if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){// This node may have been reused from a previous render, so we can't
// assume its return pointer is correct.
sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function commitPassiveMountEffects(root,finishedWork,committedLanes,committedTransitions){nextEffect=finishedWork;commitPassiveMountEffects_begin(finishedWork,root,committedLanes,committedTransitions);}function commitPassiveMountEffects_begin(subtreeRoot,root,committedLanes,committedTransitions){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if((fiber.subtreeFlags&PassiveMask)!==NoFlags&&firstChild!==null){firstChild.return=fiber;nextEffect=firstChild;}else {commitPassiveMountEffects_complete(subtreeRoot,root,committedLanes,committedTransitions);}}}function commitPassiveMountEffects_complete(subtreeRoot,root,committedLanes,committedTransitions){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&Passive)!==NoFlags){setCurrentFiber(fiber);try{commitPassiveMountOnFiber(root,fiber,committedLanes,committedTransitions);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}resetCurrentFiber();}if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function commitPassiveMountOnFiber(finishedRoot,finishedWork,committedLanes,committedTransitions){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(finishedWork.mode&ProfileMode){startPassiveEffectTimer();try{commitHookEffectListMount(Passive$1|HasEffect,finishedWork);}finally{recordPassiveEffectDuration(finishedWork);}}else {commitHookEffectListMount(Passive$1|HasEffect,finishedWork);}break;}}}function commitPassiveUnmountEffects(firstChild){nextEffect=firstChild;commitPassiveUnmountEffects_begin();}function commitPassiveUnmountEffects_begin(){while(nextEffect!==null){var fiber=nextEffect;var child=fiber.child;if((nextEffect.flags&ChildDeletion)!==NoFlags){var deletions=fiber.deletions;if(deletions!==null){for(var i=0;i<deletions.length;i++){var fiberToDelete=deletions[i];nextEffect=fiberToDelete;commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete,fiber);}{// A fiber was deleted from this parent fiber, but it's still part of
// the previous (alternate) parent fiber's list of children. Because
// children are a linked list, an earlier sibling that's still alive
// will be connected to the deleted fiber via its `alternate`:
//
//   live fiber
//   --alternate--> previous live fiber
//   --sibling--> deleted fiber
//
// We can't disconnect `alternate` on nodes that haven't been deleted
// yet, but we can disconnect the `sibling` and `child` pointers.
var previousFiber=fiber.alternate;if(previousFiber!==null){var detachedChild=previousFiber.child;if(detachedChild!==null){previousFiber.child=null;do{var detachedSibling=detachedChild.sibling;detachedChild.sibling=null;detachedChild=detachedSibling;}while(detachedChild!==null);}}}nextEffect=fiber;}}if((fiber.subtreeFlags&PassiveMask)!==NoFlags&&child!==null){child.return=fiber;nextEffect=child;}else {commitPassiveUnmountEffects_complete();}}}function commitPassiveUnmountEffects_complete(){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&Passive)!==NoFlags){setCurrentFiber(fiber);commitPassiveUnmountOnFiber(fiber);resetCurrentFiber();}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function commitPassiveUnmountOnFiber(finishedWork){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(finishedWork.mode&ProfileMode){startPassiveEffectTimer();commitHookEffectListUnmount(Passive$1|HasEffect,finishedWork,finishedWork.return);recordPassiveEffectDuration(finishedWork);}else {commitHookEffectListUnmount(Passive$1|HasEffect,finishedWork,finishedWork.return);}break;}}}function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot,nearestMountedAncestor){while(nextEffect!==null){var fiber=nextEffect;// Deletion effects fire in parent -> child order
// TODO: Check if fiber has a PassiveStatic flag
setCurrentFiber(fiber);commitPassiveUnmountInsideDeletedTreeOnFiber(fiber,nearestMountedAncestor);resetCurrentFiber();var child=fiber.child;// TODO: Only traverse subtree if it has a PassiveStatic flag. (But, if we
// do this, still need to handle `deletedTreeCleanUpLevel` correctly.)
if(child!==null){child.return=fiber;nextEffect=child;}else {commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);}}}function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var sibling=fiber.sibling;var returnFiber=fiber.return;{// Recursively traverse the entire deleted tree and clean up fiber fields.
// This is more aggressive than ideal, and the long term goal is to only
// have to detach the deleted tree at the root.
detachFiberAfterEffects(fiber);if(fiber===deletedSubtreeRoot){nextEffect=null;return;}}if(sibling!==null){sibling.return=returnFiber;nextEffect=sibling;return;}nextEffect=returnFiber;}}function commitPassiveUnmountInsideDeletedTreeOnFiber(current,nearestMountedAncestor){switch(current.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(current.mode&ProfileMode){startPassiveEffectTimer();commitHookEffectListUnmount(Passive$1,current,nearestMountedAncestor);recordPassiveEffectDuration(current);}else {commitHookEffectListUnmount(Passive$1,current,nearestMountedAncestor);}break;}}}// TODO: Reuse reappearLayoutEffects traversal here?
function invokeLayoutEffectMountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.
// This function is only called if that check has already passed.
switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListMount(Layout|HasEffect,fiber);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}break;}case ClassComponent:{var instance=fiber.stateNode;try{instance.componentDidMount();}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}break;}}}}function invokePassiveEffectMountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.
// This function is only called if that check has already passed.
switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListMount(Passive$1|HasEffect,fiber);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}break;}}}}function invokeLayoutEffectUnmountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.
// This function is only called if that check has already passed.
switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListUnmount(Layout|HasEffect,fiber,fiber.return);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}break;}case ClassComponent:{var instance=fiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(fiber,fiber.return,instance);}break;}}}}function invokePassiveEffectUnmountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.
// This function is only called if that check has already passed.
switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListUnmount(Passive$1|HasEffect,fiber,fiber.return);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}}}}}if(typeof Symbol==='function'&&Symbol.for){var symbolFor=Symbol.for;symbolFor('selector.component');symbolFor('selector.has_pseudo_class');symbolFor('selector.role');symbolFor('selector.test_id');symbolFor('selector.text');}var commitHooks=[];function onCommitRoot$1(){{commitHooks.forEach(function(commitHook){return commitHook();});}}var ReactCurrentActQueue=ReactSharedInternals.ReactCurrentActQueue;function isLegacyActEnvironment(fiber){{// Legacy mode. We preserve the behavior of React 17's act. It assumes an
// act environment whenever `jest` is defined, but you can still turn off
// spurious warnings by setting IS_REACT_ACT_ENVIRONMENT explicitly
// to false.
var isReactActEnvironmentGlobal=// $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
typeof IS_REACT_ACT_ENVIRONMENT!=='undefined'?IS_REACT_ACT_ENVIRONMENT:undefined;// $FlowExpectedError - Flow doesn't know about jest
var jestIsDefined=typeof jest!=='undefined';return jestIsDefined&&isReactActEnvironmentGlobal!==false;}}function isConcurrentActEnvironment(){{var isReactActEnvironmentGlobal=// $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
typeof IS_REACT_ACT_ENVIRONMENT!=='undefined'?IS_REACT_ACT_ENVIRONMENT:undefined;if(!isReactActEnvironmentGlobal&&ReactCurrentActQueue.current!==null){// TODO: Include link to relevant documentation page.
error('The current testing environment is not configured to support '+'act(...)');}return isReactActEnvironmentGlobal;}}var ceil=Math.ceil;var ReactCurrentDispatcher$2=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentOwner$2=ReactSharedInternals.ReactCurrentOwner,ReactCurrentBatchConfig$3=ReactSharedInternals.ReactCurrentBatchConfig,ReactCurrentActQueue$1=ReactSharedInternals.ReactCurrentActQueue;var NoContext=/*             */0;var BatchedContext=/*               */1;var RenderContext=/*                */2;var CommitContext=/*                */4;var RootInProgress=0;var RootFatalErrored=1;var RootErrored=2;var RootSuspended=3;var RootSuspendedWithDelay=4;var RootCompleted=5;var RootDidNotComplete=6;// Describes where we are in the React execution stack
var executionContext=NoContext;// The root we're working on
var workInProgressRoot=null;// The fiber we're working on
var workInProgress=null;// The lanes we're rendering
var workInProgressRootRenderLanes=NoLanes;// Stack that allows components to change the render lanes for its subtree
// This is a superset of the lanes we started working on at the root. The only
// case where it's different from `workInProgressRootRenderLanes` is when we
// enter a subtree that is hidden and needs to be unhidden: Suspense and
// Offscreen component.
//
// Most things in the work loop should deal with workInProgressRootRenderLanes.
// Most things in begin/complete phases should deal with subtreeRenderLanes.
var subtreeRenderLanes=NoLanes;var subtreeRenderLanesCursor=createCursor(NoLanes);// Whether to root completed, errored, suspended, etc.
var workInProgressRootExitStatus=RootInProgress;// A fatal error, if one is thrown
var workInProgressRootFatalError=null;// "Included" lanes refer to lanes that were worked on during this render. It's
// includes unprocessed updates, not work in bailed out children.
var workInProgressRootSkippedLanes=NoLanes;// Lanes that were updated (in an interleaved event) during this render.
var workInProgressRootInterleavedUpdatedLanes=NoLanes;// Lanes that were updated during the render phase (*not* an interleaved event).
var workInProgressRootPingedLanes=NoLanes;// Errors that are thrown during the render phase.
var workInProgressRootConcurrentErrors=null;// These are errors that we recovered from without surfacing them to the UI.
// We will log them once the tree commits.
var workInProgressRootRecoverableErrors=null;// The most recent time we committed a fallback. This lets us ensure a train
// model where we don't commit new loading states in too quick succession.
var globalMostRecentFallbackTime=0;var FALLBACK_THROTTLE_MS=500;// The absolute time for when we should start giving up on rendering
// more and prefer CPU suspense heuristics instead.
var workInProgressRootRenderTargetTime=Infinity;// How long a render is supposed to take before we start following CPU
// suspense heuristics and opt out of rendering more content.
var RENDER_TIMEOUT_MS=500;var workInProgressTransitions=null;function resetRenderTimer(){workInProgressRootRenderTargetTime=now()+RENDER_TIMEOUT_MS;}function getRenderTargetTime(){return workInProgressRootRenderTargetTime;}var hasUncaughtError=false;var firstUncaughtError=null;var legacyErrorBoundariesThatAlreadyFailed=null;// Only used when enableProfilerNestedUpdateScheduledHook is true;
var rootDoesHavePassiveEffects=false;var rootWithPendingPassiveEffects=null;var pendingPassiveEffectsLanes=NoLanes;var pendingPassiveProfilerEffects=[];var pendingPassiveTransitions=null;// Use these to prevent an infinite loop of nested updates
var NESTED_UPDATE_LIMIT=50;var nestedUpdateCount=0;var rootWithNestedUpdates=null;var isFlushingPassiveEffects=false;var didScheduleUpdateDuringPassiveEffects=false;var NESTED_PASSIVE_UPDATE_LIMIT=50;var nestedPassiveUpdateCount=0;var rootWithPassiveNestedUpdates=null;// If two updates are scheduled within the same event, we should treat their
// event times as simultaneous, even if the actual clock time has advanced
// between the first and second call.
var currentEventTime=NoTimestamp;var currentEventTransitionLane=NoLanes;var isRunningInsertionEffect=false;function getWorkInProgressRoot(){return workInProgressRoot;}function requestEventTime(){if((executionContext&(RenderContext|CommitContext))!==NoContext){// We're inside React, so it's fine to read the actual time.
return now();}// We're not inside React, so we may be in the middle of a browser event.
if(currentEventTime!==NoTimestamp){// Use the same start time for all updates until we enter React again.
return currentEventTime;}// This is the first update since React yielded. Compute a new start time.
currentEventTime=now();return currentEventTime;}function requestUpdateLane(fiber){// Special cases
var mode=fiber.mode;if((mode&ConcurrentMode)===NoMode){return SyncLane;}else if((executionContext&RenderContext)!==NoContext&&workInProgressRootRenderLanes!==NoLanes){// This is a render phase update. These are not officially supported. The
// old behavior is to give this the same "thread" (lanes) as
// whatever is currently rendering. So if you call `setState` on a component
// that happens later in the same render, it will flush. Ideally, we want to
// remove the special case and treat them as if they came from an
// interleaved event. Regardless, this pattern is not officially supported.
// This behavior is only a fallback. The flag only exists until we can roll
// out the setState warning, since existing code might accidentally rely on
// the current behavior.
return pickArbitraryLane(workInProgressRootRenderLanes);}var isTransition=requestCurrentTransition()!==NoTransition;if(isTransition){if(ReactCurrentBatchConfig$3.transition!==null){var transition=ReactCurrentBatchConfig$3.transition;if(!transition._updatedFibers){transition._updatedFibers=new Set();}transition._updatedFibers.add(fiber);}// The algorithm for assigning an update to a lane should be stable for all
// updates at the same priority within the same event. To do this, the
// inputs to the algorithm must be the same.
//
// The trick we use is to cache the first of each of these inputs within an
// event. Then reset the cached values once we can be sure the event is
// over. Our heuristic for that is whenever we enter a concurrent work loop.
if(currentEventTransitionLane===NoLane){// All transitions within the same event are assigned the same lane.
currentEventTransitionLane=claimNextTransitionLane();}return currentEventTransitionLane;}// Updates originating inside certain React methods, like flushSync, have
// their priority set by tracking it with a context variable.
//
// The opaque type returned by the host config is internally a lane, so we can
// use that directly.
// TODO: Move this type conversion to the event priority module.
var updateLane=getCurrentUpdatePriority();if(updateLane!==NoLane){return updateLane;}// This update originated outside React. Ask the host environment for an
// appropriate priority, based on the type of event.
//
// The opaque type returned by the host config is internally a lane, so we can
// use that directly.
// TODO: Move this type conversion to the event priority module.
var eventLane=getCurrentEventPriority();return eventLane;}function requestRetryLane(fiber){// This is a fork of `requestUpdateLane` designed specifically for Suspense
// "retries" — a special update that attempts to flip a Suspense boundary
// from its placeholder state to its primary/resolved state.
// Special cases
var mode=fiber.mode;if((mode&ConcurrentMode)===NoMode){return SyncLane;}return claimNextRetryLane();}function scheduleUpdateOnFiber(root,fiber,lane,eventTime){checkForNestedUpdates();{if(isRunningInsertionEffect){error('useInsertionEffect must not schedule updates.');}}{if(isFlushingPassiveEffects){didScheduleUpdateDuringPassiveEffects=true;}}// Mark that the root has a pending update.
markRootUpdated(root,lane,eventTime);if((executionContext&RenderContext)!==NoLanes&&root===workInProgressRoot){// This update was dispatched during the render phase. This is a mistake
// if the update originates from user space (with the exception of local
// hook updates, which are handled differently and don't reach this
// function), but there are some internal React features that use this as
// an implementation detail, like selective hydration.
warnAboutRenderPhaseUpdatesInDEV(fiber);// Track lanes that were updated during the render phase
}else {// This is a normal update, scheduled from outside the render phase. For
// example, during an input event.
{if(isDevToolsPresent){addFiberToLanesMap(root,fiber,lane);}}warnIfUpdatesNotWrappedWithActDEV(fiber);if(root===workInProgressRoot){// Received an update to a tree that's in the middle of rendering. Mark
// that there was an interleaved update work on this root. Unless the
// `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render
// phase update. In that case, we don't treat render phase updates as if
// they were interleaved, for backwards compat reasons.
if((executionContext&RenderContext)===NoContext){workInProgressRootInterleavedUpdatedLanes=mergeLanes(workInProgressRootInterleavedUpdatedLanes,lane);}if(workInProgressRootExitStatus===RootSuspendedWithDelay){// The root already suspended with a delay, which means this render
// definitely won't finish. Since we have a new update, let's mark it as
// suspended now, right before marking the incoming update. This has the
// effect of interrupting the current render and switching to the update.
// TODO: Make sure this doesn't override pings that happen while we've
// already started rendering.
markRootSuspended$1(root,workInProgressRootRenderLanes);}}ensureRootIsScheduled(root,eventTime);if(lane===SyncLane&&executionContext===NoContext&&(fiber.mode&ConcurrentMode)===NoMode&&// Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
!ReactCurrentActQueue$1.isBatchingLegacy){// Flush the synchronous work now, unless we're already working or inside
// a batch. This is intentionally inside scheduleUpdateOnFiber instead of
// scheduleCallbackForFiber to preserve the ability to schedule a callback
// without immediately flushing it. We only do this for user-initiated
// updates, to preserve historical behavior of legacy mode.
resetRenderTimer();flushSyncCallbacksOnlyInLegacyMode();}}}function scheduleInitialHydrationOnRoot(root,lane,eventTime){// This is a special fork of scheduleUpdateOnFiber that is only used to
// schedule the initial hydration of a root that has just been created. Most
// of the stuff in scheduleUpdateOnFiber can be skipped.
//
// The main reason for this separate path, though, is to distinguish the
// initial children from subsequent updates. In fully client-rendered roots
// (createRoot instead of hydrateRoot), all top-level renders are modeled as
// updates, but hydration roots are special because the initial render must
// match what was rendered on the server.
var current=root.current;current.lanes=lane;markRootUpdated(root,lane,eventTime);ensureRootIsScheduled(root,eventTime);}function isUnsafeClassRenderPhaseUpdate(fiber){// Check if this is a render phase update. Only called by class components,
// which special (deprecated) behavior for UNSAFE_componentWillReceive props.
return(// TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
// decided not to enable it.
(executionContext&RenderContext)!==NoContext);}// Use this function to schedule a task for a root. There's only one task per
// root; if a task was already scheduled, we'll check to make sure the priority
// of the existing task is the same as the priority of the next level that the
// root has work on. This function is called on every update, and right before
// exiting a task.
function ensureRootIsScheduled(root,currentTime){var existingCallbackNode=root.callbackNode;// Check if any lanes are being starved by other work. If so, mark them as
// expired so we know to work on those next.
markStarvedLanesAsExpired(root,currentTime);// Determine the next lanes to work on, and their priority.
var nextLanes=getNextLanes(root,root===workInProgressRoot?workInProgressRootRenderLanes:NoLanes);if(nextLanes===NoLanes){// Special case: There's nothing to work on.
if(existingCallbackNode!==null){cancelCallback$1(existingCallbackNode);}root.callbackNode=null;root.callbackPriority=NoLane;return;}// We use the highest priority lane to represent the priority of the callback.
var newCallbackPriority=getHighestPriorityLane(nextLanes);// Check if there's an existing task. We may be able to reuse it.
var existingCallbackPriority=root.callbackPriority;if(existingCallbackPriority===newCallbackPriority&&// Special case related to `act`. If the currently scheduled task is a
// Scheduler task, rather than an `act` task, cancel it and re-scheduled
// on the `act` queue.
!(ReactCurrentActQueue$1.current!==null&&existingCallbackNode!==fakeActCallbackNode)){{// If we're going to re-use an existing task, it needs to exist.
// Assume that discrete update microtasks are non-cancellable and null.
// TODO: Temporary until we confirm this warning is not fired.
if(existingCallbackNode==null&&existingCallbackPriority!==SyncLane){error('Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.');}}// The priority hasn't changed. We can reuse the existing task. Exit.
return;}if(existingCallbackNode!=null){// Cancel the existing callback. We'll schedule a new one below.
cancelCallback$1(existingCallbackNode);}// Schedule a new callback.
var newCallbackNode;if(newCallbackPriority===SyncLane){// Special case: Sync React callbacks are scheduled on a special
// internal queue
if(root.tag===LegacyRoot){if(ReactCurrentActQueue$1.isBatchingLegacy!==null){ReactCurrentActQueue$1.didScheduleLegacyUpdate=true;}scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null,root));}else {scheduleSyncCallback(performSyncWorkOnRoot.bind(null,root));}{// Flush the queue in a microtask.
if(ReactCurrentActQueue$1.current!==null){// Inside `act`, use our internal `act` queue so that these get flushed
// at the end of the current scope even when using the sync version
// of `act`.
ReactCurrentActQueue$1.current.push(flushSyncCallbacks);}else {scheduleMicrotask(function(){// In Safari, appending an iframe forces microtasks to run.
// https://github.com/facebook/react/issues/22459
// We don't support running callbacks in the middle of render
// or commit so we need to check against that.
if((executionContext&(RenderContext|CommitContext))===NoContext){// Note that this would still prematurely flush the callbacks
// if this happens outside render or commit phase (e.g. in an event).
flushSyncCallbacks();}});}}newCallbackNode=null;}else {var schedulerPriorityLevel;switch(lanesToEventPriority(nextLanes)){case DiscreteEventPriority:schedulerPriorityLevel=ImmediatePriority;break;case ContinuousEventPriority:schedulerPriorityLevel=UserBlockingPriority;break;case DefaultEventPriority:schedulerPriorityLevel=NormalPriority;break;case IdleEventPriority:schedulerPriorityLevel=IdlePriority;break;default:schedulerPriorityLevel=NormalPriority;break;}newCallbackNode=scheduleCallback$1(schedulerPriorityLevel,performConcurrentWorkOnRoot.bind(null,root));}root.callbackPriority=newCallbackPriority;root.callbackNode=newCallbackNode;}// This is the entry point for every concurrent task, i.e. anything that
// goes through Scheduler.
function performConcurrentWorkOnRoot(root,didTimeout){{resetNestedUpdateFlag();}// Since we know we're in a React event, we can clear the current
// event time. The next update will compute a new event time.
currentEventTime=NoTimestamp;currentEventTransitionLane=NoLanes;if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}// Flush any pending passive effects before deciding which lanes to work on,
// in case they schedule additional work.
var originalCallbackNode=root.callbackNode;var didFlushPassiveEffects=flushPassiveEffects();if(didFlushPassiveEffects){// Something in the passive effect phase may have canceled the current task.
// Check if the task node for this root was changed.
if(root.callbackNode!==originalCallbackNode){// The current task was canceled. Exit. We don't need to call
// `ensureRootIsScheduled` because the check above implies either that
// there's a new task, or that there's no remaining work on this root.
return null;}}// Determine the next lanes to work on, using the fields stored
// on the root.
var lanes=getNextLanes(root,root===workInProgressRoot?workInProgressRootRenderLanes:NoLanes);if(lanes===NoLanes){// Defensive coding. This is never expected to happen.
return null;}// We disable time-slicing in some cases: if the work has been CPU-bound
// for too long ("expired" work, to prevent starvation), or we're in
// sync-updates-by-default mode.
// TODO: We only check `didTimeout` defensively, to account for a Scheduler
// bug we're still investigating. Once the bug in Scheduler is fixed,
// we can remove this, since we track expiration ourselves.
var shouldTimeSlice=!includesBlockingLane(root,lanes)&&!includesExpiredLane(root,lanes)&&!didTimeout;var exitStatus=shouldTimeSlice?renderRootConcurrent(root,lanes):renderRootSync(root,lanes);if(exitStatus!==RootInProgress){if(exitStatus===RootErrored){// If something threw an error, try rendering one more time. We'll
// render synchronously to block concurrent data mutations, and we'll
// includes all pending updates are included. If it still fails after
// the second attempt, we'll give up and commit the resulting tree.
var errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(errorRetryLanes!==NoLanes){lanes=errorRetryLanes;exitStatus=recoverFromConcurrentError(root,errorRetryLanes);}}if(exitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw fatalError;}if(exitStatus===RootDidNotComplete){// The render unwound without completing the tree. This happens in special
// cases where need to exit the current render without producing a
// consistent tree or committing.
//
// This should only happen during a concurrent render, not a discrete or
// synchronous update. We should have already checked for this when we
// unwound the stack.
markRootSuspended$1(root,lanes);}else {// The render completed.
// Check if this render may have yielded to a concurrent event, and if so,
// confirm that any newly rendered stores are consistent.
// TODO: It's possible that even a concurrent render may never have yielded
// to the main thread, if it was fast enough, or if it expired. We could
// skip the consistency check in that case, too.
var renderWasConcurrent=!includesBlockingLane(root,lanes);var finishedWork=root.current.alternate;if(renderWasConcurrent&&!isRenderConsistentWithExternalStores(finishedWork)){// A store was mutated in an interleaved event. Render again,
// synchronously, to block further mutations.
exitStatus=renderRootSync(root,lanes);// We need to check again if something threw
if(exitStatus===RootErrored){var _errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(_errorRetryLanes!==NoLanes){lanes=_errorRetryLanes;exitStatus=recoverFromConcurrentError(root,_errorRetryLanes);// We assume the tree is now consistent because we didn't yield to any
// concurrent events.
}}if(exitStatus===RootFatalErrored){var _fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw _fatalError;}}// We now have a consistent tree. The next step is either to commit it,
// or, if something suspended, wait to commit it after a timeout.
root.finishedWork=finishedWork;root.finishedLanes=lanes;finishConcurrentRender(root,exitStatus,lanes);}}ensureRootIsScheduled(root,now());if(root.callbackNode===originalCallbackNode){// The task node scheduled for this root is the same one that's
// currently executed. Need to return a continuation.
return performConcurrentWorkOnRoot.bind(null,root);}return null;}function recoverFromConcurrentError(root,errorRetryLanes){// If an error occurred during hydration, discard server response and fall
// back to client side render.
// Before rendering again, save the errors from the previous attempt.
var errorsFromFirstAttempt=workInProgressRootConcurrentErrors;if(isRootDehydrated(root)){// The shell failed to hydrate. Set a flag to force a client rendering
// during the next attempt. To do this, we call prepareFreshStack now
// to create the root work-in-progress fiber. This is a bit weird in terms
// of factoring, because it relies on renderRootSync not calling
// prepareFreshStack again in the call below, which happens because the
// root and lanes haven't changed.
//
// TODO: I think what we should do is set ForceClientRender inside
// throwException, like we do for nested Suspense boundaries. The reason
// it's here instead is so we can switch to the synchronous work loop, too.
// Something to consider for a future refactor.
var rootWorkInProgress=prepareFreshStack(root,errorRetryLanes);rootWorkInProgress.flags|=ForceClientRender;{errorHydratingContainer(root.containerInfo);}}var exitStatus=renderRootSync(root,errorRetryLanes);if(exitStatus!==RootErrored){// Successfully finished rendering on retry
// The errors from the failed first attempt have been recovered. Add
// them to the collection of recoverable errors. We'll log them in the
// commit phase.
var errorsFromSecondAttempt=workInProgressRootRecoverableErrors;workInProgressRootRecoverableErrors=errorsFromFirstAttempt;// The errors from the second attempt should be queued after the errors
// from the first attempt, to preserve the causal sequence.
if(errorsFromSecondAttempt!==null){queueRecoverableErrors(errorsFromSecondAttempt);}}return exitStatus;}function queueRecoverableErrors(errors){if(workInProgressRootRecoverableErrors===null){workInProgressRootRecoverableErrors=errors;}else {workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors,errors);}}function finishConcurrentRender(root,exitStatus,lanes){switch(exitStatus){case RootInProgress:case RootFatalErrored:{throw new Error('Root did not complete. This is a bug in React.');}// Flow knows about invariant, so it complains if I add a break
// statement, but eslint doesn't know about invariant, so it complains
// if I do. eslint-disable-next-line no-fallthrough
case RootErrored:{// We should have already attempted to retry this tree. If we reached
// this point, it errored again. Commit it.
commitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}case RootSuspended:{markRootSuspended$1(root,lanes);// We have an acceptable loading state. We need to figure out if we
// should immediately commit it or wait a bit.
if(includesOnlyRetries(lanes)&&// do not delay if we're inside an act() scope
!shouldForceFlushFallbacksInDEV()){// This render only included retries, no updates. Throttle committing
// retries so that we don't show too many loading states too quickly.
var msUntilTimeout=globalMostRecentFallbackTime+FALLBACK_THROTTLE_MS-now();// Don't bother with a very short suspense time.
if(msUntilTimeout>10){var nextLanes=getNextLanes(root,NoLanes);if(nextLanes!==NoLanes){// There's additional work on this root.
break;}var suspendedLanes=root.suspendedLanes;if(!isSubsetOfLanes(suspendedLanes,lanes)){// We should prefer to render the fallback of at the last
// suspended level. Ping the last suspended level to try
// rendering it again.
// FIXME: What if the suspended lanes are Idle? Should not restart.
requestEventTime();markRootPinged(root,suspendedLanes);break;}// The render is suspended, it hasn't timed out, and there's no
// lower priority work to do. Instead of committing the fallback
// immediately, wait for more data to arrive.
root.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root,workInProgressRootRecoverableErrors,workInProgressTransitions),msUntilTimeout);break;}}// The work expired. Commit immediately.
commitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}case RootSuspendedWithDelay:{markRootSuspended$1(root,lanes);if(includesOnlyTransitions(lanes)){// This is a transition, so we should exit without committing a
// placeholder and without scheduling a timeout. Delay indefinitely
// until we receive more data.
break;}if(!shouldForceFlushFallbacksInDEV()){// This is not a transition, but we did trigger an avoided state.
// Schedule a placeholder to display after a short delay, using the Just
// Noticeable Difference.
// TODO: Is the JND optimization worth the added complexity? If this is
// the only reason we track the event time, then probably not.
// Consider removing.
var mostRecentEventTime=getMostRecentEventTime(root,lanes);var eventTimeMs=mostRecentEventTime;var timeElapsedMs=now()-eventTimeMs;var _msUntilTimeout=jnd(timeElapsedMs)-timeElapsedMs;// Don't bother with a very short suspense time.
if(_msUntilTimeout>10){// Instead of committing the fallback immediately, wait for more data
// to arrive.
root.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root,workInProgressRootRecoverableErrors,workInProgressTransitions),_msUntilTimeout);break;}}// Commit the placeholder.
commitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}case RootCompleted:{// The work completed. Ready to commit.
commitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}default:{throw new Error('Unknown root exit status.');}}}function isRenderConsistentWithExternalStores(finishedWork){// Search the rendered tree for external store reads, and check whether the
// stores were mutated in a concurrent event. Intentionally using an iterative
// loop instead of recursion so we can exit early.
var node=finishedWork;while(true){if(node.flags&StoreConsistency){var updateQueue=node.updateQueue;if(updateQueue!==null){var checks=updateQueue.stores;if(checks!==null){for(var i=0;i<checks.length;i++){var check=checks[i];var getSnapshot=check.getSnapshot;var renderedValue=check.value;try{if(!objectIs(getSnapshot(),renderedValue)){// Found an inconsistent store.
return false;}}catch(error){// If `getSnapshot` throws, return `false`. This will schedule
// a re-render, and the error will be rethrown during render.
return false;}}}}}var child=node.child;if(node.subtreeFlags&StoreConsistency&&child!==null){child.return=node;node=child;continue;}if(node===finishedWork){return true;}while(node.sibling===null){if(node.return===null||node.return===finishedWork){return true;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}// Flow doesn't know this is unreachable, but eslint does
// eslint-disable-next-line no-unreachable
return true;}function markRootSuspended$1(root,suspendedLanes){// When suspending, we should always exclude lanes that were pinged or (more
// rarely, since we try to avoid it) updated during the render phase.
// TODO: Lol maybe there's a better way to factor this besides this
// obnoxiously named function :)
suspendedLanes=removeLanes(suspendedLanes,workInProgressRootPingedLanes);suspendedLanes=removeLanes(suspendedLanes,workInProgressRootInterleavedUpdatedLanes);markRootSuspended(root,suspendedLanes);}// This is the entry point for synchronous tasks that don't go
// through Scheduler
function performSyncWorkOnRoot(root){{syncNestedUpdateFlag();}if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}flushPassiveEffects();var lanes=getNextLanes(root,NoLanes);if(!includesSomeLane(lanes,SyncLane)){// There's no remaining sync work left.
ensureRootIsScheduled(root,now());return null;}var exitStatus=renderRootSync(root,lanes);if(root.tag!==LegacyRoot&&exitStatus===RootErrored){// If something threw an error, try rendering one more time. We'll render
// synchronously to block concurrent data mutations, and we'll includes
// all pending updates are included. If it still fails after the second
// attempt, we'll give up and commit the resulting tree.
var errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(errorRetryLanes!==NoLanes){lanes=errorRetryLanes;exitStatus=recoverFromConcurrentError(root,errorRetryLanes);}}if(exitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw fatalError;}if(exitStatus===RootDidNotComplete){throw new Error('Root did not complete. This is a bug in React.');}// We now have a consistent tree. Because this is a sync render, we
// will commit it even if something suspended.
var finishedWork=root.current.alternate;root.finishedWork=finishedWork;root.finishedLanes=lanes;commitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);// Before exiting, make sure there's a callback scheduled for the next
// pending level.
ensureRootIsScheduled(root,now());return null;}function flushRoot(root,lanes){if(lanes!==NoLanes){markRootEntangled(root,mergeLanes(lanes,SyncLane));ensureRootIsScheduled(root,now());if((executionContext&(RenderContext|CommitContext))===NoContext){resetRenderTimer();flushSyncCallbacks();}}}function batchedUpdates$1(fn,a){var prevExecutionContext=executionContext;executionContext|=BatchedContext;try{return fn(a);}finally{executionContext=prevExecutionContext;// If there were legacy sync updates, flush them at the end of the outer
// most batchedUpdates-like method.
if(executionContext===NoContext&&// Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
!ReactCurrentActQueue$1.isBatchingLegacy){resetRenderTimer();flushSyncCallbacksOnlyInLegacyMode();}}}function discreteUpdates(fn,a,b,c,d){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig$3.transition;try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);return fn(a,b,c,d);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;if(executionContext===NoContext){resetRenderTimer();}}}// Overload the definition to the two valid signatures.
// Warning, this opts-out of checking the function body.
// eslint-disable-next-line no-redeclare
function flushSync(fn){// In legacy mode, we flush pending passive effects at the beginning of the
// next event, not at the end of the previous one.
if(rootWithPendingPassiveEffects!==null&&rootWithPendingPassiveEffects.tag===LegacyRoot&&(executionContext&(RenderContext|CommitContext))===NoContext){flushPassiveEffects();}var prevExecutionContext=executionContext;executionContext|=BatchedContext;var prevTransition=ReactCurrentBatchConfig$3.transition;var previousPriority=getCurrentUpdatePriority();try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);if(fn){return fn();}else {return undefined;}}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;executionContext=prevExecutionContext;// Flush the immediate callbacks that were scheduled during this batch.
// Note that this will happen even if batchedUpdates is higher up
// the stack.
if((executionContext&(RenderContext|CommitContext))===NoContext){flushSyncCallbacks();}}}function isAlreadyRendering(){// Used by the renderer to print a warning if certain APIs are called from
// the wrong context.
return (executionContext&(RenderContext|CommitContext))!==NoContext;}function pushRenderLanes(fiber,lanes){push(subtreeRenderLanesCursor,subtreeRenderLanes,fiber);subtreeRenderLanes=mergeLanes(subtreeRenderLanes,lanes);}function popRenderLanes(fiber){subtreeRenderLanes=subtreeRenderLanesCursor.current;pop(subtreeRenderLanesCursor,fiber);}function prepareFreshStack(root,lanes){root.finishedWork=null;root.finishedLanes=NoLanes;var timeoutHandle=root.timeoutHandle;if(timeoutHandle!==noTimeout){// The root previous suspended and scheduled a timeout to commit a fallback
// state. Now that we have additional work, cancel the timeout.
root.timeoutHandle=noTimeout;// $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
cancelTimeout(timeoutHandle);}if(workInProgress!==null){var interruptedWork=workInProgress.return;while(interruptedWork!==null){var current=interruptedWork.alternate;unwindInterruptedWork(current,interruptedWork);interruptedWork=interruptedWork.return;}}workInProgressRoot=root;var rootWorkInProgress=createWorkInProgress(root.current,null);workInProgress=rootWorkInProgress;workInProgressRootRenderLanes=subtreeRenderLanes=lanes;workInProgressRootExitStatus=RootInProgress;workInProgressRootFatalError=null;workInProgressRootSkippedLanes=NoLanes;workInProgressRootInterleavedUpdatedLanes=NoLanes;workInProgressRootPingedLanes=NoLanes;workInProgressRootConcurrentErrors=null;workInProgressRootRecoverableErrors=null;finishQueueingConcurrentUpdates();{ReactStrictModeWarnings.discardPendingWarnings();}return rootWorkInProgress;}function handleError(root,thrownValue){do{var erroredWork=workInProgress;try{// Reset module-level state that was set during the render phase.
resetContextDependencies();resetHooksAfterThrow();resetCurrentFiber();// TODO: I found and added this missing line while investigating a
// separate issue. Write a regression test using string refs.
ReactCurrentOwner$2.current=null;if(erroredWork===null||erroredWork.return===null){// Expected to be working on a non-root fiber. This is a fatal error
// because there's no ancestor that can handle it; the root is
// supposed to capture all errors that weren't caught by an error
// boundary.
workInProgressRootExitStatus=RootFatalErrored;workInProgressRootFatalError=thrownValue;// Set `workInProgress` to null. This represents advancing to the next
// sibling, or the parent if there are no siblings. But since the root
// has no siblings nor a parent, we set it to null. Usually this is
// handled by `completeUnitOfWork` or `unwindWork`, but since we're
// intentionally not calling those, we need set it here.
// TODO: Consider calling `unwindWork` to pop the contexts.
workInProgress=null;return;}if(enableProfilerTimer&&erroredWork.mode&ProfileMode){// Record the time spent rendering before an error was thrown. This
// avoids inaccurate Profiler durations in the case of a
// suspended render.
stopProfilerTimerIfRunningAndRecordDelta(erroredWork,true);}if(enableSchedulingProfiler){markComponentRenderStopped();if(thrownValue!==null&&typeof thrownValue==='object'&&typeof thrownValue.then==='function'){var wakeable=thrownValue;markComponentSuspended(erroredWork,wakeable,workInProgressRootRenderLanes);}else {markComponentErrored(erroredWork,thrownValue,workInProgressRootRenderLanes);}}throwException(root,erroredWork.return,erroredWork,thrownValue,workInProgressRootRenderLanes);completeUnitOfWork(erroredWork);}catch(yetAnotherThrownValue){// Something in the return path also threw.
thrownValue=yetAnotherThrownValue;if(workInProgress===erroredWork&&erroredWork!==null){// If this boundary has already errored, then we had trouble processing
// the error. Bubble it to the next boundary.
erroredWork=erroredWork.return;workInProgress=erroredWork;}else {erroredWork=workInProgress;}continue;}// Return to the normal work loop.
return;}while(true);}function pushDispatcher(){var prevDispatcher=ReactCurrentDispatcher$2.current;ReactCurrentDispatcher$2.current=ContextOnlyDispatcher;if(prevDispatcher===null){// The React isomorphic package does not include a default dispatcher.
// Instead the first renderer will lazily attach one, in order to give
// nicer error messages.
return ContextOnlyDispatcher;}else {return prevDispatcher;}}function popDispatcher(prevDispatcher){ReactCurrentDispatcher$2.current=prevDispatcher;}function markCommitTimeOfFallback(){globalMostRecentFallbackTime=now();}function markSkippedUpdateLanes(lane){workInProgressRootSkippedLanes=mergeLanes(lane,workInProgressRootSkippedLanes);}function renderDidSuspend(){if(workInProgressRootExitStatus===RootInProgress){workInProgressRootExitStatus=RootSuspended;}}function renderDidSuspendDelayIfPossible(){if(workInProgressRootExitStatus===RootInProgress||workInProgressRootExitStatus===RootSuspended||workInProgressRootExitStatus===RootErrored){workInProgressRootExitStatus=RootSuspendedWithDelay;}// Check if there are updates that we skipped tree that might have unblocked
// this render.
if(workInProgressRoot!==null&&(includesNonIdleWork(workInProgressRootSkippedLanes)||includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))){// Mark the current render as suspended so that we switch to working on
// the updates that were skipped. Usually we only suspend at the end of
// the render phase.
// TODO: We should probably always mark the root as suspended immediately
// (inside this function), since by suspending at the end of the render
// phase introduces a potential mistake where we suspend lanes that were
// pinged or updated while we were rendering.
markRootSuspended$1(workInProgressRoot,workInProgressRootRenderLanes);}}function renderDidError(error){if(workInProgressRootExitStatus!==RootSuspendedWithDelay){workInProgressRootExitStatus=RootErrored;}if(workInProgressRootConcurrentErrors===null){workInProgressRootConcurrentErrors=[error];}else {workInProgressRootConcurrentErrors.push(error);}}// Called during render to determine if anything has suspended.
// Returns false if we're not sure.
function renderHasNotSuspendedYet(){// If something errored or completed, we can't really be sure,
// so those are false.
return workInProgressRootExitStatus===RootInProgress;}function renderRootSync(root,lanes){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();// If the root or lanes have changed, throw out the existing stack
// and prepare a fresh one. Otherwise we'll continue where we left off.
if(workInProgressRoot!==root||workInProgressRootRenderLanes!==lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;if(memoizedUpdaters.size>0){restorePendingUpdaters(root,workInProgressRootRenderLanes);memoizedUpdaters.clear();}// At this point, move Fibers that scheduled the upcoming work from the Map to the Set.
// If we bailout on this work, we'll move them back (like above).
// It's important to move them now in case the work spawns more work at the same priority with different updaters.
// That way we can keep the current update and future updates separate.
movePendingFibersToMemoized(root,lanes);}}workInProgressTransitions=getTransitionsForLanes();prepareFreshStack(root,lanes);}{markRenderStarted(lanes);}do{try{workLoopSync();break;}catch(thrownValue){handleError(root,thrownValue);}}while(true);resetContextDependencies();executionContext=prevExecutionContext;popDispatcher(prevDispatcher);if(workInProgress!==null){// This is a sync render, so we should have finished the whole tree.
throw new Error('Cannot commit an incomplete root. This error is likely caused by a '+'bug in React. Please file an issue.');}{markRenderStopped();}// Set this to null to indicate there's no in-progress render.
workInProgressRoot=null;workInProgressRootRenderLanes=NoLanes;return workInProgressRootExitStatus;}// The work loop is an extremely hot path. Tell Closure not to inline it.
/** @noinline */function workLoopSync(){// Already timed out, so perform work without checking if we need to yield.
while(workInProgress!==null){performUnitOfWork(workInProgress);}}function renderRootConcurrent(root,lanes){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();// If the root or lanes have changed, throw out the existing stack
// and prepare a fresh one. Otherwise we'll continue where we left off.
if(workInProgressRoot!==root||workInProgressRootRenderLanes!==lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;if(memoizedUpdaters.size>0){restorePendingUpdaters(root,workInProgressRootRenderLanes);memoizedUpdaters.clear();}// At this point, move Fibers that scheduled the upcoming work from the Map to the Set.
// If we bailout on this work, we'll move them back (like above).
// It's important to move them now in case the work spawns more work at the same priority with different updaters.
// That way we can keep the current update and future updates separate.
movePendingFibersToMemoized(root,lanes);}}workInProgressTransitions=getTransitionsForLanes();resetRenderTimer();prepareFreshStack(root,lanes);}{markRenderStarted(lanes);}do{try{workLoopConcurrent();break;}catch(thrownValue){handleError(root,thrownValue);}}while(true);resetContextDependencies();popDispatcher(prevDispatcher);executionContext=prevExecutionContext;if(workInProgress!==null){// Still work remaining.
{markRenderYielded();}return RootInProgress;}else {// Completed the tree.
{markRenderStopped();}// Set this to null to indicate there's no in-progress render.
workInProgressRoot=null;workInProgressRootRenderLanes=NoLanes;// Return the final exit status.
return workInProgressRootExitStatus;}}/** @noinline */function workLoopConcurrent(){// Perform work until Scheduler asks us to yield
while(workInProgress!==null&&!shouldYield()){performUnitOfWork(workInProgress);}}function performUnitOfWork(unitOfWork){// The current, flushed, state of this fiber is the alternate. Ideally
// nothing should rely on this, but relying on it here means that we don't
// need an additional field on the work in progress.
var current=unitOfWork.alternate;setCurrentFiber(unitOfWork);var next;if((unitOfWork.mode&ProfileMode)!==NoMode){startProfilerTimer(unitOfWork);next=beginWork$1(current,unitOfWork,subtreeRenderLanes);stopProfilerTimerIfRunningAndRecordDelta(unitOfWork,true);}else {next=beginWork$1(current,unitOfWork,subtreeRenderLanes);}resetCurrentFiber();unitOfWork.memoizedProps=unitOfWork.pendingProps;if(next===null){// If this doesn't spawn new work, complete the current work.
completeUnitOfWork(unitOfWork);}else {workInProgress=next;}ReactCurrentOwner$2.current=null;}function completeUnitOfWork(unitOfWork){// Attempt to complete the current unit of work, then move to the next
// sibling. If there are no more siblings, return to the parent fiber.
var completedWork=unitOfWork;do{// The current, flushed, state of this fiber is the alternate. Ideally
// nothing should rely on this, but relying on it here means that we don't
// need an additional field on the work in progress.
var current=completedWork.alternate;var returnFiber=completedWork.return;// Check if the work completed or if something threw.
if((completedWork.flags&Incomplete)===NoFlags){setCurrentFiber(completedWork);var next=void 0;if((completedWork.mode&ProfileMode)===NoMode){next=completeWork(current,completedWork,subtreeRenderLanes);}else {startProfilerTimer(completedWork);next=completeWork(current,completedWork,subtreeRenderLanes);// Update render duration assuming we didn't error.
stopProfilerTimerIfRunningAndRecordDelta(completedWork,false);}resetCurrentFiber();if(next!==null){// Completing this fiber spawned new work. Work on that next.
workInProgress=next;return;}}else {// This fiber did not complete because something threw. Pop values off
// the stack without entering the complete phase. If this is a boundary,
// capture values if possible.
var _next=unwindWork(current,completedWork);// Because this fiber did not complete, don't reset its lanes.
if(_next!==null){// If completing this work spawned new work, do that next. We'll come
// back here again.
// Since we're restarting, remove anything that is not a host effect
// from the effect tag.
_next.flags&=HostEffectMask;workInProgress=_next;return;}if((completedWork.mode&ProfileMode)!==NoMode){// Record the render duration for the fiber that errored.
stopProfilerTimerIfRunningAndRecordDelta(completedWork,false);// Include the time spent working on failed children before continuing.
var actualDuration=completedWork.actualDuration;var child=completedWork.child;while(child!==null){actualDuration+=child.actualDuration;child=child.sibling;}completedWork.actualDuration=actualDuration;}if(returnFiber!==null){// Mark the parent fiber as incomplete and clear its subtree flags.
returnFiber.flags|=Incomplete;returnFiber.subtreeFlags=NoFlags;returnFiber.deletions=null;}else {// We've unwound all the way to the root.
workInProgressRootExitStatus=RootDidNotComplete;workInProgress=null;return;}}var siblingFiber=completedWork.sibling;if(siblingFiber!==null){// If there is more work to do in this returnFiber, do that next.
workInProgress=siblingFiber;return;}// Otherwise, return to the parent
completedWork=returnFiber;// Update the next thing we're working on in case something throws.
workInProgress=completedWork;}while(completedWork!==null);// We've reached the root.
if(workInProgressRootExitStatus===RootInProgress){workInProgressRootExitStatus=RootCompleted;}}function commitRoot(root,recoverableErrors,transitions){// TODO: This no longer makes any sense. We already wrap the mutation and
// layout phases. Should be able to remove.
var previousUpdateLanePriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig$3.transition;try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);commitRootImpl(root,recoverableErrors,transitions,previousUpdateLanePriority);}finally{ReactCurrentBatchConfig$3.transition=prevTransition;setCurrentUpdatePriority(previousUpdateLanePriority);}return null;}function commitRootImpl(root,recoverableErrors,transitions,renderPriorityLevel){do{// `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which
// means `flushPassiveEffects` will sometimes result in additional
// passive effects. So we need to keep flushing in a loop until there are
// no more pending effects.
// TODO: Might be better if `flushPassiveEffects` did not automatically
// flush synchronous work at the end, to avoid factoring hazards like this.
flushPassiveEffects();}while(rootWithPendingPassiveEffects!==null);flushRenderPhaseStrictModeWarningsInDEV();if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}var finishedWork=root.finishedWork;var lanes=root.finishedLanes;{markCommitStarted(lanes);}if(finishedWork===null){{markCommitStopped();}return null;}else {{if(lanes===NoLanes){error('root.finishedLanes should not be empty during a commit. This is a '+'bug in React.');}}}root.finishedWork=null;root.finishedLanes=NoLanes;if(finishedWork===root.current){throw new Error('Cannot commit the same tree as before. This error is likely caused by '+'a bug in React. Please file an issue.');}// commitRoot never returns a continuation; it always finishes synchronously.
// So we can clear these now to allow a new callback to be scheduled.
root.callbackNode=null;root.callbackPriority=NoLane;// Update the first and last pending times on this root. The new first
// pending time is whatever is left on the root fiber.
var remainingLanes=mergeLanes(finishedWork.lanes,finishedWork.childLanes);markRootFinished(root,remainingLanes);if(root===workInProgressRoot){// We can reset these now that they are finished.
workInProgressRoot=null;workInProgress=null;workInProgressRootRenderLanes=NoLanes;}// If there are pending passive effects, schedule a callback to process them.
// Do this as early as possible, so it is queued before anything else that
// might get scheduled in the commit phase. (See #16714.)
// TODO: Delete all other places that schedule the passive effect callback
// They're redundant.
if((finishedWork.subtreeFlags&PassiveMask)!==NoFlags||(finishedWork.flags&PassiveMask)!==NoFlags){if(!rootDoesHavePassiveEffects){rootDoesHavePassiveEffects=true;// to store it in pendingPassiveTransitions until they get processed
// We need to pass this through as an argument to commitRoot
// because workInProgressTransitions might have changed between
// the previous render and commit if we throttle the commit
// with setTimeout
pendingPassiveTransitions=transitions;scheduleCallback$1(NormalPriority,function(){flushPassiveEffects();// This render triggered passive effects: release the root cache pool
// *after* passive effects fire to avoid freeing a cache pool that may
// be referenced by a node in the tree (HostRoot, Cache boundary etc)
return null;});}}// Check if there are any effects in the whole tree.
// TODO: This is left over from the effect list implementation, where we had
// to check for the existence of `firstEffect` to satisfy Flow. I think the
// only other reason this optimization exists is because it affects profiling.
// Reconsider whether this is necessary.
var subtreeHasEffects=(finishedWork.subtreeFlags&(BeforeMutationMask|MutationMask|LayoutMask|PassiveMask))!==NoFlags;var rootHasEffect=(finishedWork.flags&(BeforeMutationMask|MutationMask|LayoutMask|PassiveMask))!==NoFlags;if(subtreeHasEffects||rootHasEffect){var prevTransition=ReactCurrentBatchConfig$3.transition;ReactCurrentBatchConfig$3.transition=null;var previousPriority=getCurrentUpdatePriority();setCurrentUpdatePriority(DiscreteEventPriority);var prevExecutionContext=executionContext;executionContext|=CommitContext;// Reset this to null before calling lifecycles
ReactCurrentOwner$2.current=null;// The commit phase is broken into several sub-phases. We do a separate pass
// of the effect list for each phase: all mutation effects come before all
// layout effects, and so on.
// The first phase a "before mutation" phase. We use this phase to read the
// state of the host tree right before we mutate it. This is where
// getSnapshotBeforeUpdate is called.
commitBeforeMutationEffects(root,finishedWork);{// Mark the current commit time to be shared by all Profilers in this
// batch. This enables them to be grouped later.
recordCommitTime();}commitMutationEffects(root,finishedWork,lanes);resetAfterCommit(root.containerInfo);// The work-in-progress tree is now the current tree. This must come after
// the mutation phase, so that the previous tree is still current during
// componentWillUnmount, but before the layout phase, so that the finished
// work is current during componentDidMount/Update.
root.current=finishedWork;// The next phase is the layout phase, where we call effects that read
{markLayoutEffectsStarted(lanes);}commitLayoutEffects(finishedWork,root,lanes);{markLayoutEffectsStopped();}// opportunity to paint.
requestPaint();executionContext=prevExecutionContext;// Reset the priority to the previous non-sync value.
setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;}else {// No effects.
root.current=finishedWork;// Measure these anyway so the flamegraph explicitly shows that there were
// no effects.
// TODO: Maybe there's a better way to report this.
{recordCommitTime();}}var rootDidHavePassiveEffects=rootDoesHavePassiveEffects;if(rootDoesHavePassiveEffects){// This commit has passive effects. Stash a reference to them. But don't
// schedule a callback until after flushing layout work.
rootDoesHavePassiveEffects=false;rootWithPendingPassiveEffects=root;pendingPassiveEffectsLanes=lanes;}else {{nestedPassiveUpdateCount=0;rootWithPassiveNestedUpdates=null;}}// Read this again, since an effect might have updated it
remainingLanes=root.pendingLanes;// Check if there's remaining work on this root
// TODO: This is part of the `componentDidCatch` implementation. Its purpose
// is to detect whether something might have called setState inside
// `componentDidCatch`. The mechanism is known to be flawed because `setState`
// inside `componentDidCatch` is itself flawed — that's why we recommend
// `getDerivedStateFromError` instead. However, it could be improved by
// checking if remainingLanes includes Sync work, instead of whether there's
// any work remaining at all (which would also include stuff like Suspense
// retries or transitions). It's been like this for a while, though, so fixing
// it probably isn't that urgent.
if(remainingLanes===NoLanes){// If there's no remaining work, we can clear the set of already failed
// error boundaries.
legacyErrorBoundariesThatAlreadyFailed=null;}{if(!rootDidHavePassiveEffects){commitDoubleInvokeEffectsInDEV(root.current,false);}}onCommitRoot(finishedWork.stateNode,renderPriorityLevel);{if(isDevToolsPresent){root.memoizedUpdaters.clear();}}{onCommitRoot$1();}// Always call this before exiting `commitRoot`, to ensure that any
// additional work on this root is scheduled.
ensureRootIsScheduled(root,now());if(recoverableErrors!==null){// There were errors during this render, but recovered from them without
// needing to surface it to the UI. We log them here.
var onRecoverableError=root.onRecoverableError;for(var i=0;i<recoverableErrors.length;i++){var recoverableError=recoverableErrors[i];var componentStack=recoverableError.stack;var digest=recoverableError.digest;onRecoverableError(recoverableError.value,{componentStack:componentStack,digest:digest});}}if(hasUncaughtError){hasUncaughtError=false;var error$1=firstUncaughtError;firstUncaughtError=null;throw error$1;}// If the passive effects are the result of a discrete render, flush them
// synchronously at the end of the current task so that the result is
// immediately observable. Otherwise, we assume that they are not
// order-dependent and do not need to be observed by external systems, so we
// can wait until after paint.
// TODO: We can optimize this by not scheduling the callback earlier. Since we
// currently schedule the callback in multiple places, will wait until those
// are consolidated.
if(includesSomeLane(pendingPassiveEffectsLanes,SyncLane)&&root.tag!==LegacyRoot){flushPassiveEffects();}// Read this again, since a passive effect might have updated it
remainingLanes=root.pendingLanes;if(includesSomeLane(remainingLanes,SyncLane)){{markNestedUpdateScheduled();}// Count the number of times the root synchronously re-renders without
// finishing. If there are too many, it indicates an infinite update loop.
if(root===rootWithNestedUpdates){nestedUpdateCount++;}else {nestedUpdateCount=0;rootWithNestedUpdates=root;}}else {nestedUpdateCount=0;}// If layout work was scheduled, flush it now.
flushSyncCallbacks();{markCommitStopped();}return null;}function flushPassiveEffects(){// Returns whether passive effects were flushed.
// TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should
// probably just combine the two functions. I believe they were only separate
// in the first place because we used to wrap it with
// `Scheduler.runWithPriority`, which accepts a function. But now we track the
// priority within React itself, so we can mutate the variable directly.
if(rootWithPendingPassiveEffects!==null){var renderPriority=lanesToEventPriority(pendingPassiveEffectsLanes);var priority=lowerEventPriority(DefaultEventPriority,renderPriority);var prevTransition=ReactCurrentBatchConfig$3.transition;var previousPriority=getCurrentUpdatePriority();try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(priority);return flushPassiveEffectsImpl();}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;// Once passive effects have run for the tree - giving components a
}}return false;}function enqueuePendingPassiveProfilerEffect(fiber){{pendingPassiveProfilerEffects.push(fiber);if(!rootDoesHavePassiveEffects){rootDoesHavePassiveEffects=true;scheduleCallback$1(NormalPriority,function(){flushPassiveEffects();return null;});}}}function flushPassiveEffectsImpl(){if(rootWithPendingPassiveEffects===null){return false;}// Cache and clear the transitions flag
var transitions=pendingPassiveTransitions;pendingPassiveTransitions=null;var root=rootWithPendingPassiveEffects;var lanes=pendingPassiveEffectsLanes;rootWithPendingPassiveEffects=null;// TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.
// Figure out why and fix it. It's not causing any known issues (probably
// because it's only used for profiling), but it's a refactor hazard.
pendingPassiveEffectsLanes=NoLanes;if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Cannot flush passive effects while already rendering.');}{isFlushingPassiveEffects=true;didScheduleUpdateDuringPassiveEffects=false;}{markPassiveEffectsStarted(lanes);}var prevExecutionContext=executionContext;executionContext|=CommitContext;commitPassiveUnmountEffects(root.current);commitPassiveMountEffects(root,root.current,lanes,transitions);// TODO: Move to commitPassiveMountEffects
{var profilerEffects=pendingPassiveProfilerEffects;pendingPassiveProfilerEffects=[];for(var i=0;i<profilerEffects.length;i++){var _fiber=profilerEffects[i];commitPassiveEffectDurations(root,_fiber);}}{markPassiveEffectsStopped();}{commitDoubleInvokeEffectsInDEV(root.current,true);}executionContext=prevExecutionContext;flushSyncCallbacks();{// If additional passive effects were scheduled, increment a counter. If this
// exceeds the limit, we'll fire a warning.
if(didScheduleUpdateDuringPassiveEffects){if(root===rootWithPassiveNestedUpdates){nestedPassiveUpdateCount++;}else {nestedPassiveUpdateCount=0;rootWithPassiveNestedUpdates=root;}}else {nestedPassiveUpdateCount=0;}isFlushingPassiveEffects=false;didScheduleUpdateDuringPassiveEffects=false;}// TODO: Move to commitPassiveMountEffects
onPostCommitRoot(root);{var stateNode=root.current.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}return true;}function isAlreadyFailedLegacyErrorBoundary(instance){return legacyErrorBoundariesThatAlreadyFailed!==null&&legacyErrorBoundariesThatAlreadyFailed.has(instance);}function markLegacyErrorBoundaryAsFailed(instance){if(legacyErrorBoundariesThatAlreadyFailed===null){legacyErrorBoundariesThatAlreadyFailed=new Set([instance]);}else {legacyErrorBoundariesThatAlreadyFailed.add(instance);}}function prepareToThrowUncaughtError(error){if(!hasUncaughtError){hasUncaughtError=true;firstUncaughtError=error;}}var onUncaughtError=prepareToThrowUncaughtError;function captureCommitPhaseErrorOnRoot(rootFiber,sourceFiber,error){var errorInfo=createCapturedValueAtFiber(error,sourceFiber);var update=createRootErrorUpdate(rootFiber,errorInfo,SyncLane);var root=enqueueUpdate(rootFiber,update,SyncLane);var eventTime=requestEventTime();if(root!==null){markRootUpdated(root,SyncLane,eventTime);ensureRootIsScheduled(root,eventTime);}}function captureCommitPhaseError(sourceFiber,nearestMountedAncestor,error$1){{reportUncaughtErrorInDEV(error$1);setIsRunningInsertionEffect(false);}if(sourceFiber.tag===HostRoot){// Error was thrown at the root. There is no parent, so the root
// itself should capture it.
captureCommitPhaseErrorOnRoot(sourceFiber,sourceFiber,error$1);return;}var fiber=null;{fiber=nearestMountedAncestor;}while(fiber!==null){if(fiber.tag===HostRoot){captureCommitPhaseErrorOnRoot(fiber,sourceFiber,error$1);return;}else if(fiber.tag===ClassComponent){var ctor=fiber.type;var instance=fiber.stateNode;if(typeof ctor.getDerivedStateFromError==='function'||typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance)){var errorInfo=createCapturedValueAtFiber(error$1,sourceFiber);var update=createClassErrorUpdate(fiber,errorInfo,SyncLane);var root=enqueueUpdate(fiber,update,SyncLane);var eventTime=requestEventTime();if(root!==null){markRootUpdated(root,SyncLane,eventTime);ensureRootIsScheduled(root,eventTime);}return;}}fiber=fiber.return;}{// TODO: Until we re-land skipUnmountedBoundaries (see #20147), this warning
// will fire for errors that are thrown by destroy functions inside deleted
// trees. What it should instead do is propagate the error to the parent of
// the deleted tree. In the meantime, do not add this warning to the
// allowlist; this is only for our internal use.
error('Internal React error: Attempted to capture a commit phase error '+'inside a detached tree. This indicates a bug in React. Likely '+'causes include deleting the same fiber more than once, committing an '+'already-finished tree, or an inconsistent return pointer.\n\n'+'Error message:\n\n%s',error$1);}}function pingSuspendedRoot(root,wakeable,pingedLanes){var pingCache=root.pingCache;if(pingCache!==null){// The wakeable resolved, so we no longer need to memoize, because it will
// never be thrown again.
pingCache.delete(wakeable);}var eventTime=requestEventTime();markRootPinged(root,pingedLanes);warnIfSuspenseResolutionNotWrappedWithActDEV(root);if(workInProgressRoot===root&&isSubsetOfLanes(workInProgressRootRenderLanes,pingedLanes)){// Received a ping at the same priority level at which we're currently
// rendering. We might want to restart this render. This should mirror
// the logic of whether or not a root suspends once it completes.
// TODO: If we're rendering sync either due to Sync, Batched or expired,
// we should probably never restart.
// If we're suspended with delay, or if it's a retry, we'll always suspend
// so we can always restart.
if(workInProgressRootExitStatus===RootSuspendedWithDelay||workInProgressRootExitStatus===RootSuspended&&includesOnlyRetries(workInProgressRootRenderLanes)&&now()-globalMostRecentFallbackTime<FALLBACK_THROTTLE_MS){// Restart from the root.
prepareFreshStack(root,NoLanes);}else {// Even though we can't restart right now, we might get an
// opportunity later. So we mark this render as having a ping.
workInProgressRootPingedLanes=mergeLanes(workInProgressRootPingedLanes,pingedLanes);}}ensureRootIsScheduled(root,eventTime);}function retryTimedOutBoundary(boundaryFiber,retryLane){// The boundary fiber (a Suspense component or SuspenseList component)
// previously was rendered in its fallback state. One of the promises that
// suspended it has resolved, which means at least part of the tree was
// likely unblocked. Try rendering again, at a new lanes.
if(retryLane===NoLane){// TODO: Assign this to `suspenseState.retryLane`? to avoid
// unnecessary entanglement?
retryLane=requestRetryLane(boundaryFiber);}// TODO: Special case idle priority?
var eventTime=requestEventTime();var root=enqueueConcurrentRenderForLane(boundaryFiber,retryLane);if(root!==null){markRootUpdated(root,retryLane,eventTime);ensureRootIsScheduled(root,eventTime);}}function retryDehydratedSuspenseBoundary(boundaryFiber){var suspenseState=boundaryFiber.memoizedState;var retryLane=NoLane;if(suspenseState!==null){retryLane=suspenseState.retryLane;}retryTimedOutBoundary(boundaryFiber,retryLane);}function resolveRetryWakeable(boundaryFiber,wakeable){var retryLane=NoLane;// Default
var retryCache;switch(boundaryFiber.tag){case SuspenseComponent:retryCache=boundaryFiber.stateNode;var suspenseState=boundaryFiber.memoizedState;if(suspenseState!==null){retryLane=suspenseState.retryLane;}break;case SuspenseListComponent:retryCache=boundaryFiber.stateNode;break;default:throw new Error('Pinged unknown suspense boundary type. '+'This is probably a bug in React.');}if(retryCache!==null){// The wakeable resolved, so we no longer need to memoize, because it will
// never be thrown again.
retryCache.delete(wakeable);}retryTimedOutBoundary(boundaryFiber,retryLane);}// Computes the next Just Noticeable Difference (JND) boundary.
// The theory is that a person can't tell the difference between small differences in time.
// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable
// difference in the experience. However, waiting for longer might mean that we can avoid
// showing an intermediate loading state. The longer we have already waited, the harder it
// is to tell small differences in time. Therefore, the longer we've already waited,
// the longer we can wait additionally. At some point we have to give up though.
// We pick a train model where the next boundary commits at a consistent schedule.
// These particular numbers are vague estimates. We expect to adjust them based on research.
function jnd(timeElapsed){return timeElapsed<120?120:timeElapsed<480?480:timeElapsed<1080?1080:timeElapsed<1920?1920:timeElapsed<3000?3000:timeElapsed<4320?4320:ceil(timeElapsed/1960)*1960;}function checkForNestedUpdates(){if(nestedUpdateCount>NESTED_UPDATE_LIMIT){nestedUpdateCount=0;rootWithNestedUpdates=null;throw new Error('Maximum update depth exceeded. This can happen when a component '+'repeatedly calls setState inside componentWillUpdate or '+'componentDidUpdate. React limits the number of nested updates to '+'prevent infinite loops.');}{if(nestedPassiveUpdateCount>NESTED_PASSIVE_UPDATE_LIMIT){nestedPassiveUpdateCount=0;rootWithPassiveNestedUpdates=null;error('Maximum update depth exceeded. This can happen when a component '+"calls setState inside useEffect, but useEffect either doesn't "+'have a dependency array, or one of the dependencies changes on '+'every render.');}}}function flushRenderPhaseStrictModeWarningsInDEV(){{ReactStrictModeWarnings.flushLegacyContextWarning();{ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();}}}function commitDoubleInvokeEffectsInDEV(fiber,hasPassiveEffects){{// TODO (StrictEffects) Should we set a marker on the root if it contains strict effects
// so we don't traverse unnecessarily? similar to subtreeFlags but just at the root level.
// Maybe not a big deal since this is DEV only behavior.
setCurrentFiber(fiber);invokeEffectsInDev(fiber,MountLayoutDev,invokeLayoutEffectUnmountInDEV);if(hasPassiveEffects){invokeEffectsInDev(fiber,MountPassiveDev,invokePassiveEffectUnmountInDEV);}invokeEffectsInDev(fiber,MountLayoutDev,invokeLayoutEffectMountInDEV);if(hasPassiveEffects){invokeEffectsInDev(fiber,MountPassiveDev,invokePassiveEffectMountInDEV);}resetCurrentFiber();}}function invokeEffectsInDev(firstChild,fiberFlags,invokeEffectFn){{// We don't need to re-check StrictEffectsMode here.
// This function is only called if that check has already passed.
var current=firstChild;var subtreeRoot=null;while(current!==null){var primarySubtreeFlag=current.subtreeFlags&fiberFlags;if(current!==subtreeRoot&&current.child!==null&&primarySubtreeFlag!==NoFlags){current=current.child;}else {if((current.flags&fiberFlags)!==NoFlags){invokeEffectFn(current);}if(current.sibling!==null){current=current.sibling;}else {current=subtreeRoot=current.return;}}}}}var didWarnStateUpdateForNotYetMountedComponent=null;function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber){{if((executionContext&RenderContext)!==NoContext){// We let the other warning about render phase updates deal with this one.
return;}if(!(fiber.mode&ConcurrentMode)){return;}var tag=fiber.tag;if(tag!==IndeterminateComponent&&tag!==HostRoot&&tag!==ClassComponent&&tag!==FunctionComponent&&tag!==ForwardRef&&tag!==MemoComponent&&tag!==SimpleMemoComponent){// Only warn for user-defined components, not internal ones like Suspense.
return;}// We show the whole stack but dedupe on the top component's name because
// the problematic code almost always lies inside that component.
var componentName=getComponentNameFromFiber(fiber)||'ReactComponent';if(didWarnStateUpdateForNotYetMountedComponent!==null){if(didWarnStateUpdateForNotYetMountedComponent.has(componentName)){return;}didWarnStateUpdateForNotYetMountedComponent.add(componentName);}else {didWarnStateUpdateForNotYetMountedComponent=new Set([componentName]);}var previousFiber=current;try{setCurrentFiber(fiber);error("Can't perform a React state update on a component that hasn't mounted yet. "+'This indicates that you have a side-effect in your render function that '+'asynchronously later calls tries to update the component. Move this work to '+'useEffect instead.');}finally{if(previousFiber){setCurrentFiber(fiber);}else {resetCurrentFiber();}}}}var beginWork$1;{var dummyFiber=null;beginWork$1=function(current,unitOfWork,lanes){// If a component throws an error, we replay it again in a synchronously
// dispatched event, so that the debugger will treat it as an uncaught
// error See ReactErrorUtils for more information.
// Before entering the begin phase, copy the work-in-progress onto a dummy
// fiber. If beginWork throws, we'll use this to reset the state.
var originalWorkInProgressCopy=assignFiberPropertiesInDEV(dummyFiber,unitOfWork);try{return beginWork(current,unitOfWork,lanes);}catch(originalError){if(didSuspendOrErrorWhileHydratingDEV()||originalError!==null&&typeof originalError==='object'&&typeof originalError.then==='function'){// Don't replay promises.
// Don't replay errors if we are hydrating and have already suspended or handled an error
throw originalError;}// Keep this code in sync with handleError; any changes here must have
// corresponding changes there.
resetContextDependencies();resetHooksAfterThrow();// Don't reset current debug fiber, since we're about to work on the
// same fiber again.
// Unwind the failed stack frame
unwindInterruptedWork(current,unitOfWork);// Restore the original properties of the fiber.
assignFiberPropertiesInDEV(unitOfWork,originalWorkInProgressCopy);if(unitOfWork.mode&ProfileMode){// Reset the profiler timer.
startProfilerTimer(unitOfWork);}// Run beginWork again.
invokeGuardedCallback(null,beginWork,null,current,unitOfWork,lanes);if(hasCaughtError()){var replayError=clearCaughtError();if(typeof replayError==='object'&&replayError!==null&&replayError._suppressLogging&&typeof originalError==='object'&&originalError!==null&&!originalError._suppressLogging){// If suppressed, let the flag carry over to the original error which is the one we'll rethrow.
originalError._suppressLogging=true;}}// We always throw the original error in case the second render pass is not idempotent.
// This can happen if a memoized function or CommonJS module doesn't throw after first invocation.
throw originalError;}};}var didWarnAboutUpdateInRender=false;var didWarnAboutUpdateInRenderForAnotherComponent;{didWarnAboutUpdateInRenderForAnotherComponent=new Set();}function warnAboutRenderPhaseUpdatesInDEV(fiber){{if(isRendering&&!getIsUpdatingOpaqueValueInRenderPhaseInDEV()){switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{var renderingComponentName=workInProgress&&getComponentNameFromFiber(workInProgress)||'Unknown';// Dedupe by the rendering component because it's the one that needs to be fixed.
var dedupeKey=renderingComponentName;if(!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)){didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);var setStateComponentName=getComponentNameFromFiber(fiber)||'Unknown';error('Cannot update a component (`%s`) while rendering a '+'different component (`%s`). To locate the bad setState() call inside `%s`, '+'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',setStateComponentName,renderingComponentName,renderingComponentName);}break;}case ClassComponent:{if(!didWarnAboutUpdateInRender){error('Cannot update during an existing state transition (such as '+'within `render`). Render methods should be a pure '+'function of props and state.');didWarnAboutUpdateInRender=true;}break;}}}}}function restorePendingUpdaters(root,lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;memoizedUpdaters.forEach(function(schedulingFiber){addFiberToLanesMap(root,schedulingFiber,lanes);});// This function intentionally does not clear memoized updaters.
// Those may still be relevant to the current commit
// and a future one (e.g. Suspense).
}}}var fakeActCallbackNode={};function scheduleCallback$1(priorityLevel,callback){{// If we're currently inside an `act` scope, bypass Scheduler and push to
// the `act` queue instead.
var actQueue=ReactCurrentActQueue$1.current;if(actQueue!==null){actQueue.push(callback);return fakeActCallbackNode;}else {return scheduleCallback(priorityLevel,callback);}}}function cancelCallback$1(callbackNode){if(callbackNode===fakeActCallbackNode){return;}// In production, always call Scheduler. This function will be stripped out.
return cancelCallback(callbackNode);}function shouldForceFlushFallbacksInDEV(){// Never force flush in production. This function should get stripped out.
return ReactCurrentActQueue$1.current!==null;}function warnIfUpdatesNotWrappedWithActDEV(fiber){{if(fiber.mode&ConcurrentMode){if(!isConcurrentActEnvironment()){// Not in an act environment. No need to warn.
return;}}else {// Legacy mode has additional cases where we suppress a warning.
if(!isLegacyActEnvironment()){// Not in an act environment. No need to warn.
return;}if(executionContext!==NoContext){// Legacy mode doesn't warn if the update is batched, i.e.
// batchedUpdates or flushSync.
return;}if(fiber.tag!==FunctionComponent&&fiber.tag!==ForwardRef&&fiber.tag!==SimpleMemoComponent){// For backwards compatibility with pre-hooks code, legacy mode only
// warns for updates that originate from a hook.
return;}}if(ReactCurrentActQueue$1.current===null){var previousFiber=current;try{setCurrentFiber(fiber);error('An update to %s inside a test was not wrapped in act(...).\n\n'+'When testing, code that causes React state updates should be '+'wrapped into act(...):\n\n'+'act(() => {\n'+'  /* fire events that update state */\n'+'});\n'+'/* assert on the output */\n\n'+"This ensures that you're testing the behavior the user would see "+'in the browser.'+' Learn more at https://reactjs.org/link/wrap-tests-with-act',getComponentNameFromFiber(fiber));}finally{if(previousFiber){setCurrentFiber(fiber);}else {resetCurrentFiber();}}}}}function warnIfSuspenseResolutionNotWrappedWithActDEV(root){{if(root.tag!==LegacyRoot&&isConcurrentActEnvironment()&&ReactCurrentActQueue$1.current===null){error('A suspended resource finished loading inside a test, but the event '+'was not wrapped in act(...).\n\n'+'When testing, code that resolves suspended data should be wrapped '+'into act(...):\n\n'+'act(() => {\n'+'  /* finish loading suspended data */\n'+'});\n'+'/* assert on the output */\n\n'+"This ensures that you're testing the behavior the user would see "+'in the browser.'+' Learn more at https://reactjs.org/link/wrap-tests-with-act');}}}function setIsRunningInsertionEffect(isRunning){{isRunningInsertionEffect=isRunning;}}/* eslint-disable react-internal/prod-error-codes */var resolveFamily=null;// $FlowFixMe Flow gets confused by a WeakSet feature check below.
var failedBoundaries=null;var setRefreshHandler=function(handler){{resolveFamily=handler;}};function resolveFunctionForHotReloading(type){{if(resolveFamily===null){// Hot reloading is disabled.
return type;}var family=resolveFamily(type);if(family===undefined){return type;}// Use the latest known implementation.
return family.current;}}function resolveClassForHotReloading(type){// No implementation differences.
return resolveFunctionForHotReloading(type);}function resolveForwardRefForHotReloading(type){{if(resolveFamily===null){// Hot reloading is disabled.
return type;}var family=resolveFamily(type);if(family===undefined){// Check if we're dealing with a real forwardRef. Don't want to crash early.
if(type!==null&&type!==undefined&&typeof type.render==='function'){// ForwardRef is special because its resolved .type is an object,
// but it's possible that we only have its inner render function in the map.
// If that inner render function is different, we'll build a new forwardRef type.
var currentRender=resolveFunctionForHotReloading(type.render);if(type.render!==currentRender){var syntheticType={$$typeof:REACT_FORWARD_REF_TYPE,render:currentRender};if(type.displayName!==undefined){syntheticType.displayName=type.displayName;}return syntheticType;}}return type;}// Use the latest known implementation.
return family.current;}}function isCompatibleFamilyForHotReloading(fiber,element){{if(resolveFamily===null){// Hot reloading is disabled.
return false;}var prevType=fiber.elementType;var nextType=element.type;// If we got here, we know types aren't === equal.
var needsCompareFamilies=false;var $$typeofNextType=typeof nextType==='object'&&nextType!==null?nextType.$$typeof:null;switch(fiber.tag){case ClassComponent:{if(typeof nextType==='function'){needsCompareFamilies=true;}break;}case FunctionComponent:{if(typeof nextType==='function'){needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){// We don't know the inner type yet.
// We're going to assume that the lazy inner type is stable,
// and so it is sufficient to avoid reconciling it away.
// We're not going to unwrap or actually use the new lazy type.
needsCompareFamilies=true;}break;}case ForwardRef:{if($$typeofNextType===REACT_FORWARD_REF_TYPE){needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){needsCompareFamilies=true;}break;}case MemoComponent:case SimpleMemoComponent:{if($$typeofNextType===REACT_MEMO_TYPE){// TODO: if it was but can no longer be simple,
// we shouldn't set this.
needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){needsCompareFamilies=true;}break;}default:return false;}// Check if both types have a family and it's the same one.
if(needsCompareFamilies){// Note: memo() and forwardRef() we'll compare outer rather than inner type.
// This means both of them need to be registered to preserve state.
// If we unwrapped and compared the inner types for wrappers instead,
// then we would risk falsely saying two separate memo(Foo)
// calls are equivalent because they wrap the same Foo function.
var prevFamily=resolveFamily(prevType);if(prevFamily!==undefined&&prevFamily===resolveFamily(nextType)){return true;}}return false;}}function markFailedErrorBoundaryForHotReloading(fiber){{if(resolveFamily===null){// Hot reloading is disabled.
return;}if(typeof WeakSet!=='function'){return;}if(failedBoundaries===null){failedBoundaries=new WeakSet();}failedBoundaries.add(fiber);}}var scheduleRefresh=function(root,update){{if(resolveFamily===null){// Hot reloading is disabled.
return;}var staleFamilies=update.staleFamilies,updatedFamilies=update.updatedFamilies;flushPassiveEffects();flushSync(function(){scheduleFibersWithFamiliesRecursively(root.current,updatedFamilies,staleFamilies);});}};var scheduleRoot=function(root,element){{if(root.context!==emptyContextObject){// Super edge case: root has a legacy _renderSubtree context
// but we don't know the parentComponent so we can't pass it.
// Just ignore. We'll delete this with _renderSubtree code path later.
return;}flushPassiveEffects();flushSync(function(){updateContainer(element,root,null,null);});}};function scheduleFibersWithFamiliesRecursively(fiber,updatedFamilies,staleFamilies){{var alternate=fiber.alternate,child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type;var candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break;}if(resolveFamily===null){throw new Error('Expected resolveFamily to be set during hot reload.');}var needsRender=false;var needsRemount=false;if(candidateType!==null){var family=resolveFamily(candidateType);if(family!==undefined){if(staleFamilies.has(family)){needsRemount=true;}else if(updatedFamilies.has(family)){if(tag===ClassComponent){needsRemount=true;}else {needsRender=true;}}}}if(failedBoundaries!==null){if(failedBoundaries.has(fiber)||alternate!==null&&failedBoundaries.has(alternate)){needsRemount=true;}}if(needsRemount){fiber._debugNeedsRemount=true;}if(needsRemount||needsRender){var _root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(_root!==null){scheduleUpdateOnFiber(_root,fiber,SyncLane,NoTimestamp);}}if(child!==null&&!needsRemount){scheduleFibersWithFamiliesRecursively(child,updatedFamilies,staleFamilies);}if(sibling!==null){scheduleFibersWithFamiliesRecursively(sibling,updatedFamilies,staleFamilies);}}}var findHostInstancesForRefresh=function(root,families){{var hostInstances=new Set();var types=new Set(families.map(function(family){return family.current;}));findHostInstancesForMatchingFibersRecursively(root.current,types,hostInstances);return hostInstances;}};function findHostInstancesForMatchingFibersRecursively(fiber,types,hostInstances){{var child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type;var candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break;}var didMatch=false;if(candidateType!==null){if(types.has(candidateType)){didMatch=true;}}if(didMatch){// We have a match. This only drills down to the closest host components.
// There's no need to search deeper because for the purpose of giving
// visual feedback, "flashing" outermost parent rectangles is sufficient.
findHostInstancesForFiberShallowly(fiber,hostInstances);}else {// If there's no match, maybe there will be one further down in the child tree.
if(child!==null){findHostInstancesForMatchingFibersRecursively(child,types,hostInstances);}}if(sibling!==null){findHostInstancesForMatchingFibersRecursively(sibling,types,hostInstances);}}}function findHostInstancesForFiberShallowly(fiber,hostInstances){{var foundHostInstances=findChildHostInstancesForFiberShallowly(fiber,hostInstances);if(foundHostInstances){return;}// If we didn't find any host children, fallback to closest host parent.
var node=fiber;while(true){switch(node.tag){case HostComponent:hostInstances.add(node.stateNode);return;case HostPortal:hostInstances.add(node.stateNode.containerInfo);return;case HostRoot:hostInstances.add(node.stateNode.containerInfo);return;}if(node.return===null){throw new Error('Expected to reach root first.');}node=node.return;}}}function findChildHostInstancesForFiberShallowly(fiber,hostInstances){{var node=fiber;var foundHostInstances=false;while(true){if(node.tag===HostComponent){// We got a match.
foundHostInstances=true;hostInstances.add(node.stateNode);// There may still be more, so keep searching.
}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===fiber){return foundHostInstances;}while(node.sibling===null){if(node.return===null||node.return===fiber){return foundHostInstances;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}return false;}var hasBadMapPolyfill;{hasBadMapPolyfill=false;try{var nonExtensibleObject=Object.preventExtensions({});/* eslint-disable no-new */new Map([[nonExtensibleObject,null]]);new Set([nonExtensibleObject]);/* eslint-enable no-new */}catch(e){// TODO: Consider warning about bad polyfills
hasBadMapPolyfill=true;}}function FiberNode(tag,pendingProps,key,mode){// Instance
this.tag=tag;this.key=key;this.elementType=null;this.type=null;this.stateNode=null;// Fiber
this.return=null;this.child=null;this.sibling=null;this.index=0;this.ref=null;this.pendingProps=pendingProps;this.memoizedProps=null;this.updateQueue=null;this.memoizedState=null;this.dependencies=null;this.mode=mode;// Effects
this.flags=NoFlags;this.subtreeFlags=NoFlags;this.deletions=null;this.lanes=NoLanes;this.childLanes=NoLanes;this.alternate=null;{// Note: The following is done to avoid a v8 performance cliff.
//
// Initializing the fields below to smis and later updating them with
// double values will cause Fibers to end up having separate shapes.
// This behavior/bug has something to do with Object.preventExtension().
// Fortunately this only impacts DEV builds.
// Unfortunately it makes React unusably slow for some applications.
// To work around this, initialize the fields below with doubles.
//
// Learn more about this here:
// https://github.com/facebook/react/issues/14365
// https://bugs.chromium.org/p/v8/issues/detail?id=8538
this.actualDuration=Number.NaN;this.actualStartTime=Number.NaN;this.selfBaseDuration=Number.NaN;this.treeBaseDuration=Number.NaN;// It's okay to replace the initial doubles with smis after initialization.
// This won't trigger the performance cliff mentioned above,
// and it simplifies other profiler code (including DevTools).
this.actualDuration=0;this.actualStartTime=-1;this.selfBaseDuration=0;this.treeBaseDuration=0;}{// This isn't directly used but is handy for debugging internals:
this._debugSource=null;this._debugOwner=null;this._debugNeedsRemount=false;this._debugHookTypes=null;if(!hasBadMapPolyfill&&typeof Object.preventExtensions==='function'){Object.preventExtensions(this);}}}// This is a constructor function, rather than a POJO constructor, still
// please ensure we do the following:
// 1) Nobody should add any instance methods on this. Instance methods can be
//    more difficult to predict when they get optimized and they are almost
//    never inlined properly in static compilers.
// 2) Nobody should rely on `instanceof Fiber` for type testing. We should
//    always know when it is a fiber.
// 3) We might want to experiment with using numeric keys since they are easier
//    to optimize in a non-JIT environment.
// 4) We can easily go from a constructor to a createFiber object literal if that
//    is faster.
// 5) It should be easy to port this to a C struct and keep a C implementation
//    compatible.
var createFiber=function(tag,pendingProps,key,mode){// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
return new FiberNode(tag,pendingProps,key,mode);};function shouldConstruct$1(Component){var prototype=Component.prototype;return !!(prototype&&prototype.isReactComponent);}function isSimpleFunctionComponent(type){return typeof type==='function'&&!shouldConstruct$1(type)&&type.defaultProps===undefined;}function resolveLazyComponentTag(Component){if(typeof Component==='function'){return shouldConstruct$1(Component)?ClassComponent:FunctionComponent;}else if(Component!==undefined&&Component!==null){var $$typeof=Component.$$typeof;if($$typeof===REACT_FORWARD_REF_TYPE){return ForwardRef;}if($$typeof===REACT_MEMO_TYPE){return MemoComponent;}}return IndeterminateComponent;}// This is used to create an alternate fiber to do work on.
function createWorkInProgress(current,pendingProps){var workInProgress=current.alternate;if(workInProgress===null){// We use a double buffering pooling technique because we know that we'll
// only ever need at most two versions of a tree. We pool the "other" unused
// node that we're free to reuse. This is lazily created to avoid allocating
// extra objects for things that are never updated. It also allow us to
// reclaim the extra memory if needed.
workInProgress=createFiber(current.tag,pendingProps,current.key,current.mode);workInProgress.elementType=current.elementType;workInProgress.type=current.type;workInProgress.stateNode=current.stateNode;{// DEV-only fields
workInProgress._debugSource=current._debugSource;workInProgress._debugOwner=current._debugOwner;workInProgress._debugHookTypes=current._debugHookTypes;}workInProgress.alternate=current;current.alternate=workInProgress;}else {workInProgress.pendingProps=pendingProps;// Needed because Blocks store data on type.
workInProgress.type=current.type;// We already have an alternate.
// Reset the effect tag.
workInProgress.flags=NoFlags;// The effects are no longer valid.
workInProgress.subtreeFlags=NoFlags;workInProgress.deletions=null;{// We intentionally reset, rather than copy, actualDuration & actualStartTime.
// This prevents time from endlessly accumulating in new commits.
// This has the downside of resetting values for different priority renders,
// But works for yielding (the common case) and should support resuming.
workInProgress.actualDuration=0;workInProgress.actualStartTime=-1;}}// Reset all effects except static ones.
// Static effects are not specific to a render.
workInProgress.flags=current.flags&StaticMask;workInProgress.childLanes=current.childLanes;workInProgress.lanes=current.lanes;workInProgress.child=current.child;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// Clone the dependencies object. This is mutated during the render phase, so
// it cannot be shared with the current fiber.
var currentDependencies=current.dependencies;workInProgress.dependencies=currentDependencies===null?null:{lanes:currentDependencies.lanes,firstContext:currentDependencies.firstContext};// These will be overridden during the parent's reconciliation
workInProgress.sibling=current.sibling;workInProgress.index=current.index;workInProgress.ref=current.ref;{workInProgress.selfBaseDuration=current.selfBaseDuration;workInProgress.treeBaseDuration=current.treeBaseDuration;}{workInProgress._debugNeedsRemount=current._debugNeedsRemount;switch(workInProgress.tag){case IndeterminateComponent:case FunctionComponent:case SimpleMemoComponent:workInProgress.type=resolveFunctionForHotReloading(current.type);break;case ClassComponent:workInProgress.type=resolveClassForHotReloading(current.type);break;case ForwardRef:workInProgress.type=resolveForwardRefForHotReloading(current.type);break;}}return workInProgress;}// Used to reuse a Fiber for a second pass.
function resetWorkInProgress(workInProgress,renderLanes){// This resets the Fiber to what createFiber or createWorkInProgress would
// have set the values to before during the first pass. Ideally this wouldn't
// be necessary but unfortunately many code paths reads from the workInProgress
// when they should be reading from current and writing to workInProgress.
// We assume pendingProps, index, key, ref, return are still untouched to
// avoid doing another reconciliation.
// Reset the effect flags but keep any Placement tags, since that's something
// that child fiber is setting, not the reconciliation.
workInProgress.flags&=StaticMask|Placement;// The effects are no longer valid.
var current=workInProgress.alternate;if(current===null){// Reset to createFiber's initial values.
workInProgress.childLanes=NoLanes;workInProgress.lanes=renderLanes;workInProgress.child=null;workInProgress.subtreeFlags=NoFlags;workInProgress.memoizedProps=null;workInProgress.memoizedState=null;workInProgress.updateQueue=null;workInProgress.dependencies=null;workInProgress.stateNode=null;{// Note: We don't reset the actualTime counts. It's useful to accumulate
// actual time across multiple render passes.
workInProgress.selfBaseDuration=0;workInProgress.treeBaseDuration=0;}}else {// Reset to the cloned values that createWorkInProgress would've.
workInProgress.childLanes=current.childLanes;workInProgress.lanes=current.lanes;workInProgress.child=current.child;workInProgress.subtreeFlags=NoFlags;workInProgress.deletions=null;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// Needed because Blocks store data on type.
workInProgress.type=current.type;// Clone the dependencies object. This is mutated during the render phase, so
// it cannot be shared with the current fiber.
var currentDependencies=current.dependencies;workInProgress.dependencies=currentDependencies===null?null:{lanes:currentDependencies.lanes,firstContext:currentDependencies.firstContext};{// Note: We don't reset the actualTime counts. It's useful to accumulate
// actual time across multiple render passes.
workInProgress.selfBaseDuration=current.selfBaseDuration;workInProgress.treeBaseDuration=current.treeBaseDuration;}}return workInProgress;}function createHostRootFiber(tag,isStrictMode,concurrentUpdatesByDefaultOverride){var mode;if(tag===ConcurrentRoot){mode=ConcurrentMode;if(isStrictMode===true){mode|=StrictLegacyMode;{mode|=StrictEffectsMode;}}}else {mode=NoMode;}if(isDevToolsPresent){// Always collect profile timings when DevTools are present.
// This enables DevTools to start capturing timing at any point–
// Without some nodes in the tree having empty base times.
mode|=ProfileMode;}return createFiber(HostRoot,null,null,mode);}function createFiberFromTypeAndProps(type,// React$ElementType
key,pendingProps,owner,mode,lanes){var fiberTag=IndeterminateComponent;// The resolved type is set if we know what the final type will be. I.e. it's not lazy.
var resolvedType=type;if(typeof type==='function'){if(shouldConstruct$1(type)){fiberTag=ClassComponent;{resolvedType=resolveClassForHotReloading(resolvedType);}}else {{resolvedType=resolveFunctionForHotReloading(resolvedType);}}}else if(typeof type==='string'){fiberTag=HostComponent;}else {getTag:switch(type){case REACT_FRAGMENT_TYPE:return createFiberFromFragment(pendingProps.children,mode,lanes,key);case REACT_STRICT_MODE_TYPE:fiberTag=Mode;mode|=StrictLegacyMode;if((mode&ConcurrentMode)!==NoMode){// Strict effects should never run on legacy roots
mode|=StrictEffectsMode;}break;case REACT_PROFILER_TYPE:return createFiberFromProfiler(pendingProps,mode,lanes,key);case REACT_SUSPENSE_TYPE:return createFiberFromSuspense(pendingProps,mode,lanes,key);case REACT_SUSPENSE_LIST_TYPE:return createFiberFromSuspenseList(pendingProps,mode,lanes,key);case REACT_OFFSCREEN_TYPE:return createFiberFromOffscreen(pendingProps,mode,lanes,key);case REACT_LEGACY_HIDDEN_TYPE:// eslint-disable-next-line no-fallthrough
case REACT_SCOPE_TYPE:// eslint-disable-next-line no-fallthrough
case REACT_CACHE_TYPE:// eslint-disable-next-line no-fallthrough
case REACT_TRACING_MARKER_TYPE:// eslint-disable-next-line no-fallthrough
case REACT_DEBUG_TRACING_MODE_TYPE:// eslint-disable-next-line no-fallthrough
default:{if(typeof type==='object'&&type!==null){switch(type.$$typeof){case REACT_PROVIDER_TYPE:fiberTag=ContextProvider;break getTag;case REACT_CONTEXT_TYPE:// This is a consumer
fiberTag=ContextConsumer;break getTag;case REACT_FORWARD_REF_TYPE:fiberTag=ForwardRef;{resolvedType=resolveForwardRefForHotReloading(resolvedType);}break getTag;case REACT_MEMO_TYPE:fiberTag=MemoComponent;break getTag;case REACT_LAZY_TYPE:fiberTag=LazyComponent;resolvedType=null;break getTag;}}var info='';{if(type===undefined||typeof type==='object'&&type!==null&&Object.keys(type).length===0){info+=' You likely forgot to export your component from the file '+"it's defined in, or you might have mixed up default and "+'named imports.';}var ownerName=owner?getComponentNameFromFiber(owner):null;if(ownerName){info+='\n\nCheck the render method of `'+ownerName+'`.';}}throw new Error('Element type is invalid: expected a string (for built-in '+'components) or a class/function (for composite components) '+("but got: "+(type==null?type:typeof type)+"."+info));}}}var fiber=createFiber(fiberTag,pendingProps,key,mode);fiber.elementType=type;fiber.type=resolvedType;fiber.lanes=lanes;{fiber._debugOwner=owner;}return fiber;}function createFiberFromElement(element,mode,lanes){var owner=null;{owner=element._owner;}var type=element.type;var key=element.key;var pendingProps=element.props;var fiber=createFiberFromTypeAndProps(type,key,pendingProps,owner,mode,lanes);{fiber._debugSource=element._source;fiber._debugOwner=element._owner;}return fiber;}function createFiberFromFragment(elements,mode,lanes,key){var fiber=createFiber(Fragment,elements,key,mode);fiber.lanes=lanes;return fiber;}function createFiberFromProfiler(pendingProps,mode,lanes,key){{if(typeof pendingProps.id!=='string'){error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',typeof pendingProps.id);}}var fiber=createFiber(Profiler,pendingProps,key,mode|ProfileMode);fiber.elementType=REACT_PROFILER_TYPE;fiber.lanes=lanes;{fiber.stateNode={effectDuration:0,passiveEffectDuration:0};}return fiber;}function createFiberFromSuspense(pendingProps,mode,lanes,key){var fiber=createFiber(SuspenseComponent,pendingProps,key,mode);fiber.elementType=REACT_SUSPENSE_TYPE;fiber.lanes=lanes;return fiber;}function createFiberFromSuspenseList(pendingProps,mode,lanes,key){var fiber=createFiber(SuspenseListComponent,pendingProps,key,mode);fiber.elementType=REACT_SUSPENSE_LIST_TYPE;fiber.lanes=lanes;return fiber;}function createFiberFromOffscreen(pendingProps,mode,lanes,key){var fiber=createFiber(OffscreenComponent,pendingProps,key,mode);fiber.elementType=REACT_OFFSCREEN_TYPE;fiber.lanes=lanes;var primaryChildInstance={isHidden:false};fiber.stateNode=primaryChildInstance;return fiber;}function createFiberFromText(content,mode,lanes){var fiber=createFiber(HostText,content,null,mode);fiber.lanes=lanes;return fiber;}function createFiberFromHostInstanceForDeletion(){var fiber=createFiber(HostComponent,null,null,NoMode);fiber.elementType='DELETED';return fiber;}function createFiberFromDehydratedFragment(dehydratedNode){var fiber=createFiber(DehydratedFragment,null,null,NoMode);fiber.stateNode=dehydratedNode;return fiber;}function createFiberFromPortal(portal,mode,lanes){var pendingProps=portal.children!==null?portal.children:[];var fiber=createFiber(HostPortal,pendingProps,portal.key,mode);fiber.lanes=lanes;fiber.stateNode={containerInfo:portal.containerInfo,pendingChildren:null,// Used by persistent updates
implementation:portal.implementation};return fiber;}// Used for stashing WIP properties to replay failed work in DEV.
function assignFiberPropertiesInDEV(target,source){if(target===null){// This Fiber's initial properties will always be overwritten.
// We only use a Fiber to ensure the same hidden class so DEV isn't slow.
target=createFiber(IndeterminateComponent,null,null,NoMode);}// This is intentionally written as a list of all properties.
// We tried to use Object.assign() instead but this is called in
// the hottest path, and Object.assign() was too slow:
// https://github.com/facebook/react/issues/12502
// This code is DEV-only so size is not a concern.
target.tag=source.tag;target.key=source.key;target.elementType=source.elementType;target.type=source.type;target.stateNode=source.stateNode;target.return=source.return;target.child=source.child;target.sibling=source.sibling;target.index=source.index;target.ref=source.ref;target.pendingProps=source.pendingProps;target.memoizedProps=source.memoizedProps;target.updateQueue=source.updateQueue;target.memoizedState=source.memoizedState;target.dependencies=source.dependencies;target.mode=source.mode;target.flags=source.flags;target.subtreeFlags=source.subtreeFlags;target.deletions=source.deletions;target.lanes=source.lanes;target.childLanes=source.childLanes;target.alternate=source.alternate;{target.actualDuration=source.actualDuration;target.actualStartTime=source.actualStartTime;target.selfBaseDuration=source.selfBaseDuration;target.treeBaseDuration=source.treeBaseDuration;}target._debugSource=source._debugSource;target._debugOwner=source._debugOwner;target._debugNeedsRemount=source._debugNeedsRemount;target._debugHookTypes=source._debugHookTypes;return target;}function FiberRootNode(containerInfo,tag,hydrate,identifierPrefix,onRecoverableError){this.tag=tag;this.containerInfo=containerInfo;this.pendingChildren=null;this.current=null;this.pingCache=null;this.finishedWork=null;this.timeoutHandle=noTimeout;this.context=null;this.pendingContext=null;this.callbackNode=null;this.callbackPriority=NoLane;this.eventTimes=createLaneMap(NoLanes);this.expirationTimes=createLaneMap(NoTimestamp);this.pendingLanes=NoLanes;this.suspendedLanes=NoLanes;this.pingedLanes=NoLanes;this.expiredLanes=NoLanes;this.mutableReadLanes=NoLanes;this.finishedLanes=NoLanes;this.entangledLanes=NoLanes;this.entanglements=createLaneMap(NoLanes);this.identifierPrefix=identifierPrefix;this.onRecoverableError=onRecoverableError;{this.mutableSourceEagerHydrationData=null;}{this.effectDuration=0;this.passiveEffectDuration=0;}{this.memoizedUpdaters=new Set();var pendingUpdatersLaneMap=this.pendingUpdatersLaneMap=[];for(var _i=0;_i<TotalLanes;_i++){pendingUpdatersLaneMap.push(new Set());}}{switch(tag){case ConcurrentRoot:this._debugRootType=hydrate?'hydrateRoot()':'createRoot()';break;case LegacyRoot:this._debugRootType=hydrate?'hydrate()':'render()';break;}}}function createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,// TODO: We have several of these arguments that are conceptually part of the
// host config, but because they are passed in at runtime, we have to thread
// them through the root constructor. Perhaps we should put them all into a
// single type, like a DynamicHostConfig that is defined by the renderer.
identifierPrefix,onRecoverableError,transitionCallbacks){var root=new FiberRootNode(containerInfo,tag,hydrate,identifierPrefix,onRecoverableError);// stateNode is any.
var uninitializedFiber=createHostRootFiber(tag,isStrictMode);root.current=uninitializedFiber;uninitializedFiber.stateNode=root;{var _initialState={element:initialChildren,isDehydrated:hydrate,cache:null,// not enabled yet
transitions:null,pendingSuspenseBoundaries:null};uninitializedFiber.memoizedState=_initialState;}initializeUpdateQueue(uninitializedFiber);return root;}var ReactVersion='18.2.0';function createPortal(children,containerInfo,// TODO: figure out the API for cross-renderer implementation.
implementation){var key=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;{checkKeyStringCoercion(key);}return {// This tag allow us to uniquely identify this as a React Portal
$$typeof:REACT_PORTAL_TYPE,key:key==null?null:''+key,children:children,containerInfo:containerInfo,implementation:implementation};}var didWarnAboutNestedUpdates;var didWarnAboutFindNodeInStrictMode;{didWarnAboutNestedUpdates=false;didWarnAboutFindNodeInStrictMode={};}function getContextForSubtree(parentComponent){if(!parentComponent){return emptyContextObject;}var fiber=get(parentComponent);var parentContext=findCurrentUnmaskedContext(fiber);if(fiber.tag===ClassComponent){var Component=fiber.type;if(isContextProvider(Component)){return processChildContext(fiber,Component,parentContext);}}return parentContext;}function findHostInstanceWithWarning(component,methodName){{var fiber=get(component);if(fiber===undefined){if(typeof component.render==='function'){throw new Error('Unable to find node on an unmounted component.');}else {var keys=Object.keys(component).join(',');throw new Error("Argument appears to not be a ReactComponent. Keys: "+keys);}}var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}if(hostFiber.mode&StrictLegacyMode){var componentName=getComponentNameFromFiber(fiber)||'Component';if(!didWarnAboutFindNodeInStrictMode[componentName]){didWarnAboutFindNodeInStrictMode[componentName]=true;var previousFiber=current;try{setCurrentFiber(hostFiber);if(fiber.mode&StrictLegacyMode){error('%s is deprecated in StrictMode. '+'%s was passed an instance of %s which is inside StrictMode. '+'Instead, add a ref directly to the element you want to reference. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-find-node',methodName,methodName,componentName);}else {error('%s is deprecated in StrictMode. '+'%s was passed an instance of %s which renders StrictMode children. '+'Instead, add a ref directly to the element you want to reference. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-find-node',methodName,methodName,componentName);}}finally{// Ideally this should reset to previous but this shouldn't be called in
// render and there's another warning for that anyway.
if(previousFiber){setCurrentFiber(previousFiber);}else {resetCurrentFiber();}}}}return hostFiber.stateNode;}}function createContainer(containerInfo,tag,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){var hydrate=false;var initialChildren=null;return createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);}function createHydrationContainer(initialChildren,// TODO: Remove `callback` when we delete legacy mode.
callback,containerInfo,tag,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){var hydrate=true;var root=createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);// TODO: Move this to FiberRoot constructor
root.context=getContextForSubtree(null);// Schedule the initial render. In a hydration root, this is different from
// a regular update because the initial render must match was was rendered
// on the server.
// NOTE: This update intentionally doesn't have a payload. We're only using
// the update to schedule work on the root fiber (and, for legacy roots, to
// enqueue the callback if one is provided).
var current=root.current;var eventTime=requestEventTime();var lane=requestUpdateLane(current);var update=createUpdate(eventTime,lane);update.callback=callback!==undefined&&callback!==null?callback:null;enqueueUpdate(current,update,lane);scheduleInitialHydrationOnRoot(root,lane,eventTime);return root;}function updateContainer(element,container,parentComponent,callback){{onScheduleRoot(container,element);}var current$1=container.current;var eventTime=requestEventTime();var lane=requestUpdateLane(current$1);{markRenderScheduled(lane);}var context=getContextForSubtree(parentComponent);if(container.context===null){container.context=context;}else {container.pendingContext=context;}{if(isRendering&&current!==null&&!didWarnAboutNestedUpdates){didWarnAboutNestedUpdates=true;error('Render methods should be a pure function of props and state; '+'triggering nested component updates from render is not allowed. '+'If necessary, trigger nested updates in componentDidUpdate.\n\n'+'Check the render method of %s.',getComponentNameFromFiber(current)||'Unknown');}}var update=createUpdate(eventTime,lane);// Caution: React DevTools currently depends on this property
// being called "element".
update.payload={element:element};callback=callback===undefined?null:callback;if(callback!==null){{if(typeof callback!=='function'){error('render(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callback);}}update.callback=callback;}var root=enqueueUpdate(current$1,update,lane);if(root!==null){scheduleUpdateOnFiber(root,current$1,lane,eventTime);entangleTransitions(root,current$1,lane);}return lane;}function getPublicRootInstance(container){var containerFiber=container.current;if(!containerFiber.child){return null;}switch(containerFiber.child.tag){case HostComponent:return getPublicInstance(containerFiber.child.stateNode);default:return containerFiber.child.stateNode;}}function attemptSynchronousHydration$1(fiber){switch(fiber.tag){case HostRoot:{var root=fiber.stateNode;if(isRootDehydrated(root)){// Flush the first scheduled "update".
var lanes=getHighestPriorityPendingLanes(root);flushRoot(root,lanes);}break;}case SuspenseComponent:{flushSync(function(){var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,SyncLane,eventTime);}});// If we're still blocked after this, we need to increase
// the priority of any promises resolving within this
// boundary so that they next attempt also has higher pri.
var retryLane=SyncLane;markRetryLaneIfNotHydrated(fiber,retryLane);break;}}}function markRetryLaneImpl(fiber,retryLane){var suspenseState=fiber.memoizedState;if(suspenseState!==null&&suspenseState.dehydrated!==null){suspenseState.retryLane=higherPriorityLane(suspenseState.retryLane,retryLane);}}// Increases the priority of thenables when they resolve within this boundary.
function markRetryLaneIfNotHydrated(fiber,retryLane){markRetryLaneImpl(fiber,retryLane);var alternate=fiber.alternate;if(alternate){markRetryLaneImpl(alternate,retryLane);}}function attemptContinuousHydration$1(fiber){if(fiber.tag!==SuspenseComponent){// We ignore HostRoots here because we can't increase
// their priority and they should not suspend on I/O,
// since you have to wrap anything that might suspend in
// Suspense.
return;}var lane=SelectiveHydrationLane;var root=enqueueConcurrentRenderForLane(fiber,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);}markRetryLaneIfNotHydrated(fiber,lane);}function attemptHydrationAtCurrentPriority$1(fiber){if(fiber.tag!==SuspenseComponent){// We ignore HostRoots here because we can't increase
// their priority other than synchronously flush it.
return;}var lane=requestUpdateLane(fiber);var root=enqueueConcurrentRenderForLane(fiber,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);}markRetryLaneIfNotHydrated(fiber,lane);}function findHostInstanceWithNoPortals(fiber){var hostFiber=findCurrentHostFiberWithNoPortals(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}var shouldErrorImpl=function(fiber){return null;};function shouldError(fiber){return shouldErrorImpl(fiber);}var shouldSuspendImpl=function(fiber){return false;};function shouldSuspend(fiber){return shouldSuspendImpl(fiber);}var overrideHookState=null;var overrideHookStateDeletePath=null;var overrideHookStateRenamePath=null;var overrideProps=null;var overridePropsDeletePath=null;var overridePropsRenamePath=null;var scheduleUpdate=null;var setErrorHandler=null;var setSuspenseHandler=null;{var copyWithDeleteImpl=function(obj,path,index){var key=path[index];var updated=isArray(obj)?obj.slice():assign({},obj);if(index+1===path.length){if(isArray(updated)){updated.splice(key,1);}else {delete updated[key];}return updated;}// $FlowFixMe number or string is fine here
updated[key]=copyWithDeleteImpl(obj[key],path,index+1);return updated;};var copyWithDelete=function(obj,path){return copyWithDeleteImpl(obj,path,0);};var copyWithRenameImpl=function(obj,oldPath,newPath,index){var oldKey=oldPath[index];var updated=isArray(obj)?obj.slice():assign({},obj);if(index+1===oldPath.length){var newKey=newPath[index];// $FlowFixMe number or string is fine here
updated[newKey]=updated[oldKey];if(isArray(updated)){updated.splice(oldKey,1);}else {delete updated[oldKey];}}else {// $FlowFixMe number or string is fine here
updated[oldKey]=copyWithRenameImpl(// $FlowFixMe number or string is fine here
obj[oldKey],oldPath,newPath,index+1);}return updated;};var copyWithRename=function(obj,oldPath,newPath){if(oldPath.length!==newPath.length){warn('copyWithRename() expects paths of the same length');return;}else {for(var i=0;i<newPath.length-1;i++){if(oldPath[i]!==newPath[i]){warn('copyWithRename() expects paths to be the same except for the deepest key');return;}}}return copyWithRenameImpl(obj,oldPath,newPath,0);};var copyWithSetImpl=function(obj,path,index,value){if(index>=path.length){return value;}var key=path[index];var updated=isArray(obj)?obj.slice():assign({},obj);// $FlowFixMe number or string is fine here
updated[key]=copyWithSetImpl(obj[key],path,index+1,value);return updated;};var copyWithSet=function(obj,path,value){return copyWithSetImpl(obj,path,0,value);};var findHook=function(fiber,id){// For now, the "id" of stateful hooks is just the stateful hook index.
// This may change in the future with e.g. nested hooks.
var currentHook=fiber.memoizedState;while(currentHook!==null&&id>0){currentHook=currentHook.next;id--;}return currentHook;};// Support DevTools editable values for useState and useReducer.
overrideHookState=function(fiber,id,path,value){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithSet(hook.memoizedState,path,value);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,
// because there is no update we can add for useReducer hooks that won't trigger an error.
// (There's no appropriate action type for DevTools overrides.)
// As a result though, React will see the scheduled update as a noop and bailout.
// Shallow cloning props works as a workaround for now to bypass the bailout check.
fiber.memoizedProps=assign({},fiber.memoizedProps);var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}};overrideHookStateDeletePath=function(fiber,id,path){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithDelete(hook.memoizedState,path);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,
// because there is no update we can add for useReducer hooks that won't trigger an error.
// (There's no appropriate action type for DevTools overrides.)
// As a result though, React will see the scheduled update as a noop and bailout.
// Shallow cloning props works as a workaround for now to bypass the bailout check.
fiber.memoizedProps=assign({},fiber.memoizedProps);var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}};overrideHookStateRenamePath=function(fiber,id,oldPath,newPath){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithRename(hook.memoizedState,oldPath,newPath);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,
// because there is no update we can add for useReducer hooks that won't trigger an error.
// (There's no appropriate action type for DevTools overrides.)
// As a result though, React will see the scheduled update as a noop and bailout.
// Shallow cloning props works as a workaround for now to bypass the bailout check.
fiber.memoizedProps=assign({},fiber.memoizedProps);var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}};// Support DevTools props for function components, forwardRef, memo, host components, etc.
overrideProps=function(fiber,path,value){fiber.pendingProps=copyWithSet(fiber.memoizedProps,path,value);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};overridePropsDeletePath=function(fiber,path){fiber.pendingProps=copyWithDelete(fiber.memoizedProps,path);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};overridePropsRenamePath=function(fiber,oldPath,newPath){fiber.pendingProps=copyWithRename(fiber.memoizedProps,oldPath,newPath);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};scheduleUpdate=function(fiber){var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};setErrorHandler=function(newShouldErrorImpl){shouldErrorImpl=newShouldErrorImpl;};setSuspenseHandler=function(newShouldSuspendImpl){shouldSuspendImpl=newShouldSuspendImpl;};}function findHostInstanceByFiber(fiber){var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}function emptyFindFiberByHostInstance(instance){return null;}function getCurrentFiberForDevTools(){return current;}function injectIntoDevTools(devToolsConfig){var findFiberByHostInstance=devToolsConfig.findFiberByHostInstance;var ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;return injectInternals({bundleType:devToolsConfig.bundleType,version:devToolsConfig.version,rendererPackageName:devToolsConfig.rendererPackageName,rendererConfig:devToolsConfig.rendererConfig,overrideHookState:overrideHookState,overrideHookStateDeletePath:overrideHookStateDeletePath,overrideHookStateRenamePath:overrideHookStateRenamePath,overrideProps:overrideProps,overridePropsDeletePath:overridePropsDeletePath,overridePropsRenamePath:overridePropsRenamePath,setErrorHandler:setErrorHandler,setSuspenseHandler:setSuspenseHandler,scheduleUpdate:scheduleUpdate,currentDispatcherRef:ReactCurrentDispatcher,findHostInstanceByFiber:findHostInstanceByFiber,findFiberByHostInstance:findFiberByHostInstance||emptyFindFiberByHostInstance,// React Refresh
findHostInstancesForRefresh:findHostInstancesForRefresh,scheduleRefresh:scheduleRefresh,scheduleRoot:scheduleRoot,setRefreshHandler:setRefreshHandler,// Enables DevTools to append owner stacks to error messages in DEV mode.
getCurrentFiber:getCurrentFiberForDevTools,// Enables DevTools to detect reconciler version rather than renderer version
// which may not match for third party renderers.
reconcilerVersion:ReactVersion});}/* global reportError */var defaultOnRecoverableError=typeof reportError==='function'?// In modern browsers, reportError will dispatch an error event,
// emulating an uncaught JavaScript error.
reportError:function(error){// In older browsers and test environments, fallback to console.error.
// eslint-disable-next-line react-internal/no-production-logging
console['error'](error);};function ReactDOMRoot(internalRoot){this._internalRoot=internalRoot;}ReactDOMHydrationRoot.prototype.render=ReactDOMRoot.prototype.render=function(children){var root=this._internalRoot;if(root===null){throw new Error('Cannot update an unmounted root.');}{if(typeof arguments[1]==='function'){error('render(...): does not support the second callback argument. '+'To execute a side effect after rendering, declare it in a component body with useEffect().');}else if(isValidContainer(arguments[1])){error('You passed a container to the second argument of root.render(...). '+"You don't need to pass it again since you already passed it to create the root.");}else if(typeof arguments[1]!=='undefined'){error('You passed a second argument to root.render(...) but it only accepts '+'one argument.');}var container=root.containerInfo;if(container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(root.current);if(hostInstance){if(hostInstance.parentNode!==container){error('render(...): It looks like the React-rendered content of the '+'root container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+"root.unmount() to empty a root's container.");}}}}updateContainer(children,root,null,null);};ReactDOMHydrationRoot.prototype.unmount=ReactDOMRoot.prototype.unmount=function(){{if(typeof arguments[0]==='function'){error('unmount(...): does not support a callback argument. '+'To execute a side effect after rendering, declare it in a component body with useEffect().');}}var root=this._internalRoot;if(root!==null){this._internalRoot=null;var container=root.containerInfo;{if(isAlreadyRendering()){error('Attempted to synchronously unmount a root while React was already '+'rendering. React cannot finish unmounting the root until the '+'current render has completed, which may lead to a race condition.');}}flushSync(function(){updateContainer(null,root,null,null);});unmarkContainerAsRoot(container);}};function createRoot(container,options){if(!isValidContainer(container)){throw new Error('createRoot(...): Target container is not a DOM element.');}warnIfReactDOMContainerInDEV(container);var isStrictMode=false;var concurrentUpdatesByDefaultOverride=false;var identifierPrefix='';var onRecoverableError=defaultOnRecoverableError;if(options!==null&&options!==undefined){{if(options.hydrate){warn('hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.');}else {if(typeof options==='object'&&options!==null&&options.$$typeof===REACT_ELEMENT_TYPE){error('You passed a JSX element to createRoot. You probably meant to '+'call root.render instead. '+'Example usage:\n\n'+'  let root = createRoot(domContainer);\n'+'  root.render(<App />);');}}}if(options.unstable_strictMode===true){isStrictMode=true;}if(options.identifierPrefix!==undefined){identifierPrefix=options.identifierPrefix;}if(options.onRecoverableError!==undefined){onRecoverableError=options.onRecoverableError;}if(options.transitionCallbacks!==undefined){options.transitionCallbacks;}}var root=createContainer(container,ConcurrentRoot,null,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);markContainerAsRoot(root.current,container);var rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(rootContainerElement);return new ReactDOMRoot(root);}function ReactDOMHydrationRoot(internalRoot){this._internalRoot=internalRoot;}function scheduleHydration(target){if(target){queueExplicitHydrationTarget(target);}}ReactDOMHydrationRoot.prototype.unstable_scheduleHydration=scheduleHydration;function hydrateRoot(container,initialChildren,options){if(!isValidContainer(container)){throw new Error('hydrateRoot(...): Target container is not a DOM element.');}warnIfReactDOMContainerInDEV(container);{if(initialChildren===undefined){error('Must provide initial children as second argument to hydrateRoot. '+'Example usage: hydrateRoot(domContainer, <App />)');}}// For now we reuse the whole bag of options since they contain
// the hydration callbacks.
var hydrationCallbacks=options!=null?options:null;// TODO: Delete this option
var mutableSources=options!=null&&options.hydratedSources||null;var isStrictMode=false;var concurrentUpdatesByDefaultOverride=false;var identifierPrefix='';var onRecoverableError=defaultOnRecoverableError;if(options!==null&&options!==undefined){if(options.unstable_strictMode===true){isStrictMode=true;}if(options.identifierPrefix!==undefined){identifierPrefix=options.identifierPrefix;}if(options.onRecoverableError!==undefined){onRecoverableError=options.onRecoverableError;}}var root=createHydrationContainer(initialChildren,null,container,ConcurrentRoot,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);markContainerAsRoot(root.current,container);// This can't be a comment node since hydration doesn't work on comment nodes anyway.
listenToAllSupportedEvents(container);if(mutableSources){for(var i=0;i<mutableSources.length;i++){var mutableSource=mutableSources[i];registerMutableSourceForHydration(root,mutableSource);}}return new ReactDOMHydrationRoot(root);}function isValidContainer(node){return !!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||!disableCommentsAsDOMContainers));}// TODO: Remove this function which also includes comment nodes.
// We only use it in places that are currently more relaxed.
function isValidContainerLegacy(node){return !!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||node.nodeType===COMMENT_NODE&&node.nodeValue===' react-mount-point-unstable '));}function warnIfReactDOMContainerInDEV(container){{if(container.nodeType===ELEMENT_NODE&&container.tagName&&container.tagName.toUpperCase()==='BODY'){error('createRoot(): Creating roots directly with document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try using a container element created '+'for your app.');}if(isContainerMarkedAsRoot(container)){if(container._reactRootContainer){error('You are calling ReactDOMClient.createRoot() on a container that was previously '+'passed to ReactDOM.render(). This is not supported.');}else {error('You are calling ReactDOMClient.createRoot() on a container that '+'has already been passed to createRoot() before. Instead, call '+'root.render() on the existing root instead if you want to update it.');}}}}var ReactCurrentOwner$3=ReactSharedInternals.ReactCurrentOwner;var topLevelUpdateWarnings;{topLevelUpdateWarnings=function(container){if(container._reactRootContainer&&container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(container._reactRootContainer.current);if(hostInstance){if(hostInstance.parentNode!==container){error('render(...): It looks like the React-rendered content of this '+'container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+'ReactDOM.unmountComponentAtNode to empty a container.');}}}var isRootRenderedBySomeReact=!!container._reactRootContainer;var rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(rootEl&&getInstanceFromNode(rootEl));if(hasNonRootReactChild&&!isRootRenderedBySomeReact){error('render(...): Replacing React-rendered children with a new root '+'component. If you intended to update the children of this node, '+'you should instead have the existing children update their state '+'and render the new components instead of calling ReactDOM.render.');}if(container.nodeType===ELEMENT_NODE&&container.tagName&&container.tagName.toUpperCase()==='BODY'){error('render(): Rendering components directly into document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try rendering into a container element created '+'for your app.');}};}function getReactRootElementInContainer(container){if(!container){return null;}if(container.nodeType===DOCUMENT_NODE){return container.documentElement;}else {return container.firstChild;}}function noopOnRecoverableError(){// This isn't reachable because onRecoverableError isn't called in the
// legacy API.
}function legacyCreateRootFromDOMContainer(container,initialChildren,parentComponent,callback,isHydrationContainer){if(isHydrationContainer){if(typeof callback==='function'){var originalCallback=callback;callback=function(){var instance=getPublicRootInstance(root);originalCallback.call(instance);};}var root=createHydrationContainer(initialChildren,callback,container,LegacyRoot,null,// hydrationCallbacks
false,// isStrictMode
false,// concurrentUpdatesByDefaultOverride,
'',// identifierPrefix
noopOnRecoverableError);container._reactRootContainer=root;markContainerAsRoot(root.current,container);var rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(rootContainerElement);flushSync();return root;}else {// First clear any existing content.
var rootSibling;while(rootSibling=container.lastChild){container.removeChild(rootSibling);}if(typeof callback==='function'){var _originalCallback=callback;callback=function(){var instance=getPublicRootInstance(_root);_originalCallback.call(instance);};}var _root=createContainer(container,LegacyRoot,null,// hydrationCallbacks
false,// isStrictMode
false,// concurrentUpdatesByDefaultOverride,
'',// identifierPrefix
noopOnRecoverableError);container._reactRootContainer=_root;markContainerAsRoot(_root.current,container);var _rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(_rootContainerElement);// Initial mount should not be batched.
flushSync(function(){updateContainer(initialChildren,_root,parentComponent,callback);});return _root;}}function warnOnInvalidCallback$1(callback,callerName){{if(callback!==null&&typeof callback!=='function'){error('%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);}}}function legacyRenderSubtreeIntoContainer(parentComponent,children,container,forceHydrate,callback){{topLevelUpdateWarnings(container);warnOnInvalidCallback$1(callback===undefined?null:callback,'render');}var maybeRoot=container._reactRootContainer;var root;if(!maybeRoot){// Initial mount
root=legacyCreateRootFromDOMContainer(container,children,parentComponent,callback,forceHydrate);}else {root=maybeRoot;if(typeof callback==='function'){var originalCallback=callback;callback=function(){var instance=getPublicRootInstance(root);originalCallback.call(instance);};}// Update
updateContainer(children,root,parentComponent,callback);}return getPublicRootInstance(root);}function findDOMNode(componentOrElement){{var owner=ReactCurrentOwner$3.current;if(owner!==null&&owner.stateNode!==null){var warnedAboutRefsInRender=owner.stateNode._warnedAboutRefsInRender;if(!warnedAboutRefsInRender){error('%s is accessing findDOMNode inside its render(). '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentNameFromType(owner.type)||'A component');}owner.stateNode._warnedAboutRefsInRender=true;}}if(componentOrElement==null){return null;}if(componentOrElement.nodeType===ELEMENT_NODE){return componentOrElement;}{return findHostInstanceWithWarning(componentOrElement,'findDOMNode');}}function hydrate(element,container,callback){{error('ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot '+'instead. Until you switch to the new API, your app will behave as '+"if it's running React 17. Learn "+'more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(container)){throw new Error('Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.hydrate() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. '+'Did you mean to call hydrateRoot(container, element)?');}}// TODO: throw or warn if we couldn't hydrate?
return legacyRenderSubtreeIntoContainer(null,element,container,true,callback);}function render(element,container,callback){{error('ReactDOM.render is no longer supported in React 18. Use createRoot '+'instead. Until you switch to the new API, your app will behave as '+"if it's running React 17. Learn "+'more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(container)){throw new Error('Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.render() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. '+'Did you mean to call root.render(element)?');}}return legacyRenderSubtreeIntoContainer(null,element,container,false,callback);}function unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){{error('ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported '+'in React 18. Consider using a portal instead. Until you switch to '+"the createRoot API, your app will behave as if it's running React "+'17. Learn more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(containerNode)){throw new Error('Target container is not a DOM element.');}if(parentComponent==null||!has(parentComponent)){throw new Error('parentComponent must be a valid React Component');}return legacyRenderSubtreeIntoContainer(parentComponent,element,containerNode,false,callback);}function unmountComponentAtNode(container){if(!isValidContainerLegacy(container)){throw new Error('unmountComponentAtNode(...): Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.unmountComponentAtNode() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?');}}if(container._reactRootContainer){{var rootEl=getReactRootElementInContainer(container);var renderedByDifferentReact=rootEl&&!getInstanceFromNode(rootEl);if(renderedByDifferentReact){error("unmountComponentAtNode(): The node you're attempting to unmount "+'was rendered by another copy of React.');}}// Unmount should not be batched.
flushSync(function(){legacyRenderSubtreeIntoContainer(null,null,container,false,function(){// $FlowFixMe This should probably use `delete container._reactRootContainer`
container._reactRootContainer=null;unmarkContainerAsRoot(container);});});// If you call unmountComponentAtNode twice in quick succession, you'll
// get `true` twice. That's probably fine?
return true;}else {{var _rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(_rootEl&&getInstanceFromNode(_rootEl));// Check if the container itself is a React root node.
var isContainerReactRoot=container.nodeType===ELEMENT_NODE&&isValidContainerLegacy(container.parentNode)&&!!container.parentNode._reactRootContainer;if(hasNonRootReactChild){error("unmountComponentAtNode(): The node you're attempting to unmount "+'was rendered by React and is not a top-level container. %s',isContainerReactRoot?'You may have accidentally passed in a React root node instead '+'of its container.':'Instead, have the parent component update its state and '+'rerender in order to remove this component.');}}return false;}}setAttemptSynchronousHydration(attemptSynchronousHydration$1);setAttemptContinuousHydration(attemptContinuousHydration$1);setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);setGetCurrentUpdatePriority(getCurrentUpdatePriority);setAttemptHydrationAtPriority(runWithPriority);{if(typeof Map!=='function'||// $FlowIssue Flow incorrectly thinks Map has no prototype
Map.prototype==null||typeof Map.prototype.forEach!=='function'||typeof Set!=='function'||// $FlowIssue Flow incorrectly thinks Set has no prototype
Set.prototype==null||typeof Set.prototype.clear!=='function'||typeof Set.prototype.forEach!=='function'){error('React depends on Map and Set built-in types. Make sure that you load a '+'polyfill in older browsers. https://reactjs.org/link/react-polyfills');}}setRestoreImplementation(restoreControlledState$3);setBatchingImplementation(batchedUpdates$1,discreteUpdates,flushSync);function createPortal$1(children,container){var key=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;if(!isValidContainer(container)){throw new Error('Target container is not a DOM element.');}// TODO: pass ReactDOM portal implementation as third argument
// $FlowFixMe The Flow type is opaque but there's no way to actually create it.
return createPortal(children,container,null,key);}function renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){return unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback);}var Internals={usingClientEntryPoint:false,// Keep in sync with ReactTestUtils.js.
// This is an array for better minification.
Events:[getInstanceFromNode,getNodeFromInstance,getFiberCurrentPropsFromNode,enqueueStateRestore,restoreStateIfNeeded,batchedUpdates$1]};function createRoot$1(container,options){{if(!Internals.usingClientEntryPoint&&!false){error('You are importing createRoot from "react-dom" which is not supported. '+'You should instead import it from "react-dom/client".');}}return createRoot(container,options);}function hydrateRoot$1(container,initialChildren,options){{if(!Internals.usingClientEntryPoint&&!false){error('You are importing hydrateRoot from "react-dom" which is not supported. '+'You should instead import it from "react-dom/client".');}}return hydrateRoot(container,initialChildren,options);}// Overload the definition to the two valid signatures.
// Warning, this opts-out of checking the function body.
// eslint-disable-next-line no-redeclare
function flushSync$1(fn){{if(isAlreadyRendering()){error('flushSync was called from inside a lifecycle method. React cannot '+'flush when React is already rendering. Consider moving this call to '+'a scheduler task or micro task.');}}return flushSync(fn);}var foundDevTools=injectIntoDevTools({findFiberByHostInstance:getClosestInstanceFromNode,bundleType:1,version:ReactVersion,rendererPackageName:'react-dom'});{if(!foundDevTools&&canUseDOM&&window.top===window.self){// If we're in Chrome or Firefox, provide a download link if not installed.
if(navigator.userAgent.indexOf('Chrome')>-1&&navigator.userAgent.indexOf('Edge')===-1||navigator.userAgent.indexOf('Firefox')>-1){var protocol=window.location.protocol;// Don't warn in exotic cases like chrome-extension://.
if(/^(https?|file):$/.test(protocol)){// eslint-disable-next-line react-internal/no-production-logging
console.info('%cDownload the React DevTools '+'for a better development experience: '+'https://reactjs.org/link/react-devtools'+(protocol==='file:'?'\nYou might need to use a local HTTP server (instead of file://): '+'https://reactjs.org/link/react-devtools-faq':''),'font-weight:bold');}}}}reactDom_development.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Internals;reactDom_development.createPortal=createPortal$1;reactDom_development.createRoot=createRoot$1;reactDom_development.findDOMNode=findDOMNode;reactDom_development.flushSync=flushSync$1;reactDom_development.hydrate=hydrate;reactDom_development.hydrateRoot=hydrateRoot$1;reactDom_development.render=render;reactDom_development.unmountComponentAtNode=unmountComponentAtNode;reactDom_development.unstable_batchedUpdates=batchedUpdates$1;reactDom_development.unstable_renderSubtreeIntoContainer=renderSubtreeIntoContainer;reactDom_development.version=ReactVersion;/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined'&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop==='function'){__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());}})();}

{
  reactDom.exports = reactDom_development;
}

var reactDomExports = reactDom.exports;
var ReactDOM = /*@__PURE__*/getDefaultExportFromCjs(reactDomExports);

function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;
  if (!css || typeof document === 'undefined') {
    return;
  }
  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';
  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = ".App {\n  text-align: center;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  width: 100vw;\n  height: 100vh;\n}\n";
styleInject(css_248z);

var img = "data:image/gif;base64,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";

function App() {
  return /*#__PURE__*/React.createElement("div", {
    className: "App"
  }, /*#__PURE__*/React.createElement("img", {
    src: img,
    alt: "logo"
  }), /*#__PURE__*/React.createElement("p", null, "Edit ", /*#__PURE__*/React.createElement("code", null, "src/App.js"), " and save to reload."));
}

ReactDOM.render( /*#__PURE__*/React.createElement(App, null), document.querySelector('#root'));
